#!/bin/bash
#
if [ $UID -ne 0 ]; then echo Please run this script as root; exit 1; fi
LFS=$LFS
echo "LFS is set to $LFS"
if [ "$LFS" = "" ]; then
  echo "The LFS variable is not set"
  echo "do: export LFS=/mnt/lfs to install LFS on a target machine"
  echo "    export LFS=local to install LFS on this (local) machine"
  echo  
  exit 1
fi
# repository will be for LFS
REPO="LFS"
#
if [ "$LFS" = /mnt/lfs ]; then # check for the directory
  if [ ! -d $LFS ]; then
    echo "Directory $LFS doesn't exist"
    echo "Create it to continue"
    exit 1
  fi
elif [ "$LFS" = local ]; then
  LFS="/" # local machine
else
  echo "Don't recognise env variable LFS as $LFS. Edit this script to respond to $LFS."
  echo "Or else do: export LFS=/mnt/lfs"
  exit 1
fi
#
if [ -e $LFS/tools ]; then
  if [ ! -d $LFS/tools ]; then
    echo "$LFS/tools is not a directory"
    mv -v $LFS/tools $LFS/tools.backup
    echo "file $LFS/tools moved to $LFS/tools.backup"
    echo "create directory $LFS/tools"
    install -vdm755 $LFS/tools
    if [ "$LFS/tools" != "$( ls -l /tools | awk '{print $NF}' )" ]; then
      echo "/tools is not a symlink to $LFS/tools"
      echo ""
      echo "as root, do:"
      echo ""
      echo " ln -s $LFS/tools /tools"
      exit 1
    fi
  else
    echo "tools dir ${LFS}/tools exists"
  fi
else
  install -vdm755 ${LFS}/tools
fi
#
#display_menu=true # by default, edit the config file
# set up default config filename
if [ "$LFS" = /mnt/lfs -o "$LFS" = "/" ]; then
  lfs="lfs"
  lfsUC=${lfs^^} # uppercase version of $lfs
  cfg=~/${lfsUC}.conf
else
  echo "*** Don't recognise $LFS. Make sure this script will work with that. ***"
fi
# this following bit allows you to give a config filename as $1 and use it unedited
#if [ ! -z "$1" ]; then # config filename given - use it unedited
#  cfg=$1 # full name of the config file
# check it exists
#  if [ ! -e $cfg ]; then # doesn't exist - exit
#    echo "If you give the config filename it must exist"
#    echo "Exiting now"
#    exit 1
#  else
#    display_menu=false # do not change the config file
#  fi
#fi
# output the env var LFS in a file in /home/lfs so can source it in chapter05
if [ -d /home/lfs ]; then # make sure .bash_profile and .bashrc exist
  if [ -e /home/lfs/.bashrc  ]; then
    if [ -e /home/lfs/defineLFS ]; then rm -v /home/lfs/defineLFS; fi
# remove LFS env variable in .bashrc in case LFS=local
    sed -e '/LFS=\/mnt\/lfs/d' \
        -e 's/LFS LC_ALL/LC_ALL/' \
        -i /home/lfs/.bashrc
    cat > /home/lfs/defineLFS << "EOF"
# this is sourced by .bashrc when su - lfs is done in chapter05
EOF
    echo export LFS=\"$LFS\" >> /home/lfs/defineLFS
#    chown lfs:lfs /home/lfs/defineLFS
# does the .bashrc file contain the source defineLFS line?
    sourcePres=$(egrep -w 'source|defineLFS' /home/lfs/.bashrc)
    if [ "$sourcePres" != "source /home/lfs/defineLFS" ]; then
      sed -i '/export/a source \/home\/lfs\/defineLFS' /home/lfs/.bashrc
    fi
  else # .bashrc doesn't exist so create it
    cat > /home/lfs/.bashrc << "EOF"
set +h
umask 022
LC_ALL=POSIX
LFS_TGT=$(uname -m)-lfs-linux-gnu
PATH=/usr/bin
if [ ! -L /bin ]; then PATH=/bin:$PATH; fi
PATH=$LFS/tools/bin:$PATH
CONFIG_SITE=$LFS/usr/share/config.site
export LC_ALL LFS_TGT PATH CONFIG_SITE
EOF
    if [ -e /home/lfs/defineLFS ]; then rm -v /home/lfs/defineLFS; fi # in case it exists
    cat > /home/lfs/defineLFS << "EOF"
# this is sourced by .bashrc when su - lfs is done in chapter05
EOF
    echo export LFS=\"$LFS\" >> /home/lfs/defineLFS
# now source defineLFS
    sed -i '/export/a source \/home\/lfs\/defineLFS' /home/lfs/.bashrc
# does /home/lfs/.bash_profile exist
    if [ ! -e "/home/lfs/.bash_profile" ]; then # create it
      cat > /home/lfs/.bash_profile << "EOF"
exec env -i HOME=$HOME TERM=$TERM PS1='\u:\w\$ ' /bin/bash
EOF
    fi
  fi
else
  echo "user lfs doesn't exist - will create the group and user lfs"
  groupadd lfs
  useradd -s /bin/bash -g lfs -m -k /dev/null lfs
  chown -v lfs ${LFS}/tools
  if [ ! -d ${LFS}/sources ]; then mkdir -v ${LFS}/sources; fi
  chown -v lfs $LFS/sources
  cat > /home/lfs/.bash_profile << "EOF"
exec env -i HOME=$HOME TERM=$TERM PS1='\u:\w\$ ' /bin/bash
EOF
cat > /home/lfs/.bashrc << "EOF"
set +h
umask 022
LC_ALL=POSIX
LFS_TGT=$(uname -m)-lfs-linux-gnu
PATH=/usr/bin
if [ ! -L /bin ]; then PATH=/bin:$PATH; fi
PATH=$LFS/tools/bin:$PATH
CONFIG_SITE=$LFS/usr/share/config.site
export LC_ALL LFS_TGT PATH CONFIG_SITE
EOF
  cat > /home/lfs/defineLFS << "EOF"
# this is sourced by .bashrc when su - lfs is done in chapter05
EOF
  echo export LFS=\"$LFS\" >> /home/lfs/defineLFS
#  chown lfs:lfs /home/lfs/{.bash_profile,.bashrc,defineLFS}
  echo "*** NOTE - You need to set a password for user lfs ***"
fi
lfscommands=${lfs}-commands # the dir containing the lfs-commands
lfshtml=${lfs}-html # the dir containing the lfs html
DumpedCommands=${LFS}/${lfscommands}
Dumpedhtml=${LFS}/${lfshtml}
if [ "$LFS" = "/" ]; then # need to remove the // to get the Makefile to work
  DumpedCommands="/${lfscommands}"
  Dumpedhtml="/${lfshtml}"
fi
wgetopts="" # Options for wget, e.g. proxy settings etc
RETURN_OTHER_ERR=237 # used when more than one error found in a function
RETURN_GT=239 # used in test of which version is later. returned if $1 > $2
RETURN_EQ=241 # used in compare_versions - returned if versions are equal
RETURN_FNF=243 # file not found
RETURN_MTOV=245 # more than one version of file present
RETURN_NO_CMNDS=247 # no commands found for specified package
RETURN_FNF=249 # return file not found
RETURN_PARAM=251  # from a function on error
#
isInt=89 # test if a string is int, float or just a string
isFloat=91
isChar=93
#
# these are relative to newly installed lfs ( i.e. without $LFS prefix )
sourcedir=/sources # as given in the book
PkgUserDir=/usr/src/core # all package src files sit under here. Make sure blfsa is consistent with this.
chrootBuild=/build # chapter05 and 06 build directory
#
buildDir=${LFS}/build # chapter05 and 06 build directory
BuildLog=${lfsUC}-build.log # keep a record of packages and times
echo "BuildLog set to $BuildLog"
if [ ! -e ${LFS}/${BuildLog} ]; then
  if [ -d /home/lfs ]; then # user lfs exists
    echo "Directory /home/lfs exists"
    touch ${LFS}/${BuildLog}
  else
    echo "user lfs doesn't exist. You should create it now - section 4.3 in the book"
    exit 1
  fi
fi
SOURCEDIR=${LFS}${sourcedir}
if [ ! -d "$SOURCEDIR" ]; then install -vdm755 $SOURCEDIR; fi
allChaps="chapter05 chapter06 chapter07 chapter08 chapter10"
build="build" # name of the build file for each package
ncc="--no-check-certificate" # options for wget
#initialize the config variables
TZ=$TZ
PAPER_SIZE=$PAPER_SIZE
LFS_BOOK_GIT_LOC_DIR=$HOME/LFS_GIT/$REPO # def local dir for the downloaded (git) book xml
GIT_URL="git://git.linuxfromscratch.org" # git url
trunkDIR=trunk # the dir below LFS_BOOK_GIT_LOC_DIR
BOOK_VERSION=$BOOK_VERSION
SOURCES=$SOURCES
CLEAN_SRC_DIR=$CLEAN_SRC_DIR
WGETLISTNAME=$WGETLISTNAME
UPDATESRCFILES=$UPDATESRCFILES
BOOK_ORIGIN=$BOOK_ORIGIN
WHICH_CHAPTER=$WHICH_CHAPTER
PKGUSERFILE=$PKGUSERFILE
TESTS=$TESTS
MAKE_KERNEL=$MAKE_KERNEL # "no" -  stop at make mrproper, "yes" - use a .config and make
AS_ROOT=$AS_ROOT # 'no' install as package user, 'yes' install as root
SYSTEMD=$SYSTEMD # 'yes' use systemd, 'no' use sysvinit for control
DESTDIR=$DESTDIR
INSTALLDEST=$INSTALLDEST
USEPROXY=$USEPROXY
SINGLE_PACKAGE=$SINGLE_PACKAGE
echo "config file is $cfg"
if [ -e $cfg ]; then
  source $cfg # exists so source it
else
  touch $cfg #cfg is new
  if [ -z "$TZ" ]; then #null
    TZ="Europe/London"
  fi
  if [ -z "$PAPER_SIZE" ]; then #null
    PAPER_SIZE="A4"
  fi
  if [ -z "$BOOK_ORIGIN" ]; then
    BOOK_ORIGIN="git"
  fi
  if [ -z "$BOOK_VERSION" ]; then
    BOOK_VERSION="trunk"
  fi
  if [ -z "$SOURCES" ]; then
    SOURCES="atinstall"
  fi
  if [ -z "$CLEAN_SRC_DIR" ]; then
    CLEAN_SRC_DIR="no"
  fi
  if [ -z "$WGETLISTNAME" ]; then
    WGETLISTNAME="wget-list"
  fi
  if [ -z "$UPDATESRCFILES" ]; then
    UPDATESRCFILES="no"
  fi
  if [ -z "$WHICH_CHAPTER" ]; then
    WHICH_CHAPTER="chapter05"
  fi
  if [ -z "$PKGUSERFILE" ]; then
    PKGUSERFILE="pkguser.tar.xz"
  fi
  if [ -z "$TESTS" ]; then #null
    TESTS="no"
  fi
  if [ -z "$MAKE_KERNEL" ]; then #null
    MAKE_KERNEL="no"
  fi
  if [ -z "$AS_ROOT" ]; then #null
    AS_ROOT="no"
  fi
  if [ -z "$SYSTEMD" ]; then #null
    SYSTEMD="yes"
  fi
  if [ -z "$DESTDIR" ]; then
    DESTDIR="no"
  fi
  if [ -z "$INSTALLDEST" ]; then
    INSTALLDEST="no"
  fi
  if [ -z "$USEPROXY" ]; then
    USEPROXY="no"
  fi
  if [ -z "$SINGLE_PACKAGE" ]; then
    SINGLE_PACKAGE="no"
  fi
# store the values in the new config file
  echo "TZ=$TZ" | tee $cfg 
  echo "PAPER_SIZE=$PAPER_SIZE" | tee -a $cfg
  echo "LFS_BOOK_GIT_LOC_DIR=$HOME/LFS_GIT/$REPO" | tee -a $cfg
  echo "GIT_URL=$GIT_URL" | tee -a $cfg
  echo "BOOK_VERSION=$BOOK_VERSION" | tee -a $cfg
  echo "SOURCES=$SOURCES" | tee -a $cfg
  echo "CLEAN_SRC_DIR=$CLEAN_SRC_DIR" | tee -a $cfg
  echo "WGETLISTNAME=$WGETLISTNAME" | tee -a $cfg
  echo "UPDATESRCFILES=$UPDATESRCFILES" | tee -a $cfg
  echo "BOOK_ORIGIN=$BOOK_ORIGIN" | tee -a $cfg
  echo "WHICH_CHAPTER=$WHICH_CHAPTER" | tee -a $cfg
  echo "PKGUSERFILE=$PKGUSERFILE" | tee -a $cfg
  echo "TESTS=$TESTS" | tee -a $cfg
  echo "MAKE_KERNEL=$MAKE_KERNEL" | tee -a $cfg
  echo "AS_ROOT=$AS_ROOT" | tee -a $cfg
  echo "SYSTEMD=$SYSTEMD" | tee -a $cfg
  echo "DESTDIR=$DESTDIR" | tee -a $cfg
  echo "INSTALLDEST=$INSTALLDEST" | tee -a $cfg
  echo "USEPROXY=$USEPROXY" | tee -a $cfg
  echo "SINGLE_PACKAGE=$SINGLE_PACKAGE" | tee -a $cfg
fi
# functions
#
msg () {
  echo >&2 -e "${1-}"
}
#
die() {
  local msg=$1
  local code=${2-1} # default exit status 1
  msg "$msg"
  exit "$code"
}
#
configEdit () {
local DIALOG_OK=0
local DIALOG_CANCEL=1
local DIALOG_HELP=2
local DIALOG_EXTRA=3
local DIALOG_ITEM_HELP=4
local DIALOG_ESC=255
local HEIGHT=0
local WIDTH=0

display_configFile () {
  dialog --textbox "$1" $HEIGHT $WIDTH
}
#
_edit () {
local value
local newval
local exit_status
local tochange
local display
#
itemMenu=$(awk -F\= '{print $1,$2}' $cfg)
exec 3>&1
tochange=$(dialog --menu "Select item to edit" 0 0 0 $itemMenu 2>&1 1>&3)
exit_status=$?
exec 3>&-
case $exit_status in
  $DIALOG_CANCEL)
    return 0
  ;;
  $DIALOG_ESC)
    echo "Program aborted." >&2
    exit 1
  ;;
  $DIALOG_OK)
    case $tochange in
       TZ)
         display="Enter your local time zone. (If not known, run tzselect)"
       ;;
       PAPER_SIZE)
         display="Probably either letter or A4"
       ;;
       LFS_BOOK_GIT_LOC_DIR)
         display="If the book source is GIT, enter the local directory to store the LFS Book"
       ;;
       GIT_URL)
         display="Enter the git url of the LFS book"
       ;;
       BOOK_VERSION)
         display="LFS book version you want. Type trunk to get the development version. To use systemd, set SYSTEMD=yes in the menu. Type blank to choose from a list."
       ;;
       BOOK_ORIGIN)
         display="Enter git to download the book or local if it's already downloaded. If local the book must be in $LFS_BOOK_GIT_LOC_DIR"
       ;;
       WHICH_CHAPTER)
         display="Enter chapter05, 06, 07, 08 or 10. Enter update to update the core lfs packages in chapter08. To do this set MAKE_KERNEL to no. If MAKE_KERNEL is yes, only the kernel will be updated"
       ;;
       SOURCES)
	       display="atinstall, download or local. atinstall means download to the install dir at install time (default). (if local, source files must be in ${SOURCEDIR}/<book_version>)"
       ;;
       CLEAN_SRC_DIR)
         display="If yes, all files in the $WgetList file in ${SOURCEDIR}/<book_version> will be deleted. Default is no. Note, if using the SINGLE_PACKAGE option with DESTDIR, the source directory will be cleaned first."
       ;;
       WGETLISTNAME)
         display="The name of the wget-list file. Default is wget-list"
       ;;
       UPDATESRCFILES)
           display="If yes, the source files are updated from the lfs sources page in the book.
The wget-list file is made consistent with these updates. Default is no"
       ;;
       PKGUSERFILE)
         display="tar file containing the package user build files. Default is pkguser.tar.xz. Place the file in $LFS/sources"
       ;;
       TESTS)
         display="Chapter 6 tests? Type eithe yes or no"
       ;;
       MAKE_KERNEL)
         display="If WHICH_CHAPTER is chapter10, input no will stop the kernel at makeproper. If yes, the kernel will be compiled and installed. If WHICH_CHAPTER is update, input no will update all the packages in chapter08, but not the kernel. If yes, the latest kernel will be compiled and installed; but nothing else. Remember, if this option is yes, the .config file must be in \$LFS/sources for the kernel to be installed"
       ;;
       AS_ROOT)
         display="If yes, install packages as root. If no, install as package user"
       ;;
       SYSTEMD)
         display="If yes, systemd will control start-up, running and shutdown of the system. If no, will use sysvinit."
       ;;
       DESTDIR)
           display="Set to yes to install the files to a specified directory and create a binary package tarfile from those files. Default is set to no."
       ;;
       INSTALLDEST)
           display="Set to yes to install the files created by DESTDIR. No binary package file is created and this overrides DESTDIR. Default is no"
       ;;
       USEPROXY)
           display="Set to yes if a proxy server is running on the host. Default is no."
       ;;
       SINGLE_PACKAGE)
         display="Install a single package. Use with DESTDIR to create a binary package file. The package name must be in the wget-list file (linux-headers and kernel are okay names). To turn off, type no"
       ;;
    esac
    value=$(awk -F\= -v x=$tochange '$1==x {print $2}' $cfg)
  ;;
esac
exec 3>&1
newval=$(dialog --clear --title "Change value" --inputbox "$display" 0 0 $value 2>&1 1>&3)
case ${newval+x$newval} in
  (x)
     dialog --infobox "Value can't be empty" 0 0
     sleep 2
     exit_status=1
  ;;
  ("")
     dialog --infobox "Value can't be unset" 0 0
     sleep 2
     exit_status=1
  ;;
  (x*[![:blank:]]*)
     exit_status=$? # non blank
  ;;
  (*)
     dialog --infobox "Value can't be blank" 0 0
     sleep 2
     exit_status=1
  ;;
esac
exec 3>&-
case $exit_status in
  $DIALOG_CANCEL)
    return 0
  ;;
  $DIALOG_ESC)
    echo "Program aborted." >&2
    exit 1
  ;;
  $DIALOG_OK)
    dialog --title "Confirmation"  --yesno "Commit ?" 0 0
    exit_status=$?
    case $exit_status in
       1)
          dialog --infobox "Value not changed" 0 0
          sleep 1
       ;;
       0)
          awk -v x=$tochange -v n=$newval '
               BEGIN {FS=OFS="="}$1==x {$2=n} {print}
               ' $cfg > $cfg.tmp
          mv $cfg.tmp $cfg
       ;;
    esac
  ;;
esac
return 0
} # end _edit
#
_main () {
while true; do
  exec 3>&1
  selection=$(dialog \
    --backtitle "LFS config file editor" \
    --title "Menu" \
    --clear \
    --cancel-label "Cancel" \
    --menu "Please choose an option:" $HEIGHT $WIDTH 4 \
            1 "View the config file" \
            2 "Edit config file" \
            3 "Exit from this menu" 2>&1 1>&3)
  exit_status=$?
  exec 3>&-
  case $exit_status in
    $DIALOG_CANCEL)
      echo "Cancel pressed. Exit program"
      exit 1
    ;;
    $DIALOG_ESC)
      echo "Program aborted."
      exit 1
    ;;
    $DIALOG_OK)
      case $selection in
        1)
           display_configFile $cfg
        ;;
        2)
           _edit
           display_configFile $cfg
        ;;
        3)
          echo "Exit and process config file"
          return
        ;;
      esac
  esac
done
#
} # end _main
_main
} #end configEdit
#
ChkLocalBook () {
# $1 is the dir of the book
# $2 is the book version
local localbookdir=$1
local version=$2
if [ "$version" = trunk ]; then # check if dir exists
  if [ -d ${localbookdir}/${version}/lfs ]; then # local book dir exists
    if [ -e ${localbookdir}/${version}/lfs/.git ]; then # a book exists, check the version
      ChkLocalBookDetails $localbookdir $version
      retval=$?
      if [ $retval -eq 0 ]; then
        return 0 # download the book
      else
        return 1 # requested book alreaded downloaded
      fi
    else # no .git file found, check if dir is empty
      if [ $(ls -al ${localbookdir}/${version} | wc -l) -eq 3 ]; then
        echo "dir ${localbookdir}/${version} is empty"
      fi
      return 0 # download the book
    fi
  else
    return $RETURN_PARAM # book dir doesn't exist
  fi
else # book is a release version so do nothing
  echo "Requested book is present locally so will use it."
  echo "It is a release version so no update necessary."
  return $RETURN_PARAM
fi
} # end ChkLocalBook
#
ChkLocalBookDetails () {
local bookdir=$1
local book_version=$2
#
# check the last commit hash
pushd ${bookdir}/${version}/lfs > /dev/null
  local last_commit_local=$(git rev-parse HEAD)
popd > /dev/null
# get the last commit hash from the online book
local last_commit_online=$(git ls-remote  git://git.linuxfromscratch.org/lfs.git  HEAD | cut -f1)
#echo "last_commit_local is $last_commit_local"
#echo "last_commit_online is $last_commit_online"
if [ "$last_commit_local" = "$last_commit_online" ]; then # latest commit already downloaded
  return 1 # don't download
else
  return 0 # download latest version of the book
fi
} # end ChkLocalBookDetails
#
CleanLocalREPO () { # delete any files in the local directory
local bookdir=$1
local book_version=$2
if [ -d ${bookdir}/${book_version} ]; then # local dir exists
  if [ "$(ls -A ${bookdir}/${book_version})" ]; then # dir contains files
    rm -rf ${bookdir}/${book_version}* # delete contents of local book dir
  fi
else  # create it
  install -v -m0755 -d ${bookdir}/${book_version}
fi
} # end CleanLocalREPO
#
WhichLFSBook () {
# BOOK_VERSION is global
local f lfsVers lfsBooks
# get a list of branches from the website
local lfsVers=$(git ls-remote ${GIT_URL}/lfs.git | awk -F\/ '{print $NF}')
# limit the books to just a decimal number and nothing else
for f in $lfsVers; do
  if [[ $f =~ ^[-+]?([0-9]*\.[0-9]+|[0-9]+\.[0-9]*)$ ]]; then
    lfsBooks="$lfsBooks $f"$'\n'
  fi
done
PS3="Please select the book version : "
select TAG in 'Current Development' $lfsBooks
do
  case $TAG in
    '') echo >&2 "Please select a numbered option"
    ;;
    Current*)
      type=trunk
      version=trunk
      BOOK_VERSION=trunk
    ;;
    ?*)
      type=tags
      version=$TAG
      BOOK_VERSION=$TAG
    ;;
  esac
  echo >&2 "You have selected '$TAG'"
  echo >&2 "$GIT_URL"
  PS3="Is this correct? : "
  select confirm in Yes No
  do
    case $confirm in
      '') echo >&2 "Please enter 1 for Yes or 2 for No"
      ;;
      ?*) break
      ;;
    esac
  done
  case $confirm in
    No) PS3="Please select the book version : "
    ;;
# update the config file with the book version
    Yes) awk -v x=BOOK_VERSION -v n=$BOOK_VERSION '
             BEGIN {FS=OFS="="}$1==x {$2=n} {print}
             ' $cfg > $cfg.tmp
             mv $cfg.tmp $cfg
	 break
    ;;
  esac
done
} #end WhichLFSBook
#
git-info () {
# a close equivalent to svn info

function check_git_dir {
  local IS_GIT_DIR=$(git rev-parse --is-inside-work-tree)
  if [ ! "$IS_GIT_DIR" == "true" ]; then
    exit 1
  fi
}
#
function get_last_modified {
  echo -e -n "$(git show --format="%ci %cr" $1 | head -n 1 | cut -d ' ' -f4-6)"
}
#
check_git_dir

REMOTE=$1
if [ "$REMOTE" == "" ]; then
  REMOTE=origin
fi

if [ "$(git remote | grep $REMOTE)" == "" ]; then
  echo "remote '$REMOTE' does not exist"
  exit 1
fi

git remote update $REMOTE > /dev/null 2>&1

REMOTE_URL=$(git config --get remote.$REMOTE.url)
BRANCH=$(git rev-parse --abbrev-ref HEAD)

LAST_REMOTE_COMMIT=""
REMOTE_LAST_MODIFIED=""
REMOTE_BRANCH_EXISTS=false
if [ ! "$(git branch -r  | grep $GROUP/$BRANCH)" == "" ]; then
  REMOTE_BRANCH_EXISTS=true
  LAST_REMOTE_COMMIT=$(git rev-parse $REMOTE/$BRANCH)
  REMOTE_LAST_MODIFIED=$(get_last_modified $REMOTE/$BRANCH)
fi
LAST_LOCAL_COMMIT=$(git --no-pager log --max-count=1 | head -n1 | cut -d ' ' -f2)
LOCAL_LAST_MODIFIED=$(get_last_modified $BRANCH)
SHORT_COMMIT_HASH=$(git rev-parse --short=9 $BRANCH)

INSYNC=false
if [ "$LAST_LOCAL_COMMIT" == "$LAST_REMOTE_COMMIT" ]; then
  INSYNC=true
fi

cd $(readlink -f .)
while [ ! -d .git ] && [ ! `pwd` = "/" ]; do cd ..; done
WORKING_COPY_ROOT_PATH=$(pwd)

echo "Working Copy Root Path: $WORKING_COPY_ROOT_PATH|Remote: $REMOTE|Remote URL: $REMOTE_URL|Branch: $BRANCH|Last Local Commit: $LAST_LOCAL_COMMIT ($LOCAL_LAST_MODIFIED)|Last Remote Commit: $LAST_REMOTE_COMMIT ($REMOTE_LAST_MODIFIED)|Synchronized: $INSYNC|Revision: $SHORT_COMMIT_HASH|"
#echo "                Remote: $REMOTE"
#echo "            Remote URL: $REMOTE_URL"
#echo "                Branch: $BRANCH"
#echo "     Last Local Commit: $LAST_LOCAL_COMMIT ($LOCAL_LAST_MODIFIED)"
#if [ "$REMOTE_BRANCH_EXISTS" == "true" ]; then
#  echo "    Last Remote Commit: $LAST_REMOTE_COMMIT ($REMOTE_LAST_MODIFIED)"
#  echo "          Synchronized: $INSYNC"
#else
#  echo "    Last Remote Commit: -- no remote branch --"
#  echo "          Synchronized: -- no remote branch --"
#fi
#
} # end git-info
#
CheckoutGIT () {
local gitUrl=$1
local bookdir=$2
local book_version=$3
local reType='^[0-9]+([.][0-9]+)?$' # deal decimal book versions
local source="${gitUrl}/lfs.git"
local destin="${bookdir}/${book_version}/lfs"
# download the book
git clone $source $destin
# add lfs: to the Makefile
sed -i '/book:/i lfs: book wget-list\n' "${destin}/Makefile"
# deal with a released book
if [[ $book_version =~ $reType ]] ; then
  echo "will do git checkout $book_version"
  pushd "${bookdir}/${book_version}/lfs" > /dev/null
    git checkout -b $book_version "origin/${book_version}"
  popd > /dev/null
fi
#
} # end CheckoutGIT
#
DumpCommands () {
# $1 is the Repository - LFS in this case
# $2 is the dir containing the book
# $3 is the book version
local bookdir=$2
local book_version=$3
local rev="systemd" # default
if [ "$SYSTEMD" = no ]; then rev="sysv"; fi
#
local target=$( echo $1 | awk '{print tolower($1)}')
REPODIR=${bookdir}/${book_version}/${target}
pushd $REPODIR > /dev/null
GITINFO=$(git-info)
popd > /dev/null
GITrevision=$( echo $GITINFO | awk 'BEGIN{ RS = "|" };/Revision/ {print $0}' )
if [ ! -d $DumpedCommands ]; then install -vdm755 $DumpedCommands; fi
if [ ! -d $Dumpedhtml ]; then install -vdm755 $Dumpedhtml; fi
if [ ! -e ${DumpedCommands}/.revision ]; then touch ${DumpedCommands}/.revision; fi # suppress a 'No such file' warning
commandRevision=$( cat $DumpedCommands/.revision | awk '/Revision/ {print $0}')
if [ "$commandRevision" != "$GITrevision" ]; then # dump the new commands
  rm -rf $DumpedCommands
  rm -rf $Dumpedhtml
  install -vdm755 $DumpedCommands
  install -vdm755 $Dumpedhtml
  pushd $REPODIR > /dev/null
    make -j1 DUMPDIR=$DumpedCommands BASEDIR=$Dumpedhtml REV=$rev $target "dump-commands"
    for dir in $DumpedCommands $Dumpedhtml; do
      echo $GITINFO | awk 'BEGIN{ RS = "|" }; {print $0}' > ${dir}/.revision
    done
  popd > /dev/null
  mkdir -pv ${SOURCEDIR}/${book_version}
  if [ ! -e ${SOURCEDIR}/${book_version}/wget-list ]; then # try and mv it from Dumpedhtml
    if [ -e ${Dumpedhtml}/wget-list ]; then
      mv ${Dumpedhtml}/wget-list ${SOURCEDIR}/${book_version}/
      mv ${Dumpedhtml}/md5sums ${SOURCEDIR}/${book_version}/
    else
      echo "There is no wget-list file in $Dumpedhtml"
      echo "You need to make sure that docbook-xml and docbook-xsl"
      echo "are installed on the host"
      echo "Abort"
      exit 1
    fi
  fi
fi
} # end of DumpCommands
#
CleanSourceDir () {
local srcdir=$1
local wgetlistFile=$2
if [ -d $srcdir ]; then
# delete any file in $srcdir that is in $wgetlistFile
  if [ -e $wgetlistFile ]; then
    while read FUrl; do
      if [[ ${FUrl:0:1} != '#' ]]; then # ignore file if it has a hash at the start
        fileinlist=$( echo $FUrl | awk -F\/ '{print $NF}' )
        [ -e ${srcdir}/${fileinlist} ] && rm -rf ${srcdir}/${fileinlist}
      fi
    done < $wgetlistFile
  fi
else
  rm -rf $srcdir # remove any file called $srcdir - it needs to be a dir
  install -v -m0755 -d $srcdir
fi
} #end CleanSourceDir
#
ChkPkgExists () {
# Used with the SINGLE_PACKAGE option.
# checks that the requested package is in the wgetlist file
local wgetlistFile=$1
local packageName=("${!2}")
local pkgURL
local fileinURL=""
#
echo "in ChkPkgExists"
echo "packageName is ${packageName[@]}"
if [ -e $wgetlistFile ]; then
  while read pkgURL; do
    fileinURL=$( echo $pkgURL | awk -F\/ '{print $NF}' )
    if [[ "$fileinURL" == ${packageName[0]}*.tar.*z* ]]; then
      fileinURL=$( echo $fileinURL | awk -F\/ '{print $NF}' )
      rtrnName=($fileinURL)
      return 0
    fi
  done < $wgetlistFile
return $RETURN_FNF
else
  return $RETURN_PARAM
fi
} # end ChkPkgExists
#
GetPkgName () {
# given a source file name, returns the package name for LFS packages
# $1 is the name of the src file
local pkgvers
local srcfile=$1
local pkgnm=$(echo $srcfile | awk -F\- '{print $1}')- # assumes the separator is -
case $srcfile in
   expect*|tcl8*) # separator is .
        pkgnm=$(echo $srcfile | awk -F\. '{print $1}')
        pkgnm=${pkgnm%?} # remove trailing numeric
   ;;
   iana-etc*|man-db*|man-pages*|pkg-config*|procps-ng*|util-linux*|XML-Parser*) # need $1 and $2 from awk
        pkgnm=$(echo $srcfile | awk -F\- '{print $1"-"$2}')-
   ;;
   tzdata*)
        pkgnm=$(echo $srcfile | awk -F\. '{print $1}') # separator is .
        pkgvers="${pkgnm#*tzdata}"
        pkgnm="${pkgnm%${pkgvers}*}"
   ;;
esac
echo $pkgnm
return 0
} # end GetPkgName
#
uniqueArray () {
# $1 is the array to sort
local unsorted_array=("${!1}")
local ip
local IFS=$'\n'
local sorted_array=( $(printf "%s\n" "${unsorted_array[@]}" | sort -u) )
rtrnSorted=(${sorted_array[@]})
} # end uniqueArray
#
get_crtime() {
# get the creation time (crtime) of a file
# $1 is the filename
# $2 is the file location - no final /
# NOTE need the -P option for grep implemented (if necessary recompile grep with pcre support)
#
local target=${2}/${1}
local inode=$(stat -c %i "${target}")
local fs=$(df "${target}"  | tail -1 | awk '{print $1}')
local crtime=$(sudo debugfs -R 'stat <'"${inode}"'>' "${fs}" 2>/dev/null | grep -oP 'crtime.*--\s*\K.*')
echo $crtime
}
#
detExtType () {
# determine the extension type of a tar file
# the hierarchy is xz, bz2, gz, tgz and zip
local sortedVers=("${!1}")
local isXZ=false
local isLZMA=false
local isBZ2=false
local isGZ=false
local isGZ2=false
local ispatchGZ=false
local isTGZ=false
local isZIP=false
local isTAR=false
local extType
#
for ((in=0; in<${#sortedVers[@]}; in++)); do # decide which files to test, .xz, .bz2, .gz, .tgz or zip
  case ${sortedVers[in]} in
     *tar.xz*)
        isXZ=true # if .xz file present, don't need to continue searching
        break
     ;;
     *.tar.lzma*) # e.g. curl
        isLZMA=true
     ;;
     *tar.bz2*)
        isBZ2=true
     ;;
     *tar.gz*)
        isGZ=true
     ;;
     *.patch.gz*) # for a gz patch file
        ispatchGZ=true
        break
     ;;
     *[0-9].gz*) # if no tar in name
        isGZ2=true
        trimto=".gz"
     ;;
     *.tgz*)
        isTGZ=true
     ;;
     *.zip*)
        isZIP=true
     ;;
     *-signed.tar) # for any signed file
        isTAR=true
        break
     ;;
  esac
done
# Set extension type to use, based on the hierarchy of tar files
if $isXZ; then
  extType="xz"
elif $isLZMA; then
  extType="lzma"
elif $isBZ2; then
  extType="bz2"
elif $isGZ; then
  extType="gz"
elif $ispatchGZ; then
  extType="patch.gz"
elif $isGZ2; then
  extType="gz2"
elif $isTGZ; then
  extType="tgz"
elif $isZIP; then
  extType="zip"
elif $isTAR; then
  extType="tar"
else
  return $RETURN_PARAM
fi
echo $extType
return 0
} # end detExtType
#
compare_versions () {
#
# compares two version numbers
# returns $RETURN_GT if $1 > $2 
# return $RETURN_EQ if $1 = $2
# otherwise returns 0
# $3 is the separator to parse the version number, usually .
#
local IFS="$3"
local a1=( $1 )
local a2=( $2 )
# some versions have a - in them, e.g. ImageMagick
local b1=$(IFS='-'; echo "${a1[*]}") # string b1 is now - delimited
local b2=$(IFS='-'; echo "${a2[*]}")
IFS='-' read -ra a1 <<< "$b1" # put delimited string back into array
IFS='-' read -ra a2 <<< "$b2"
#echo "a1 is ${a1[@]}"
#echo "a2 is ${a2[@]}"
local num_a1=${#a1[@]}
local num_a2=${#a2[@]}
#echo "numa1, numa2 are $num_a1 $num_a2"
local max=$(( $num_a1 > $num_a2 ? $num_a1 : $num_a2 ))
local im
for (( im=0; im<$max; im++ )); do
# deal with invalid octal. usbutils uses 00 type versioning.
  if [ "${a1[im]}" = "08" -o "${a1[im]}" = "09" ]; then a1[im]=${a1[im]#?}; fi
  if [ "${a2[im]}" = "08" -o "${a2[im]}" = "09" ]; then a2[im]=${a2[im]#?}; fi
  if [ "${a1[im]}" = "008" -o "${a1[im]}" = "009" ]; then a1[im]=${a1[im]#??}; fi
  if [ "${a2[im]}" = "008" -o "${a2[im]}" = "009" ]; then a2[im]=${a2[im]#??}; fi
#echo "a1 is ${a1[im]}"
#echo "a2 is ${a2[im]}"
  if [ "${a1[im]}" -eq "${a1[im]}" ] 2>/dev/null; then # is integer
    if [ "${a2[im]}" -eq "${a2[im]}" ] 2>/dev/null; then # can compare
      (("${a1[im]}" > "${a2[im]}")) && return $RETURN_GT
      (("${a2[im]}" > "${a1[im]}")) && return 0
    else
         return $RETURN_GT # a2 missing so a1 greater
    fi
  else
         return 0 # a2 greater
  fi
done
# if got here then a1 and a2 are equal
return $RETURN_EQ
} # end compare_versions
#
# test if integer, float or just a string
testIntFloatChar () {
# $1 is the string to test
local testString=$1
if [[ $testString =~ ^[+-]?[0-9]+$ ]]; then return $isInt; fi
if [[ $testString =~ ^[+-]?[0-9]+\.?[0-9]*$ ]]; then return $isFloat; fi
if [[ $testString =~ ^[+-]?[0-9]+\.$ ]]; then return $isChar; fi
return $isChar
}
#
updateSorted () {
# $1 is the array holding the list of "Click to enter 'version' strings"
# $2 is the url
# $3 is the package name, no version num but include the - after the name
# $4 is the file extension, .tar.xz, .tar.bz2, .tar.gz, .tgz or .zip
# $5 is the index number in ClickToDnld containing the filename
local ClickToEnter=("${!1}")
#echo "in updateSorted"
local ClickToDnld # array containing list of "Click to download 'filename' strings"
local latestVer=${ClickToEnter[1]} # assumes the first one is the latest - note [0] is empty
latestVer=${latestVer#"Click to enter "} # version number
local url="${2}${latestVer}/" # new url for page to search
local pattern
case $3 in
   boost_)
     latestVer="${latestVer//./_}" # version is _
     pattern="${3}${latestVer}${4}"
   ;;
   cracklib-words-)
     latestVer=${latestVer//-/}
     pattern="${3}${latestVer}${4}"
   ;;
   faad2-)
     pattern="${latestVer}/${latestVer}${4}"
   ;;
   libusb-)
     pattern="${latestVer}${4}"
   ;;
   sqlite-*)
     pattern=$3
     url=${url/e 3/e%203} # fix the space in the version number
   ;;
   tcl8.)
     pattern="${3}${latestVer}-src.tar.gz"
   ;;
   tk8.)
     pattern="${fnameonly}${latestVer}-src.tar.gz"
   ;;
   *)
     pattern="${3}${latestVer}${4}"
   ;;
esac
#echo "url is $url"
#echo "pattern is $pattern"
local foundPat=$(/usr/bin/php srcFileVers.php -- $pattern $url $3)
if [ "$foundPat" = "" ]; then
  return $RETURN_PARAM
fi
# page found so update array
readarray -t ClickToDnld <<< "$foundPat"
#echo "ClickToDnld is ${ClickToDnld[@]}"
local indexnum=$5
local filename=${ClickToDnld[indexnum]} #  [0] is empty
#echo "filename is $filename"
filename=${filename#*"Click to download "}
#echo "filename is $filename"
rtrnFname=$filename
#echo "exit updateSorted"
return 0
} # end updateSorted
#
findMaxVers () {
# $1 is the array holding the filenames
# $2 is the extension of the file - xz, bz2, gz, patch.gz, tgz or zip
# $3 is the pattern to trim to
# $4 is the current version in the wget-list file
# $5 is the package tar filename
# $6 - only used for grub and is $trimfname
local filesArray=("${!1}")
local extType=$2
local trimto=$3
local extension
local CurrentMaxVers=$4
local fname=$5
local instor=0 # the index of the max version file in the filesArray array
local foundit=false # true if $maxVers found in filesArray
local maxVers=$CurrentMaxVers # this will change if there is a later version
local trimfname=$6
#
case $extType in
   xz)
     extension="tar.xz"
   ;;
   bz2)
     extension="tar.bz2"
   ;;
   gz)
     extension="tar.gz"
   ;;
   gz2)
     extension=".gz"
   ;;
   patch.gz)
     extension="patch.gz"
   ;;
   tgz)
     extension=".tgz"
   ;;
   zip)
     extension=".zip"
   ;;
   tar)
     extension=".tar"
   ;;
   lzma)
    extension="tar.lzma"
   ;;
esac
for ((in=0; in<${#filesArray[@]}; in++)); do
  case ${filesArray[in]} in
     *$extension) # parse the version number of all files of type $extension
             namePlusVer="${filesArray[in]%${trimto}*}" # name plus version
#echo "namePlusVer is $namePlusVer"
             case $namePlusVer in
                expect*) # use . as the separator
                  justVers=$(echo $namePlusVer | awk -F\. '{print $NF}')
                ;;
                grub-*)
                  justVers=${namePlusVer#*${trimfname}} # the numeric after beta
                ;;
                tcl8.*)
                  justVers=${namePlusVer#"tcl8."}
                ;;
                *)
                  justVers=$(echo $namePlusVer | awk -F\- '{print $NF}')
                ;;
              esac
              case $justVers in
                 *rc*|*RC*|*c1*) # release candidate - ignore.
                   ret_val=0
                 ;;
                 *)
#echo "justVers is $justVers"
#echo "maxVers is $maxVers"
                  compare_versions $justVers $maxVers "."
                  ret_val=$?
                ;;
             esac
        if [ $ret_val -eq $RETURN_GT ]; then # justVers is >
          maxVers=$justVers
          foundit=true
          instor=$in # store the index of current max version
        elif [ $ret_val -eq $RETURN_EQ ]; then
          foundit=true
          instor=$in # versions are the same so store the index
        fi
     ;;
  esac
done
if [ "$maxVers" = "$CurrentMaxVers" ]; then # CurrentmaxVers unchanged
  if ! $foundit; then
    return $RETURN_PARAM
  else
    echo $instor # array index of the max version
    return $RETURN_EQ
  fi
else
  echo $instor # return the array index of the max version
  return 0
fi
} # end findMaxVers
#

GetLatestVers () {
# $1 is the wget-list file
# $2 is the book version, either lfs-sysv or lfs-systemd. Default is the latter.
# if present, $3 is runit, set to false to see result of a dummy run. Default is true.
# if present, $4 is printit. Set to true to see printout of variables' values. Default is false.
local wgetlist=$1
local bookvers
if [ ! -z "$2" ]; then
  if [ "$2" = "lfs-sysv" ]; then
    bookvers="development"
    echo "Using the sysv version of the book"
  elif [ "$2" = "lfs-systemd" ]; then
    bookvers="systemd"
    echo "Using the systemd version of the book"
  else
    echo "Didn't recognise $2. It should either be lfs-sysv or lfs-systemd."
    exit 1
  fi
else
  echo "Using the systemd version of the book"
  bookvers="systemd"
fi
local runit=${3:-true}
local printit=${4:-false}
#use a tmp file to store the latest urls for each source package
local latest_tmpfile=$(date +%d%B%Y_%H:%M:%S)tmp.file
local SrcURLtoUse="http://www.linuxfromscratch.org/lfs/view/${bookvers}/chapter03/packages.html"
local PatchURLtoUse="http://www.linuxfromscratch.org/lfs/view/${bookvers}/chapter03/patches.html"
# scrape the LFS website for the latest sources
local -a lines=($(python3 BShref.py $SrcURLtoUse))
if [ "$?" != 0 ]; then
  echo "Failed in BShref.py"
  echo "Is python-beautifulsoup4 installed on the host?"
  echo "Abort"
  exit 1
fi
local newURL=""
local i k
local src latestvers trimto
local fileExists useThisOne
local numFiles reply
local latestSrc
# remove the existing wget-list file so can be updated
if $runit; then rm -rf $wgetlist; fi # remove the old wgetlist file
for ((i=0; i<${#lines[@]}; i++)); do # get the src tarfile name
#  echo "from lfs website: ${lines[i]}"
# assumes all files in LFS have extensions .xz, .bz2 or .gz
  src=$(echo ${lines[i]} | awk -F\/ '{print $NF}' | grep -E ".tar.xz|.tar.bz2|.tar.gz")
  if $printit; then echo "src is $src"; fi
  if [ ! -z "$src" ]; then
# is this file already in $SourceDir
    if [ ! -e ${SourceDir}/${src} ]; then
      case $src in
          lfs-bootscripts*)
              echo "Don't need $src"
          ;;
          *)
              if ! $runit; then
                echo "Could download $src and place in $sourceLoc if runit were true"
              else
                echo "Will download $src and place in $SourceDir"
                trimto=".tar"
                case $src in
                   "tcl8."*) # trimto is -src
                     trimto="-src"
                   ;;
                   "python-"*"-docs-html.tar"*)
                     trimto="-docs"
                     tailbit="-docs-html" # might need this to find existing files
                   ;;
                esac
                pkgnm=$(GetPkgName $src)
                rtrvers=""
                GetVersionNum "" $src $trimto
                pkgvers=$rtrvers
                fileExists=($(find $SourceDir -type f -name "$pkgnm*"))
                numFiles=${#fileExists[@]}
                if [ $numFiles -gt 1 ]; then # probably src and patch file found for this package
                  echo "Files:"
                  for (( k=0; k<$numFiles; k++ )); do
                    echo "${fileExists[k]}"
                    case ${fileExists[k]} in
                       *tar.*z*) # use the tar file
                           useThisOne=${fileExists[k]}
                       ;;
                    esac
                  done
                  echo "found for package $pkgnm"
                elif [ $numFiles -eq 1 ]; then
                  useThisOne=${fileExists[0]}
                else # numFiles is zero, no package with this name found
                  echo "No package with name $pkgnm found in $sourceLoc"
                  echo "No source file to delete - continue with download"
                  useThisOne=$src
                fi
                if $printit; then echo "useThisOne is $useThisOne"; fi
                if [ "$useThisOne" = "$src" ]; then # only one file, download it
                  wget -O ${sourceLoc}/${src} ${lines[i]}
                  chown john:john ${sourceLoc}/${src}
                elif [ ! -z "$useThisOne" ]; then # a file with this pkgnm is present - compare versions
                  latestvers=$pkgvers # version of file to download
                  if $printit; then echo "latestvers is $latestvers"; fi
                  latestSrc=$(echo $useThisOne | awk -F\/ '{print $NF}') # remove SourceDir
                  if $printit; then echo "latestSrc is $latestSrc"; fi
                  pkgnm=$(GetPkgName $latestSrc)
                  rtrvers=""
                  GetVersionNum $SourceDir $pkgnm $trimto
                  retval=$?
                  if [ $retval -ne 0 ]; then
                    echo "Return from GetVersionNum is $retval"
                    echo "It should be 0. Investigate!"
                    exit 1
                  else
                    pkgvers=$rtrvers
                  fi
                  if [ "$pkgvers" = "$latestvers" ]; then
                    echo "Same version already downloaded but different extension"
                  else
                    for (( k=0; k<$numFiles; k++ )); do
                      echo "delete ${fileExists[k]} (Y/n)"
                      read replyDel
                      case $replyDel in
                        [yY]|[yY][Ee][Ss])
                          rm -v ${fileExists[k]}
                        ;;
                        [nN]|[nN][Oo])
                          echo "file ${fileExists[k]} not deleted"
                          storFname=${fileExists[k]}
                        ;;
                        *)
                          rm -v ${fileExists[k]}
                        ;;
                      esac
                    done
                    echo "Download $src (Y/n)"
                    read reply_Dwnld
                    case $reply_Dwnld in
                       [yY]|[yY][Ee][Ss])
                         wget -O ${SourceDir}/${src} ${lines[i]}
                         chown john:john ${SourceDir}/${src}
                       ;;
                       [nN]|[nN][Oo])
                         echo "File not downloaded"
                         reply_Dwnld=$(echo ${reply_Dwnld,,*}) # make sure it's lower case
                         if [ "$replyDel" = n -o "$replyDel" = no ]; then
                           echo "File $storFname not deleted and"
                           echo "File $src not downloaded"
                           tarfname=$(echo ${lines[i]} |  awk -F\/ '{print $NF}')
                           laterFname=$(echo $storFname |  awk -F\/ '{print $NF}')
                           echo "Will place $laterFname in the wget-list file"
                           url_bit="${lines[i]%${tarfname}}"
                           newURL=${url_bit}${laterFname}
                         fi
                       ;;
                       *)
                         wget -O ${SourceDir}/${src} ${lines[i]}
#                         chown lfs:root ${SourceDir}/${src}
                       ;;
                    esac
                  fi
                else
                  echo "The variable useThisOne is null. Investigate why"
                fi
              fi # end runit
          ;;
      esac
    else
      echo "file $src already downloaded"
    fi
  else
    echo "variable \$src is null"
    echo "Didn't find a tar.xz, tar.bz2 or tar.gz file"
    echo "Need to investigate why not"
    exit 1
  fi
  if [ -z "$newURL" ]; then
# echo "write ${lines[i]} to $wgetlist"
    echo "${lines[i]}" >> $wgetlist
  else
# echo "write $newURL to $wgetlist"
    echo "$newURL" >> $wgetlist
    newURL=""
  fi
done
# update any patches
local -a patches=($(python3 BShref.py $PatchURLtoUse))
if [ "$?" != 0 ]; then
  echo "Failed in BShref.py"
  echo "Is python-beautifulsoup4 installed on the host?"
  echo "Abort"
  exit 1
fi
local patchExists
for ((i=0; i<${#patches[@]}; i++)); do
  local ptch=$(echo ${patches[i]} | awk -F\/ '{print $NF}' | grep -E ".patch")
  if [ ! -e ${SourceDir}/${ptch} ]; then
    echo "Will download the patch $ptch and place in $SourceDir"
    pkgnm=$(GetPkgName $ptch)
    rtrvers=""
    GetVersionNum $SourceDir $pkgnm ".patch" "patch"
    retval=$?
    if [ $retval -ne 0 ]; then
      echo "parsing a patch file."
      echo "return value is $retval. It should be 0"
      exit 1
    else
      pkgvers=$rtrvers
    fi
    patchExists=$(find $SourceDir -type f -name "$pkgnm*.patch")
    if [ ! -z "$patchExists" ]; then
      if $runit; then
        echo "delete $patchExists (Y/n)"
        read replyDel
        case $replyDel in
          [yY]|[yY][Ee][Ss])
            rm -v $patchExists
          ;;
          [nN]|[nN][Oo])
            echo "file $patchExists not deleted"
          ;;
          *)
            rm -v $patchExists
          ;;
        esac
      else
        echo "Could delete $patchExists if runit were true"
      fi
    fi
    if $runit; then
      wget -O ${SourceDir}/${ptch} ${patches[i]}
#      chown lfs:root ${SourceDir}/${ptch}
    fi
  else
    echo "patch $ptch already downloaded"
  fi
# echo "write ${patches[i]} to $wgetlist"
  if $runit; then echo "${patches[i]}" >> $wgetlist; fi
done
} # end GetLatestVers
#
GetSource () {
local bookvers=$1
local srcdir=$2
local wgetlistFile=$3
local bookdir=$4
local fnameUnknown=false
# RequiredFiles contains an array of the required files. If RequiredFiles[0]=no, all files are requested.
local RequiredFiles=("${!5}")
#
# echo "RequiredFiles is ${RequiredFiles[@]}"
if [ "$bookvers" = trunk ]; then # get sources from the urls in $wgetlist
  if [ ! -d $srcdir ]; then install -v -d $srcdir; fi
    if [ ! -e ${srcdir}/${wgetlistFile} ]; then # wget-list doesn't exist, get it from the book
      REPODIR=${bookdir}/${bookvers}
      make -j1 -f ${REPODIR}/Makefile -C $REPODIR BASEDIR=$srcdir REV="systemd" ${srcdir}/${wgetlistFile} ${srcdir}/md5sums
      md5sums=${srcdir}/md5sums
    fi
    if [ "${RequiredFiles[0]}" = no ]; then # all source files requested
      pushd $srcdir > /dev/null
        RequiredFiles=$( md5sum --quiet -c $md5sums 2> /dev/null | awk -F\: '!/OK/{printf "%s ",$1}' )
      popd > /dev/null
    else
      fnameUnknown=true # might not know the precise filename, only the package name
    fi
    for File in ${RequiredFiles[@]}; do
      Url=$( grep $File $wgetlistFile )
      case $File in
         lfs-bootscripts*)
             if [ ! -e ${srcdir}/${File} ]; then
              wget $wgetopts -c $Url -O ${srcdir}/${File}
             fi
         ;;
         ?*)
             if $fnameUnknown; then
               wget $wgetopts -c $Url -P ${srcdir}/
             else
               wget $wgetopts -c $Url -O ${srcdir}/${File}
             fi
         ;;
      esac
    done
else # use anduin to get the source tarball for the released book version
# ****** NOTE ******
# anduin no longer is up-to-date. The LFS editors appear to have abandoned it
#
  bookvers=${bookvers%/} # remove the trailing /
#  File="lfs-packages-${bookvers}.tar"
#  sourceURL="http://anduin.linuxfromscratch.org/sources/LFS/lfs-packages/${File}"
#  wget $wgetopts -c $sourceURL -O ${SOURCEDIR}/${File}
#  tar xvf ${SOURCEDIR}/${File} -C $SOURCEDIR
#  rm -v ${SOURCEDIR}/${File} # untared so remove it
  wget --input-file=$LFS/sources/${bookvers}/wget-list --continue --directory-prefix=$LFS/sources/${bookvers}
fi
#set all the sources to owner lfs, if it exists
if getent passwd lfs > /dev/null 2>&1; then
  echo "User lfs exists"
#  chown -R -h lfs:root $srcdir # because chapter05.sh and chapter06.sh are run as lfs
else
  echo "user lfs doesn't exist. Sources owned by root instead."
  chown -R -h root:root $srcdir
fi
chmod 755 $srcdir
chmod 644 ${srcdir}/*
#
} #end GetSource
#
GetSystemdSources () {
local srcdir=$1
local wgetlistFile=$2
while read -r FileUrl; do
  fileNam=$( echo $FileUrl | awk -F\/ '{print $NF}' )
  wget $wgetopts -c $FileUrl -O ${srcdir}/${fileNam}
done < $wgetlistFile
#if getent passwd lfs > /dev/null 2>&1; then
#  chown -R -h lfs:root $srcdir
#else
  chown -R -h root:root $srcdir
#fi
chmod 644 ${srcdir}/*
#
} # end GetSystemdSources
# 
ChkSrcPresent () { 
# $1 is the directory to check
# $2 is the $wgetlist of files
# $3 is the array to hold any missing src file names
# if a single package, $3 contains the package name in array element 0
local dirtochk=$1
local wgetlistFile=$2
filesNotPresent=("${!3}") # global array
local filetofind
#
if $single_package; then # single package requested
  if [ -e ${dirtochk}/${filesNotPresent[0]} ]; then
    return 0
  else
    return $RETURN_PARAM
  fi
else # check sources in wget-list file are present in dirtochk
  echo "Checking all sources in $wgetlistFile have been downloaded"
  im=0
  while read FileUrl; do
    if [[ ${FileUrl:0:1} != '#' ]]; then # ignore file if it has a hash at the start
      filetofind=$( echo $FileUrl | awk -F\/ '{print $NF}' )
      if [ ! -e ${dirtochk}/${filetofind} ]; then
	if [[ "$filetofind" == "lfs-bootscripts"* && "$SYSTEMD" == yes ]]; then
          echo "don't need lfs-bootscripts with systemd"
        elif [[ "$filetofind" == "sysvinit-"* && "$SYSTEMD" == yes ]]; then
          echo "don't need sysvinit with systemd"
	else
          echo "'$filetofind' not present in $dirtochk"
	  filesNotPresent[im]=$filetofind
          ((im++))
        fi
      fi   
    fi
  done < $wgetlistFile
  if [ $im -gt 0 ]; then # files are missing
    return $RETURN_PARAM
  else
    return 0
  fi
fi
} # end ChkSrcPresent
#
ChkEmptySrcFiles () {
local srcdir=$1
# if checking a single package download, $2 will be the package filename
local pkgnm="${2:-}"
local zeroLenFiles
#
if [ ! -z "$pkgnm" ]; then # single package requested
# chk pkgnm exists
  if [ ! -e "${srcdir}/${pkgnm}" ]; then
# file not found
    return $RETURN_FNF
  else
    zeroLenFiles=$(find $srcdir -type f -name "$pkgnm" -empty)
  fi
else
  zeroLenFiles=$(find $srcdir -type f -empty)
fi
local numzero=${#zeroLenFiles}
if [ $numzero -eq 0 ]; then
  return 0
else
  echo -e "These files are empty:\n$zeroLenFiles"
  return $RETURN_PARAM
fi
} # end ChkEmptySrcFiles
#
GetSeriesNum () {
# $1 is the version number
local versnumber=$1
rtrseries=""
local IFS='.' # parse using a .
digitarray=($versnumber)
rtrseries="${digitarray[0]}.${digitarray[1]}"
} # GetSeriesNum
#
getPatchVers () {
# assumes the standard form of a patch, viz. pkgnm-version-descriptor-1.patch
# $1 is the name of the patch file
# $2 is the pkg name
local patchFile=$1
local pkgnm=$2
local versionPlus="${patchFile#${pkgnm}*}"
pkgvers=$(echo $versionPlus | awk -F\- '{print $1}')
echo $pkgvers
} # end getPatchVers
#
GetPkgVersion () {
# $1 is the location of the src package
# $2 is the name of the package
# $3 is the name to trim against - usually tar
# $4 is used with a patch file and is set to patch
# $5 is used with a patch and if set to returnName, will return the name of the patch file only

local pkgloc=${1:-"nowhere"}
local patch=${4:-""}
local rtrnName=${5:-""}
rtrvers=""
# first check if just requested the name of a patch file
if [ "$rtrnName" = returnName ]; then
  if [ -d "$pkgloc" ]; then
    local patchFile="$2*.patch"
    local -a found=($(find $pkgloc -name $patchFile))
    local num=${#found[@]}
    if [ $num -eq 1 ]; then # return the name
      rtrvers=$found[0]
    elif [ $num -gt 1 ]; then
      return $RETURN_MTOV # more than one version present
    elif [ $num -eq 0 ]; then # file not found
      return $RETURN_FNF
    fi
  else # pkgloc not a directory
    return $RETURN_FNF
  fi
else
  GetVersionNum $pkgloc $2 $3 $patch $rtrnName
  retval=$?
  if [ $retval -eq $RETURN_PARAM ]; then
    return $RETURN_PARAM
  elif [ $retval -eq $RETURN_FNF ]; then
    return $RETURN_FNF
  elif [ $retval -eq $RETURN_MTOV ]; then
    return $RETURN_MTOV
  else
    return 0
  fi
fi
} # GetPkgVersion
#
GetVersionNum () {
# $1 is the dir containing the src package.
# If it doesn't exist, return the version of $2, if possible
# $2 is the name of the package
# $3 is the name to trim against - usually tar
# $4 if present, is "patch" to indicate a patch file
# $5 if present, is returnName to return the name of the patch file only
local pkgloc=$1
local srcfile=$2
local trimto=$3
local patch=${4:-""}
local rtrnName=${5:-""}
local -a found=""
local fname
local fileExt
local num=0
local i
local pkgvers=""
#
if [ -d "$pkgloc" ]; then
  found=($(find $pkgloc -name "${srcfile}[0-9]*${trimto}.*z*"))
  num=${#found[@]}
  if [ $num -gt 0 ]; then
    for((i=0; i<$num; i++)); do
      fname=$(echo ${found[i]} | awk -F\/ '{print $NF}')
      unset found[i]
      found[i]=$fname # replace with just the filename, not the url
    done
    if [ $num -eq 1 ]; then # get the version
      fileExt="${found#*${srcfile}}"
      pkgvers="${fileExt%${trimto}*}"
      rtrvers=($pkgvers)
      return 0
    elif [ $num -gt 1 ]; then
      return $RETURN_MTOV # more than one version present
    fi
  else # num=0 - might be a patch file
    if [ "$trimto" = ".patch" ]; then
      found=$(find $pkgloc -name "${srcfile}[0-9].*${trimto}" | awk -F\/ '{print $NF}')
      num=${#found[@]}
      if [ $num -eq 1 ]; then # a patch file so get the version
        pkgvers=$(getPatchVers $found $srcfile)
        rtrvers=($pkgvers)
        return 0
      else
        return $RETURN_FNF # file not found
      fi
    else # not a patch file, see if can return version of srcfile
      local pkgPlusVers="${srcfile%${trimto}*}"
      if [[ "$pkgPlusVers" = "tzdata"* ]]; then
        pkgnm="tzdata"
      else
        local pkgvers=$(echo $pkgPlusVers | awk -F\- '{print $NF}')
        if [ -z "$pkgvers" ]; then
          pkgnm=""
          return $RETURN_FNF
        else
# trim to the version number
          pkgnm="${pkgPlusVers%${pkgvers}}"
#          echo "pkgvers is $pkgvers"
#          echo "pkgnm is $pkgnm"
	   rtrvers=$pkgvers
	   return 0
	fi
      fi
    fi
  fi
else # no pkg location given - return the version of $2, if possible
  local pkgPlusVers="${srcfile%${trimto}*}"
  if [ "$patch" = patch ]; then
    local pkgnm=$(echo $pkgPlusVers | awk -F\- '{print $1}') # search for pkgnm*.patch
  else
    if [[ "$pkgPlusVers" = "tzdata"* ]]; then
      pkgnm="tzdata"
    else
      local pkgvers=$(echo $pkgPlusVers | awk -F\- '{print $NF}')
      if [ -z "$pkgvers" ]; then
        pkgnm=""
        return $RETURN_FNF
      else
# trim to the version number
        pkgnm="${pkgPlusVers%${pkgvers}}"
      fi
    fi
  fi
  rtrvers=$pkgvers
  return 0
fi
} # end GetVersionNum
#
GetLinuxVersion () {
local srcdir=$1
local linuxfnd
local linuxExt
#
linuxfnd=$(find $srcdir -name "linux-[0-9]*.tar.*z*" | awk -F\/ '{print $NF}')
if [ -z "$linuxfnd" ]; then # linux src not found in wget-list file - return
  return $RETURN_PARAM
else
  linuxExt="${linuxfnd#*-}"
  linuxvers="${linuxExt%.tar*}"
fi
return 0
} # end GetLinuxVersion
#
GetLinuxCommandVersion () {
# find the version of a package in the lfs commands
# $1 is the location of the lfs commands, include $LFS
# $2 is the package name in the command directory
# $3 is the pattern to find in the pkgname commands
local commandloc=$1
local pkgname=$2
local pattern=$3
if [ -e "$commandloc" ]; then
  local cmdLine
  local linuxcomfnd=""
#
  while read cmdLine; do
    if [[ ${cmdLine:0:1} != '#' ]]; then # ignore line if it has a hash at the start
      linuxcomfnd=$( echo $cmdLine | awk -F\/ '{print $NF}' | grep $pattern )
      if [ ! -z "$linuxcomfnd" ]; then
        break # found the pattern in the command line
      fi
    fi
  done < ${commandloc}/*-${pkgname}
  if [ ! -z "$linuxcomfnd" ]; then # found required pattern in the commands - echo it
    echo $linuxcomfnd
    return 0
  else
    return $RETURN_PARAM
  fi
#    linuxcomExt="${linuxcomfnd#*-}"
#    linuxcomvers="${linuxcomExt%-lfs*}"
else
  return $RETURN_PARAM
fi
} # end GetLinuxCommandVersion
#
combineScripts () {
declare -a commands=("${!1}")
declare -a buildWrap=("${!2}")
local combine=""
local numc=${#commands[@]}
local numb=${#buildWrap[@]}
countc=0 # counter for the combine array
countbl=0 # counter for build lines written
inc=false # switch for whether a configure, make and install section is present
cont=0 # number of continuation lines
ifDoc=false # true if an if block containing a doc
#
for (( i=0; i<$numb; i++ )); do
  case "${buildWrap[i]}" in
    configure_commands*)
      combine[countc++]=${buildWrap[countbl++]}
      combine[countc++]=${buildWrap[countbl++]} # the {: line
      for (( jk=$countg; jk<$numc; jk++ )); do
        case ${commands[jk]} in
           make*) # assume either a make command or make install
              countg=$jk
              break
           ;;
           *"make -c"*) # ncurses has a pushd with make commands
              if $foundPushd; then # keep writing until popd found
                combine[countc++]="  ${commands[jk]}"
              else
                countg=$jk
                break
              fi
           ;;
           *popd*)
	     if $foundPushd; then # write it out and set foundPushd to false
                combine[countc++]="  ${commands[jk]}"
		foundPushd=false
             else
		echo "popd found but no pushd found before it"
		echo "Something is wrong. You need to investigate"
		exit 1
	     fi
	   ;;
           *"install_man_docs install_html_docs"*) # openssl in chapter06
              countg=$jk
              break
           ;;
           *"LANG=en_US.UTF-8 ninja"*) # systemd using ninja
              countg=$jk
              break
           ;;
           *'LIBRARY_PATH=/tools/lib make'*) # the eudev make command
              countg=$jk
              break
           ;;
           "cp services protocols"*) # iana-etc copy
              countg=$jk
              break
           ;;
           *ninja*)
              countg=$jk
              break
           ;;
           "pip3 wheel"*) # meson markupsafe
              countg=$jk
              break
           ;;
           "python3 -m build -n") # wheel using destdir
              countg=$jk
              break
           ;;
           *install*) # test to see if part of a continuation squence
              case ${commands[jk]} in
                 *\\) # a continuation line
                    if [ $cont -gt 0 ]; then # part of configure sequence so store it
                      storit[cont++]="${commands[jk]}"
                    else # assume an install cont line
                      countg=$jk
                      break
                    fi
                 ;;
                 './configure'*) # might be a configure with install in it
                    combine[countc++]="  ${commands[jk]}"
                    inc=true
                 ;;
                 *)
                    countg=$jk
                    break
                 ;;
              esac
           ;;
           *)
              case "${commands[jk]}" in
                 *\\)
                    storit[cont++]="${commands[jk]}"
                 ;;
                 *)
                    # write with any continuation lines
                    if [ $cont -gt 0 ]; then
                      for (( l=0; l<$cont; l++ )); do
                        combine[countc++]="  ${storit[l]}"
                      done
                      combine[countc++]="  ${commands[jk]}"
                      cont=0
                      inc=true
                    else
                      combine[countc++]="  ${commands[jk]}" # configure command
                      inc=true # found at least one configure command
                    fi
                    if [ $[jk+1] -eq $numc ]; then countg=$jk; fi
                 ;;
              esac
           ;;
        esac
      done
      if [ $cont -gt 0 ]; then
        for (( l=0; l<$cont; l++ )); do
          combine[countc++]="  ${storit[l]}"
        done
        combine[countc++]="  ${commands[countg++]}"
        inc=true
        cont=0
      fi
      if ! $inc; then
        combine[countc++]='  echo "no configure script for this package"'
      fi
    ;;
    make_commands*)
      inc=false
      combine[countc++]=${buildWrap[countbl++]}
      combine[countc++]=${buildWrap[countbl++]} # the {: command
      for (( jl=$countg; jl<$numc; jl++ )); do
        case ${commands[jl]} in
           *"install_man_docs install_html_docs"*) # openssl chapter06, write this
              combine[countc++]="  ${commands[jl]}"
              cont=0
              inc=true
           ;;
           *install*) # assume an install command
              countg=$jl
              break
           ;;
           'cp -v src/{msgfmt'*) # gettext ch5
              countg=$jl
              break
           ;;
           'cp -v src/{fstab-decode'*) # sysvinit (systemd) ch6
              countg=$jl
              break
           ;;
           'cp -v perl cpan'*) # perl ch5
              countg=$jl
              break
           ;;
           "cp services protocols"*) # iana-etc copy
              countg=$jl
              break
           ;; 
           *)
              case "${commands[jl]}" in
                 *\\)
                     storit[cont++]="${commands[jl]}"
                 ;;
                 *)
                     if [ $cont -gt 0 ]; then # write the continuation lines
                       for (( l=0; l<$cont; l++ )); do
                         combine[countc++]="  ${storit[l]}"
                       done
                       combine[countc++]="  ${commands[jl]}"
                       cont=0
                       inc=true
                     else
                       combine[countc++]="  ${commands[jl]}" # make commands
                       inc=true #at least one make command found
                     fi
                     if [ $[jl+1] -eq $numc ]; then # no more commands
                       countg=$jl
                       if [[ "${commands[$countg]}" != *make* ]]; then
                         ((countc--))
                       fi
                     fi
                 ;;
              esac
           ;;
        esac
      done
       if ! $inc; then
         combine[countc++]='  echo "no make script for this package"'
       fi
    ;;
    install_commands*)
      inc=false
      foundDoc=false
      tarCom=false
      combine[countc++]=${buildWrap[countbl++]}
      combine[countc++]=${buildWrap[countbl++]} # the {: command
      for (( jm=$countg; jm<$numc; jm++ )); do
        case ${commands[jm]} in
          *install*)
             case "${commands[jm]}" in
               *\\) # cont line so store it
                  case "${commands[jm]}" in
                    *'/usr/share/doc'*) # cont line contains a doc
                        foundDoc=true
                        storit[cont++]="${commands[jm]}"
                    ;;
                    *) # no doc in this cont line
                        storit[cont++]="${commands[jm]}"
                    ;;
                  esac
               ;;
               'make'*'=/usr/share/doc'*|*'DOCDIR=/usr/share/doc'*) # genuine install command
                    if [ $cont -gt 0 ]; then # first write out cont lines
                      for (( l=0; l<$cont; l++ )); do
                        combine[countc++]="  ${storit[l]}"
                      done
                    fi
                    combine[countc++]="  ${commands[jm]}"
                    inc=true
               ;;
               *'/usr/share/doc'*) # don't write a doc install
                    :
               ;;
               *) # install line so write it out
                    if [ $cont -gt 0 ]; then # first write out cont lines
                      for (( l=0; l<$cont; l++ )); do
                        combine[countc++]="  ${storit[l]}"
                      done
                    fi
                    combine[countc++]="  ${commands[jm]}"
                    inc=true
                    cont=0
                    countg=$((jm+1))
               ;;
             esac
          ;;
          "tar "*) # a tar command, so break
             countg=$jm
             cont=0
             inc=true
             tarCom=true # set to true in case continuation lines have a /usr/share/doc in them
             break
          ;;
          '#'*) # comment line so ignore it
              if [ $[jm+1] -eq $numc ]; then countg=$[jm+1]; fi
          ;;
          if*) # starts with if so if a doc, will need to delete the closing fi
                   case ${commands[jm]} in
                   *'/usr/share/doc'*)
                       ifDoc=true
                       case ${commands[j]} in
                          *\\) # a continuation line so store it
                                storit[cont++]="${commands[jm]}"
                          ;;
                       esac
                   ;;
                   *\\) # a continuation line
                       storit[cont++]="${commands[jm]}"
                   ;;
                   *) # if block but not a doc or a cont line
                       echo ${commands[jm]}
                   ;;
                esac
          ;;
          *'mv -v /usr/share/doc/openssl'*) # add version to the openssl doc dir
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          *'/usr/share/doc'*) # would have got here because we have a cont line
             cont=0 # doc so don't write it out
             countg=$((jm+1)) # update countg in case this is the last line
          ;;
          "for "*) # begining of a for loop so break
             countg=$jm
             cont=0
             inc=true
             break
          ;;
          'cp -v src/{fstab-decode'*|'cp -v src/last'*|'cp -v man/{last'*|'cp -v man/{fstab-decode'*) # sysvinit (systemd) ch6
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'cp -v perl cpan/podlators'*|'mkdir -pv /tools/lib/perl5'*|'cp -Rv lib/* /tools/lib/perl5'*) # perl ch5
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'make -C ld clean'*|'make -C ld LIB_PATH=/usr/lib:/lib'*|'cp -v ld/ld-new /tools/bin'*) # binutils pass 2
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'cp -v gettext-tools/src/{msgfmt'*) # gettext chapter07
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'cp -rv usr/include $LFS/usr'*) # linux-headers copy
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'cp -rv usr/include /usr'*) # linux-headers copy when updating
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'cp -rv dest/* /'*) # meson copy from destdir
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'cp services protocols /etc'*) # iana-etc copy
	    combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;; 
          *)
             case "${commands[jm]}" in
               *\\) # if a cont line, then store it
                     storit[cont++]="${commands[jm]}"
               ;;
               'cp -v src/msgfmt'*)
                     combine[countc++]="  ${commands[jm]}"
                     countg=$((jm+1))
                     cont=0
                     inc=true
               ;;
               *)
                     if ! $foundDoc; then # write out any cont lines
                       if [ $cont -gt 0 ]; then
                         for (( l=0; l<$cont; l++ )); do
                           combine[countc++]="  ${storit[l]}"
                         done
                         combine[countc++]="  ${commands[jm]}"
                         cont=0
                         inc=true
                         countg=$((jm+1))
                       else # not part of install commands so break
                         countg=$jm
                         cont=0
                         inc=true
                         break
                       fi
                     else # continuation of a doc line so ignore it
                       cont=0
                     fi
               ;;
             esac
          ;;
        esac
      done
      if ! $inc; then
        combine[countc++]='  echo "no install script for this package"'
      fi
    ;;
    *)
      if [ $i -lt $countbl ]; then
        :
      else
        combine[countc++]=${buildWrap[i]}
        ((countbl++)) # increment because have written another build command
      fi
    ;;
  esac
done
rtr=(${combine[@]})
} # end combineScript
#
getBuild () {
# $1 is the pkguser directory in /tools, pkguser by default
local pkguser=${1:-pkguser}
local abuild=""
buildfile=${LFS}/tools/${pkguser}/build
if [ ! -e $buildfile ]; then
  return $RETURN_PARAM
else
IFS='
'
abuild=( $( < $buildfile ) )
rtrnBuild=(${abuild[@]})
return 0
fi
} # end getBuild
#
getComms () {
# $1 is the chapter containing the commands
# if present, $2 is the package name. This can be used to modify the commands
# Note - DumpedCommands and CmdName are global variables
local acom=""
local bcom=""
local chapreq=$1
local pkgname=${2:-""}
#msg "in function getComms"
#msg "DumpedCommands is $DumpedCommands"
#msg "chapreq is $chapreq"
#msg "CmdName is $CmdName"
if [ -e ${DumpedCommands}/${chapreq}/*-${CmdName} ]; then
  curfile=${DumpedCommands}/${chapreq}/*-${CmdName}
#  msg "curfile is ${curfile[@]}"
else
  return $RETURN_PARAM
fi
local IFS='
'
acom=( $( < $curfile ) )
#
# can use pkgname to adjust the commands here if required
#
if [ ! -z "$pkgname" ]; then
  msg "*** NOTE *** you've set pkgname to $pkgname in getComms"
  msg "you need set up a case statement in function getComms"
  msg "in order to edit the commands for $pkgname"
#  case $pkgname in
#     somePkgName)
#       edits to the acom array
#       rtrnCom=(${acom[@]})
#       return 0
#     ;;
#  esac
  msg "Aborting"
  exit 1
else
  rtrnCom=(${acom[@]}) # rtrnCom is global
  return 0
fi
} # end getComms
#
GetCommands () {
#get access to the arrays
rtrnBuild=""
getBuild
return_val=$?
if [ "$return_val" -eq $RETURN_PARAM ]; then # no build file present in /tools
  return $RETURN_PARAM
else
buildScripts=(${rtrnBuild[@]})
rtrnCom=""
getComms $currentChapter
ret_val=$?
if [ "$ret_val" -eq $RETURN_PARAM ]; then # no commands found
  echo 'echo "No commands found for package '"$PkgName"' in '"$lfscommands"'"
echo "Check you have the correct book written to '"$lfscommands"'"
echo "and that '"$PkgName"' is supposed to be installed in '"$currentChapter"'"
echo "This script will fail."
echo "Aborting"
exit 1' >> $Output
  return $RETURN_NO_CMNDS
else
  commandScripts=(${rtrnCom[@]})
  numclines=${#commandScripts[@]} # # of commands
#
# place commands in output until first configure found
  countg=0
  contline=0
  foundCase=false # keep track of a case statement
  foundPushd=false # used to find the corresponding popd
  for line in "${commandScripts[@]}"; do
    case "$line" in
         sed*)
           echo "$line"
           ((countg++))
         ;;
         *pushd*) # ncurses has this in chapter06
	   foundPushd=true
	   countg=$countg-$contline
	   break
	 ;;
         *"case \$(uname -m) in"*)
           if [ "$PkgName" = gcc -o "$PkgName" = glibc ]; then # write it
             foundCase=true # expect to find an esac
             echo "$line"
             ((countg++))
           else # case statement in findutils
             countg=$countg-$contline
             break
           fi
         ;;
         *"case \"\$online"*) # stripping
           if [ "$PkgName" = stripping ]; then # write it
             foundCase=true # expect to find an esac
             echo "$line"
             ((countg++))
           fi
         ;;
         *esac*) # check that foundCase is true
           if $foundCase; then # write it
             echo "$line"
             ((countg++))
             foundCase=false
           else # something wrong
             msg "found an esac but not the case statement"
             msg "PkgName is $PkgName"
             msg "INVESTIGATE"
             exit 1
           fi
         ;;
         *configure*|*Configure*) #Perl has Configure!
           countg=$countg-$contline
           break
         ;;
         *"config --prefix="*) # openssl
           countg=$countg-$contline
           break
         ;;
         *"cp services protocols"*) # iana-etc copy
           break
         ;;
         *"LANG=en_US.UTF-8"*) # systemd has this at start of configure
           countg=$countg-$contline
           break
         ;;
         "meson --prefix="*)
           countg=$countg-$contline
           break
         ;;
         "perl Makefile"*) # xml-parser is a perl module
           countg=$countg-$contline
           break
         ;;
         "pip3 install"*)
           countg=$countg-$contline
           break
         ;;
         "pip3 wheel -w dist "*) # for meson
           countg=$countg-$contline
           break
         ;;
         make*) #begins with make
           break
         ;;
         "PKG_CONFIG_PATH=/usr/lib/pkgconfig"*) # added for systemd using meson
           break
         ;;
         *)
# if a continuation line, store in cache
           case "$line" in
              *\\)
               cacheit[contline++]="$line"
               ((countg++))
              ;;
              *)
               if [ $contline -gt 0 ]; then # continuation line found
                 for (( l=0; l<$contline; l++ )); do
                   echo "${cacheit[l]}"
                 done
                 echo "$line"
                 contline=0
                 ((countg++)) # count # of commands written to output
                 if [ $countg -eq $numclines ]; then
                   return 0
                 fi
               else
                 echo "$line"
                 ((countg++)) # count # of commands written to output
                 if [ $countg -eq $numclines ]; then 
                   return 0 
                 fi
               fi
              ;;
            esac
         ;;
    esac
  done
#
  rtr=""
  combineScripts commandScripts[@] buildScripts[@]
  scriptOut=(${rtr[@]})
  for t in "${scriptOut[@]}"; do
    echo $t
  done
  if [ $countg -lt $((numclines)) ]; then # output remaining commands
    contin=false # switch for a continuation line
    contline=0   # # of continuation lines found
    iftest=false # test for an if block with a /usr/share/doc in it
    for (( k=$countg; k<$((numclines)); k++ )); do
#msg "command is ${commandScripts[k]}"
      case ${commandScripts[k]} in
         install*)
                case ${commandScripts[k]} in
                   *'/usr/share/doc'*)
                       case ${commandScripts[k]} in
                          *\\) # a continuation line
                             contin=true
                          ;;
                       esac
                   ;;
                   *\\) # a continuation line
                       cacheit[contline++]=${commandScripts[k]}
                       contin=true
                   ;;
                   *) # install but not a doc or a cont line
                       echo ${commandScripts[k]}
                   ;;
                esac
         ;;
         if*) # starts with if so if a doc, will need to delete the closing fi
                case ${commandScripts[k]} in
                   *'/usr/share/doc'*)
                       iftest=true
                       case ${commandScripts[k]} in
                          *\\) # a continuation line
                             contin=true
                          ;;
                       esac
                   ;;
                   *\\) # a continuation line
                       cacheit[contline++]=${commandScripts[k]}
                       contin=true
                   ;;
                   *) # if test but not a doc or a cont line
                       echo ${commandScripts[k]}
                   ;;
                esac
         ;;
         ln*) # a symlink so write it - e.g. vim74
                echo ${commandScripts[k]}
         ;;
         *'/usr/share/doc'*)
                case ${commandScripts[k]} in
                    *\\) # a continuation line
                       if $tarCom; then # part of a tar command so write it to the cache
                         cacheit[contline++]=${commandScripts[k]}
                       fi
                       contin=true
                    ;;
                    *)
                       if $contin; then # is a doc, so don't write
                         contin=false
                         contline=0
                       fi
                    ;;
                esac
         ;;
         "fi"*)
                if $iftest; then # end of a doc if test - don't write it
                  iftest=false
                else
                  echo ${commandScripts[k]} # if block is not a doc
                fi
         ;;
         *)
                if ! $iftest; then # commands not within a doc if block
                  case ${commandScripts[k]} in
                      *\\) # continuation line, store it
                           cacheit[contline++]=${commandScripts[k]}
                           contin=true
                      ;;
                      *)
                           if [ $contline -gt 0 ]; then # write out continuation lines
                             for (( l=0; l<$contline; l++ )); do
                               echo "${cacheit[l]}"
                             done
                             contin=false
                             tarCom=false
                             contline=0
                           fi
                           echo ${commandScripts[k]}
                      ;;
                  esac
                fi
         ;;
      esac
    done
  fi
fi
return 0
fi
} # end GetCommands
#
dbusComms () {
local dbuscom=""
dbuscom[0]="./configure --prefix=/usr \\"
dbuscom[1]="            --sysconfdir=/etc \\"
dbuscom[2]="            --localstatedir=/var \\"
dbuscom[3]="            --libexecdir=/usr/lib/dbus-1.0 \\"
dbuscom[4]="            --docdir=/usr/share/doc/dbus-${dbusvers} \\"
dbuscom[5]="            --with-system-pid-file=/run/dbus/pid \\"
dbuscom[6]="            --with-system-socket=/run/dbus/system_bus_socket \\"
dbuscom[7]="            --disable-static \\"
dbuscom[8]="            --enable-systemd \\"
dbuscom[9]="            --with-console-auth-dir=/run/console/ \\"
dbuscom[10]="            --with-systemdsystemunitdir=/usr/lib/systemd/system"
dbuscom[11]="make"
dbuscom[12]="make install"
dbuscom[13]="ln -s /etc/machine-id /var/lib/dbus"
rtrncommands=(${dbuscom[@]})
} # end dbusComms
#
gccComms () {
local gcccom=""
gcccom[0]='case $(uname -m) in'
gcccom[1]="  x86_64)"
gcccom[2]="    sed -i.orig '/m64=/s/lib64/lib/' gcc/config/i386/t-linux64"
gcccom[3]="  ;;"
gcccom[4]="esac"
gcccom[5]="mkdir build"
gcccom[6]="cd build"
gcccom[7]="../configure --prefix=/usr      \\"
gcccom[8]="             --disable-multilib \\"
gcccom[9]="             --with-system-zlib \\"
gcccom[10]="             --enable-languages=c,c++,fortran"
gcccom[11]="make"
gcccom[12]="make install"
gcccom[13]="mkdir -pv /usr/share/gdb/auto-load/usr/lib"
gcccom[14]="mv -v /usr/lib/*gdb.py /usr/share/gdb/auto-load/usr/lib"
gcccom[15]="ln -v -sf ../usr/bin/cpp /lib"
gcccom[16]="ln -v -sf gcc /usr/bin/cc"
gcccom[17]="install -v -dm755 /usr/lib/bfd-plugins"
gcccom[18]='ln -sfv ../../libexec/gcc/$(gcc -dumpmachine)/${gccVers}/liblto_plugin.so /usr/lib/bfd-plugins/'
rtrncommands=(${gcccom[@]})
} # end gccComms
#
gccDestdirComms () {
local gccdestcom=""
gccdestcom[0]='case $(uname -m) in'
gccdestcom[1]="  x86_64)"
gccdestcom[2]="    sed -i.orig '/m64=/s/lib64/lib/' gcc/config/i386/t-linux64"
gccdestcom[3]="  ;;"
gccdestcom[4]="esac"
gccdestcom[5]="mkdir build"
gccdestcom[6]="cd build"
gccdestcom[7]="../configure --prefix=/usr      \\"
gccdestcom[8]="             --disable-multilib \\"
gccdestcom[9]="             --with-system-zlib \\"
gccdestcom[10]="             --enable-languages=c,c++,fortran"
gccdestcom[11]="make"
gccdestcom[12]="make DESTDIR=\"\$CUR_DIR\" install"
gccdestcom[13]="mkdir -pv \"\$CUR_DIR\"/usr/share/gdb/auto-load/usr/lib"
gccdestcom[14]="mv -v \"\$CUR_DIR\"/usr/lib/*gdb.py \"\$CUR_DIR\"/usr/share/gdb/auto-load/usr/lib"
gccdestcom[15]="ln -v -sf ../usr/bin/cpp \"\$CUR_DIR\"/lib"
gccdestcom[16]="ln -v -sf gcc \"\$CUR_DIR\"/usr/bin/cc"
gccdestcom[17]="install -v -dm755 \"\$CUR_DIR\"/usr/lib/bfd-plugins"
gccdestcom[18]='ln -sfv ../../libexec/gcc/$(gcc -dumpmachine)/${gccVers}/liblto_plugin.so "$CUR_DIR"/usr/lib/bfd-plugins/'
rtrncommands=(${gccdestcom[@]})
} # end gccDestdirComms
#
mesonDestdirComms () {
local mesondestcom=""
mesondestcom[0]="pip3 wheel -w dist --no-build-isolation --no-deps \$PWD"
mesondestcom[1]="PYTHONPATH=src python3 -m installer --destdir=\"\$CUR_DIR\" dist/*.whl"
mesondestcom[2]="install -dm0755 \"\${CUR_DIR}\"/usr/bin"
mesondestcom[3]="install -vDm644 data/shell-completions/bash/meson \"\${CUR_DIR}\"/usr/share/bash-completion/completions/meson"
mesondestcom[4]="install -vDm644 data/shell-completions/zsh/_meson \"\${CUR_DIR}\"/usr/share/zsh/site-functions/_meson"
rtrncommands=(${mesondestcom[@]})
} # end mesonDestdirComms
#
ncursesComms () {
local ncursescom=""
ncursescom[0]="./configure --prefix=/usr           \\"
ncursescom[1]="            --mandir=/usr/share/man \\"
ncursescom[2]="            --with-shared           \\"
ncursescom[3]="            --without-debug         \\"
ncursescom[4]="            --without-normal        \\"
ncursescom[5]="            --enable-pc-files       \\"
ncursescom[6]="            --enable-widec          \\"
ncursescom[7]="            --with-pkg-config-libdir=/usr/lib/pkgconfig"
ncursescom[8]="make"
ncursescom[9]="make DESTDIR=\"\$CUR_DIR\" install"
ncursescom[10]="install -vm755 \"\${CUR_DIR}\"/usr/lib/libncursesw.so.6.3 /usr/lib"
ncursescom[11]="rm -v \"\${CUR_DIR}\"/usr/lib/{libncursesw.so.6.3,libncurses++w.a}"
ncursescom[12]="set +e"
ncursescom[13]="pushd ../usr > /dev/null"
ncursescom[14]="cp -a * /usr"
ncursescom[15]="popd > /dev/null"
ncursescom[16]="set -e"
ncursescom[17]="for lib in ncurses form panel menu ; do"
ncursescom[18]="    rm -vf                    /usr/lib/lib\${lib}.so"
ncursescom[19]="    echo \"INPUT(-l\${lib}w)\" > /usr/lib/lib\${lib}.so"
ncursescom[20]="    ln -sfv \${lib}w.pc        /usr/lib/pkgconfig/\${lib}.pc"
ncursescom[21]="done"
ncursescom[22]="rm -vf                     /usr/lib/libcursesw.so"
ncursescom[23]="echo \"INPUT(-lncursesw)\" > /usr/lib/libcursesw.so"
ncursescom[24]="ln -sfv libncurses.so      /usr/lib/libcurses.so"
rtrncommands=(${ncursescom[@]})
} # end ncursesComms
#
ncursesDestdirComms () {
local ncursesdestcom=""
ncursesdestcom[0]="./configure --prefix=/usr           \\"
ncursesdestcom[1]="            --mandir=/usr/share/man \\"
ncursesdestcom[2]="            --with-shared           \\"
ncursesdestcom[3]="            --without-debug         \\"
ncursesdestcom[4]="            --without-normal        \\"
ncursesdestcom[5]="            --enable-pc-files       \\"
ncursesdestcom[6]="            --enable-widec          \\"
ncursesdestcom[7]="            --with-pkg-config-libdir=/usr/lib/pkgconfig"
ncursesdestcom[8]="make"
ncursesdestcom[9]="make DESTDIR=\"\$CUR_DIR\" install"
ncursesdestcom[10]="rm -v \"\${CUR_DIR}\"/usr/lib/libncurses++w.a"
ncursesdestcom[11]="for lib in ncurses form panel menu ; do"
ncursesdestcom[12]="    rm -vf                    \"\${CUR_DIR}\"/usr/lib/lib\${lib}.so"
ncursesdestcom[13]="    echo \"INPUT(-l\${lib}w)\" > \"\${CUR_DIR}\"/usr/lib/lib\${lib}.so"
ncursesdestcom[14]="    ln -sfv \${lib}w.pc        \"\${CUR_DIR}\"/usr/lib/pkgconfig/\${lib}.pc"
ncursesdestcom[15]="done"
ncursesdestcom[16]="rm -vf                     \"\${CUR_DIR}\"/usr/lib/libcursesw.so"
ncursesdestcom[17]="echo \"INPUT(-lncursesw)\" > \"\${CUR_DIR}\"/usr/lib/libcursesw.so"
ncursesdestcom[18]="ln -sfv libncurses.so      \"\${CUR_DIR}\"/usr/lib/libcurses.so"
rtrncommands=(${ncursesdestcom[@]})
} # end ncursesDestdirComms
#
shadowComms () {
local shadowcom=""
shadowcom[0]="sed -i 's/groups\$(EXEEXT) //' src/Makefile.in"
shadowcom[1]="find man -name Makefile.in -exec sed -i 's/groups\\.1 / /'   {} \\;"
shadowcom[2]="find man -name Makefile.in -exec sed -i 's/getspnam\\.3 / /' {} \\;"
shadowcom[3]="find man -name Makefile.in -exec sed -i 's/passwd\\.5 / /'   {} \\;"
shadowcom[4]="sed -e 's@#ENCRYPT_METHOD DES@ENCRYPT_METHOD SHA512@' \\"
shadowcom[5]="    -e 's@/var/spool/mail@/var/mail@'                 \\"
shadowcom[6]="    -e '/PATH=/{s@/sbin:@@;s@/bin:@@}'                \\"
shadowcom[7]="    -i etc/login.defs"
shadowcom[8]="sed -i -e 's/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\//' \\"
shadowcom[9]="       -e 's/zh_CN zh_TW//' \\"
shadowcom[10]="       -e 's/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr //' man/Makefile.in"
shadowcom[11]="./configure --sysconfdir=/etc \\"
shadowcom[12]="            --disable-static  \\"
shadowcom[13]="            --with-group-name-max-length=32"
shadowcom[14]="make"
shadowcom[15]="make exec_prefix=/usr install"
shadowcom[16]="make -C man install-man"
shadowcom[17]="install -v -m644 /etc/login.defs /etc/login.defs.orig"
shadowcom[18]="for FUNCTION in FAIL_DELAY               \\"
shadowcom[19]="                FAILLOG_ENAB             \\"
shadowcom[20]="                LASTLOG_ENAB             \\"
shadowcom[21]="                MAIL_CHECK_ENAB          \\"
shadowcom[22]="                OBSCURE_CHECKS_ENAB      \\"
shadowcom[23]="                PORTTIME_CHECKS_ENAB     \\"
shadowcom[24]="                QUOTAS_ENAB              \\"
shadowcom[25]="                CONSOLE MOTD_FILE        \\"
shadowcom[26]="                FTMP_FILE NOLOGINS_FILE  \\"
shadowcom[27]="                ENV_HZ PASS_MIN_LEN      \\"
shadowcom[28]="                SU_WHEEL_ONLY            \\"
shadowcom[29]="                CRACKLIB_DICTPATH        \\"
shadowcom[30]="                PASS_CHANGE_TRIES        \\"
shadowcom[31]="                PASS_ALWAYS_WARN         \\"
shadowcom[32]="                CHFN_AUTH ENCRYPT_METHOD \\"
shadowcom[33]="                ENVIRON_FILE"
shadowcom[34]="do"
shadowcom[35]='    sed -i "s/^${FUNCTION}/# &/" /etc/login.defs'
shadowcom[36]="done"
shadowcom[37]='cat > /etc/pam.d/login << "EOF"'
shadowcom[38]="# Begin /etc/pam.d/login"
shadowcom[39]="# Set failure delay before next prompt to 3 seconds"
shadowcom[40]="auth      optional    pam_faildelay.so  delay=3000000"
shadowcom[41]="# Check to make sure that the user is allowed to login"
shadowcom[42]="auth      requisite   pam_nologin.so"
shadowcom[43]="# Check to make sure that root is allowed to login"
shadowcom[44]="# Disabled by default. You will need to create /etc/securetty"
shadowcom[45]="# file for this module to function. See man 5 securetty."
shadowcom[46]="#auth      required    pam_securetty.so"
shadowcom[47]="# Additional group memberships - disabled by default"
shadowcom[48]="#auth      optional    pam_group.so"
shadowcom[49]="# include system auth settings"
shadowcom[50]="auth      include     system-auth"
shadowcom[51]="# check access for the user"
shadowcom[52]="account   required    pam_access.so"
shadowcom[53]="# include system account settings"
shadowcom[54]="account   include     system-account"
shadowcom[55]="# Set default environment variables for the user"
shadowcom[56]="session   required    pam_env.so"
shadowcom[57]="# Set resource limits for the user"
shadowcom[58]="session   required    pam_limits.so"
shadowcom[59]="# Display date of last login - Disabled by default"
shadowcom[60]="#session   optional    pam_lastlog.so"
shadowcom[61]="# Display the message of the day - Disabled by default"
shadowcom[62]="#session   optional    pam_motd.so"
shadowcom[63]="# Check user's mail - Disabled by default"
shadowcom[64]="#session   optional    pam_mail.so      standard quiet"
shadowcom[65]="# include system session and password settings"
shadowcom[66]="session   include     system-session"
shadowcom[67]="password  include     system-password"
shadowcom[68]="# End /etc/pam.d/login"
shadowcom[69]="EOF"
shadowcom[70]='cat > /etc/pam.d/passwd << "EOF"'
shadowcom[71]="# Begin /etc/pam.d/passwd"
shadowcom[72]="password  include     system-password"
shadowcom[73]="# End /etc/pam.d/passwd"
shadowcom[74]="EOF"
shadowcom[75]='cat > /etc/pam.d/su << "EOF"'
shadowcom[76]="# Begin /etc/pam.d/su"
shadowcom[77]="# always allow root"
shadowcom[78]="auth      sufficient  pam_rootok.so"
shadowcom[79]="# Allow users in the wheel group to execute su without a password"
shadowcom[80]="# disabled by default"
shadowcom[81]="#auth      sufficient  pam_wheel.so trust use_uid"
shadowcom[82]="# include system auth settings"
shadowcom[83]="auth      include     system-auth"
shadowcom[84]="# limit su to users in the wheel group"
shadowcom[85]="auth      required    pam_wheel.so use_uid"
shadowcom[86]="# include system account settings"
shadowcom[87]="account   include     system-account"
shadowcom[88]="# Set default environment variables for the service user"
shadowcom[89]="session   required    pam_env.so"
shadowcom[90]="# include system session settings"
shadowcom[91]="session   include     system-session"
shadowcom[92]="# End /etc/pam.d/su"
shadowcom[93]="EOF"
shadowcom[94]='cat > /etc/pam.d/chpasswd << "EOF"'
shadowcom[95]="# Begin /etc/pam.d/chpasswd"
shadowcom[96]="# always allow root"
shadowcom[97]="auth      sufficient  pam_rootok.so"
shadowcom[98]="# include system auth and account settings"
shadowcom[99]="auth      include     system-auth"
shadowcom[100]="account   include     system-account"
shadowcom[101]="password  include     system-password"
shadowcom[102]="# End /etc/pam.d/chpasswd"
shadowcom[103]="EOF"
shadowcom[104]="sed -e s/chpasswd/newusers/ /etc/pam.d/chpasswd >/etc/pam.d/newusers"
shadowcom[105]='cat > /etc/pam.d/chage << "EOF"'
shadowcom[106]="# Begin /etc/pam.d/chage"
shadowcom[107]="# always allow root"
shadowcom[108]="auth      sufficient  pam_rootok.so"
shadowcom[109]="# include system auth and account settings"
shadowcom[110]="auth      include     system-auth"
shadowcom[111]="account   include     system-account"
shadowcom[112]="# End /etc/pam.d/chage"
shadowcom[113]="EOF"
shadowcom[114]="for PROGRAM in chfn chgpasswd chsh groupadd groupdel \\"
shadowcom[115]="               groupmems groupmod useradd userdel usermod"
shadowcom[116]="do"
shadowcom[117]='    install -v -m644 /etc/pam.d/chage /etc/pam.d/${PROGRAM}'
shadowcom[118]='    sed -i "s/chage/$PROGRAM/" /etc/pam.d/${PROGRAM}'
shadowcom[119]="done"
shadowcom[120]="[ -f /etc/login.access ] && mv -v /etc/login.access{,.NOUSE}"
shadowcom[121]="[ -f /etc/limits ] && mv -v /etc/limits{,.NOUSE}"
rtrncommands=(${shadowcom[@]})
} # end shadowComms
# same as above but using DESTDIR
shadowDestdirComms () {
local shadowdestcom=""
shadowdestcom[0]="sed -i 's/groups\$(EXEEXT) //' src/Makefile.in"
shadowdestcom[1]="find man -name Makefile.in -exec sed -i 's/groups\\.1 / /'   {} \\;"
shadowdestcom[2]="find man -name Makefile.in -exec sed -i 's/getspnam\\.3 / /' {} \\;"
shadowdestcom[3]="find man -name Makefile.in -exec sed -i 's/passwd\\.5 / /'   {} \\;"
shadowdestcom[4]="sed -e 's@#ENCRYPT_METHOD DES@ENCRYPT_METHOD SHA512@' \\"
shadowdestcom[5]="    -e 's@/var/spool/mail@/var/mail@'                 \\"
shadowdestcom[6]="    -e '/PATH=/{s@/sbin:@@;s@/bin:@@}'                \\"
shadowdestcom[7]="    -i etc/login.defs"
shadowdestcom[8]="sed -i -e 's/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\//' \\"
shadowdestcom[9]="       -e 's/zh_CN zh_TW//' \\"
shadowdestcom[10]="       -e 's/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr //' man/Makefile.in"
shadowdestcom[11]="./configure --sysconfdir=/etc \\"
shadowdestcom[12]="            --disable-static  \\"
shadowdestcom[13]="            --with-group-name-max-length=32"
shadowdestcom[14]="make"
shadowdestcom[15]="make exec_prefix=/usr DESTDIR=\"\$CUR_DIR\" install"
shadowdestcom[16]="make -C man DESTDIR=\"\$CUR_DIR\" install-man"
shadowdestcom[17]="install -v -m644 \"\${CUR_DIR}\"/etc/login.defs \"\${CUR_DIR}\"/etc/login.defs.orig"
shadowdestcom[18]="for FUNCTION in FAIL_DELAY               \\"
shadowdestcom[19]="                FAILLOG_ENAB             \\"
shadowdestcom[20]="                LASTLOG_ENAB             \\"
shadowdestcom[21]="                MAIL_CHECK_ENAB          \\"
shadowdestcom[22]="                OBSCURE_CHECKS_ENAB      \\"
shadowdestcom[23]="                PORTTIME_CHECKS_ENAB     \\"
shadowdestcom[24]="                QUOTAS_ENAB              \\"
shadowdestcom[25]="                CONSOLE MOTD_FILE        \\"
shadowdestcom[26]="                FTMP_FILE NOLOGINS_FILE  \\"
shadowdestcom[27]="                ENV_HZ PASS_MIN_LEN      \\"
shadowdestcom[28]="                SU_WHEEL_ONLY            \\"
shadowdestcom[29]="                CRACKLIB_DICTPATH        \\"
shadowdestcom[30]="                PASS_CHANGE_TRIES        \\"
shadowdestcom[31]="                PASS_ALWAYS_WARN         \\"
shadowdestcom[32]="                CHFN_AUTH ENCRYPT_METHOD \\"
shadowdestcom[33]="                ENVIRON_FILE"
shadowdestcom[34]="do"
shadowdestcom[35]='    sed -i "s/^${FUNCTION}/# &/" "${CUR_DIR}"/etc/login.defs'
shadowdestcom[36]="done"
shadowdestcom[37]='cat > "${CUR_DIR}"/etc/pam.d/login << "EOF"'
shadowdestcom[38]="# Begin /etc/pam.d/login"
shadowdestcom[39]="# Set failure delay before next prompt to 3 seconds"
shadowdestcom[40]="auth      optional    pam_faildelay.so  delay=3000000"
shadowdestcom[41]="# Check to make sure that the user is allowed to login"
shadowdestcom[42]="auth      requisite   pam_nologin.so"
shadowdestcom[43]="# Check to make sure that root is allowed to login"
shadowdestcom[44]="# Disabled by default. You will need to create /etc/securetty"
shadowdestcom[45]="# file for this module to function. See man 5 securetty."
shadowdestcom[46]="#auth      required    pam_securetty.so"
shadowdestcom[47]="# Additional group memberships - disabled by default"
shadowdestcom[48]="#auth      optional    pam_group.so"
shadowdestcom[49]="# include system auth settings"
shadowdestcom[50]="auth      include     system-auth"
shadowdestcom[51]="# check access for the user"
shadowdestcom[52]="account   required    pam_access.so"
shadowdestcom[53]="# include system account settings"
shadowdestcom[54]="account   include     system-account"
shadowdestcom[55]="# Set default environment variables for the user"
shadowdestcom[56]="session   required    pam_env.so"
shadowdestcom[57]="# Set resource limits for the user"
shadowdestcom[58]="session   required    pam_limits.so"
shadowdestcom[59]="# Display date of last login - Disabled by default"
shadowdestcom[60]="#session   optional    pam_lastlog.so"
shadowdestcom[61]="# Display the message of the day - Disabled by default"
shadowdestcom[62]="#session   optional    pam_motd.so"
shadowdestcom[63]="# Check user's mail - Disabled by default"
shadowdestcom[64]="#session   optional    pam_mail.so      standard quiet"
shadowdestcom[65]="# include system session and password settings"
shadowdestcom[66]="session   include     system-session"
shadowdestcom[67]="password  include     system-password"
shadowdestcom[68]="# End /etc/pam.d/login"
shadowdestcom[69]="EOF"
shadowdestcom[70]='cat > "${CUR_DIR}"/etc/pam.d/passwd << "EOF"'
shadowdestcom[71]="# Begin /etc/pam.d/passwd"
shadowdestcom[72]="password  include     system-password"
shadowdestcom[73]="# End /etc/pam.d/passwd"
shadowdestcom[74]="EOF"
shadowdestcom[75]='cat > "${CUR_DIR}"/etc/pam.d/su << "EOF"'
shadowdestcom[76]="# Begin /etc/pam.d/su"
shadowdestcom[77]="# always allow root"
shadowdestcom[78]="auth      sufficient  pam_rootok.so"
shadowdestcom[79]="# Allow users in the wheel group to execute su without a password"
shadowdestcom[80]="# disabled by default"
shadowdestcom[81]="#auth      sufficient  pam_wheel.so trust use_uid"
shadowdestcom[82]="# include system auth settings"
shadowdestcom[83]="auth      include     system-auth"
shadowdestcom[84]="# limit su to users in the wheel group"
shadowdestcom[85]="auth      required    pam_wheel.so use_uid"
shadowdestcom[86]="# include system account settings"
shadowdestcom[87]="account   include     system-account"
shadowdestcom[88]="# Set default environment variables for the service user"
shadowdestcom[89]="session   required    pam_env.so"
shadowdestcom[90]="# include system session settings"
shadowdestcom[91]="session   include     system-session"
shadowdestcom[92]="# End /etc/pam.d/su"
shadowdestcom[93]="EOF"
shadowdestcom[94]='cat > "${CUR_DIR}"/etc/pam.d/chpasswd << "EOF"'
shadowdestcom[95]="# Begin /etc/pam.d/chpasswd"
shadowdestcom[96]="# always allow root"
shadowdestcom[97]="auth      sufficient  pam_rootok.so"
shadowdestcom[98]="# include system auth and account settings"
shadowdestcom[99]="auth      include     system-auth"
shadowdestcom[100]="account   include     system-account"
shadowdestcom[101]="password  include     system-password"
shadowdestcom[102]="# End /etc/pam.d/chpasswd"
shadowdestcom[103]="EOF"
shadowdestcom[104]="sed -e s/chpasswd/newusers/ \"\${CUR_DIR}\"/etc/pam.d/chpasswd >\"\${CUR_DIR}\"/etc/pam.d/newusers"
shadowdestcom[105]='cat > "${CUR_DIR}"/etc/pam.d/chage << "EOF"'
shadowdestcom[106]="# Begin /etc/pam.d/chage"
shadowdestcom[107]="# always allow root"
shadowdestcom[108]="auth      sufficient  pam_rootok.so"
shadowdestcom[109]="# include system auth and account settings"
shadowdestcom[110]="auth      include     system-auth"
shadowdestcom[111]="account   include     system-account"
shadowdestcom[112]="# End /etc/pam.d/chage"
shadowdestcom[113]="EOF"
shadowdestcom[114]="for PROGRAM in chfn chgpasswd chsh groupadd groupdel \\"
shadowdestcom[115]="               groupmems groupmod useradd userdel usermod"
shadowdestcom[116]="do"
shadowdestcom[117]='    install -v -m644 "${CUR_DIR}"/etc/pam.d/chage "${CUR_DIR}"/etc/pam.d/${PROGRAM}'
shadowdestcom[118]='    sed -i "s/chage/$PROGRAM/" "${CUR_DIR}"/etc/pam.d/${PROGRAM}'
shadowdestcom[119]="done"
shadowdestcom[120]="[ -f /etc/login.access ] && mv -v \"\${CUR_DIR}\"/etc/login.access{,.NOUSE}"
shadowdestcom[121]="[ -f /etc/limits ] && mv -v \"\${CUR_DIR}\"/etc/limits{,.NOUSE}"
rtrncommands=(${shadowdestcom[@]})
} # end shadowDestdirComms
#
sysvinitComms () {
local sysvinitcom=""
sysvinitcom[0]="make -C src fstab-decode"
sysvinitcom[1]="make -C src killall5"
sysvinitcom[3]="cp -v src/{fstab-decode,killall5} /usr/sbin"
sysvinitcom[6]="cp -v man/{fstab-decode,killall5,pidof}.8 /usr/share/man/man8"
sysvinitcom[7]="ln -sv ../sbin/killall5 /usr/bin/pidof"
rtrncommands=(${sysvinitcom[@]})
} # end sysvinitComms
#
wheelDestdirComms () {
local wheeldestcom=""
wheeldestcom[0]="python3 -m build -n"
wheeldestcom[1]="PYTHONPATH=src python3 -m installer --destdir=\"\$CUR_DIR\" dist/*.whl"
rtrncommands=(${wheeldestcom[@]})
} # end wheelDestdirComms
#
GetInternalCommands () {
# $1 is the function name that creates the commands
# get access to the build array
rtrnBuild=""
getBuild
return_val=$?
if [ $return_val -eq $RETURN_PARAM ]; then # no build file present
  return $RETURN_PARAM
else
  buildScripts=(${rtrnBuild[@]})
  declare -a rtrncommands=""
  eval $1
  commandScripts=(${rtrncommands[@]})
  numclines=${#commandScripts[@]}
  countg=0 # initialize commands counter
  cont=0
  for line in "${commandScripts[@]}"; do
    case "$line" in
       sed*)
# test if sed has continuation line
         case "$line" in
           *\\)
             cacheit[cont++]="$line"
             ((countg++))
           ;;
           *)
             echo "$line"
             ((countg++))
           ;;
         esac
       ;;
       *configure*)
         break
       ;;
       make*) #  if no configure script present
         break
       ;;
       "perl Makefile.PL") # for perl modules
         break
       ;;
       "python3 -m build"*) # for wheel with destdir
         break
       ;;
       "pip3 wheel -w dist "*) # for meson with destdir
         break
       ;;
       *)
         case "$line" in
            *\\) # if a continuation line then store in cache
             cacheit[cont++]="$line"
             ((countg++))
            ;;
            *)
             if [ $cont -gt 0 ]; then # continuation line found
               for (( l=0; l<$cont; l++ )); do
                 echo "${cacheit[l]}"
               done
               echo "$line"
               cont=0
               ((countg++)) # count # of commands written to output
             else
               echo "$line"
               ((countg++)) # count # of commands written to output
             fi
            ;;
          esac
       ;;
    esac
  done
#
  rtr=""
  combineScripts commandScripts[@] buildScripts[@]
  scriptOut=(${rtr[@]})
  for t in "${scriptOut[@]}"; do
    echo $t
  done
  if [ $countg -lt $numclines ]; then # output remaining commands
    contin=false
    for (( k=$countg; k<$numclines; k++ )); do
      if [[ "${commandScripts[k]}" == install* ]]; then #don't install docs
        case ${commandScripts[k]} in
            *\\) # continuation line
                contin=true
            ;;
            */usr/share/doc*) # doc so don't write
                continue
            ;;
            *) # not a doc so write it
                echo ${commandScripts[k]}
            ;;
        esac
      else
        if $contin; then
          if [[ "${commandScripts[k]}" == *\\ ]]; then # more continuation
            :
          else
            contin=false
          fi
        else
          echo ${commandScripts[k]}
        fi
      fi
    done
  fi
  return 0
fi
} # end GetInternalCommands
#
createPkguser () {
cat >> $Output << "CPUEOF"
createPkguser () {
# $1 is the UID of the package
# $2 is the GID of the package. In this scheme UID = GID
# if $1 and $2 are 0, then the values are incremented on the initial value of 10000
# does the $PkgName user exist?
ret=false
getent passwd $PkgName > /dev/null 2>&1 && ret=true
if $ret; then
  echo "user $PkgName exists"
# make sure the home dir exists
  mkdir -pv ${PkgUserDir}/${PkgName}
else # create it and add it to the install group
  echo "Creating the user $PkgName"
  if [ $2 -ne 0 ]; then
    groupadd -g $2 $PkgName
    mkdir -pv ${PkgUserDir}/${PkgName}
    useradd -d ${PkgUserDir}/${PkgName} -s /bin/bash -u $1 -g $PkgName -m -k /dev/null $PkgName
  else # increment
    groupadd $PkgName
    useradd -d ${PkgUserDir}/${PkgName} -s /bin/bash -g $PkgName -m -k /dev/null $PkgName
  fi
  usermod -aG install $PkgName # add PkgName to the install group
fi
# create the .bash_profile and .bashrc files if they don't exist
if [ ! -e ${PkgUserDir}/${PkgName}/.bash_profile ]; then
  echo "exec env -i HOME=\$HOME TERM=\$TERM PS1='\u:\w\$ ' ${LFS}/install${PkgName}.sh" >> ${PkgUserDir}/${PkgName}/.bash_profile
fi
if [ ! -e ${PkgUserDir}/${PkgName}/.bashrc ]; then
  cat > ${PkgUserDir}/${PkgName}/.bashrc << "EOF"
set +h
umask 022
LFS=/mnt/lfs
LC_ALL=POSIX
LFS_TGT=$(uname -m)-lfs-linux-gnu
PATH=/usr/bin
if [ ! -L /bin ]; then PATH=/bin:$PATH; fi
PATH=$LFS/tools/bin:$PATH
CONFIG_SITE=$LFS/usr/share/config.site
export LFS LC_ALL LFS_TGT PATH CONFIG_SITE
EOF
fi
} # end createPkguser
#
CPUEOF
} # end createPkguser
#
cleanPkgDir () {
    cat >> $Output << "EOF"
cleanpkgdir () {
# $1 is the dir to clean
# $2 is the pkgname
local dirtoClean=$1
local pkgtoClean=$2
rm -rf ${dirtoClean}/${pkgtoClean}/{..?*,.[!.]*,*}
} # end cleanpkgdir
#
EOF
} # end cleanPkgDir
#
Header () {
echo writing the script to: $Output
if [[ "$as_root" = true && ("$currentChapter" = chapter05 || "$currentChapter" = chapter06) ]]; then
  cat > $Output << "EOF"
#!/bin/bash -e
#
if [ $UID -eq 0 ]; then
  echo "Please do NOT run this script as root."
  echo "Run it as user lfs."
  exit 1
fi
if [ $(whoami) != "lfs" ]; then echo Please run this script as user lfs. ; exit 1; fi
#
EOF
else # as root and chapter 7,8,10 and update or as pkguser
  cat > $Output << "EOF"
#!/bin/bash -e
#
if [ $UID -ne 0 ]; then echo Please run this script as root. ; exit 1; fi
#
EOF
fi
echo "me=\$0
GITINFO=\"$GITINFO\"
AS_ROOT=$as_root" >> $Output
if $useDESTDIR; then echo "useDESTDIR=$useDESTDIR" >> $Output; fi
case "$currentChapter" in
   chapter05|chapter06)
     echo "Chapter=$Chapter
LFS=$LFS" >> $Output
     if ! $as_root; then
       echo "PkgUserDir=\${LFS}${PkgUserDir}" >> $Output
       cat >> $Output << "EOF"
buildDir=${LFS}/build
if [ ! -d ${LFS}/build ]; then
  mkdir -v ${LFS}/build
fi
chgrp install ${LFS}/{build,LFS-build.log}
chmod 1775 ${LFS}/build
chmod 664 ${LFS}/LFS-build.log
EOF
       createPkguser
     else # as root
       cat >> $Output << "EOF"  
buildDir=${LFS}/build
BuildLog=/LFS-build.log
sourcedir=/sources
sourceloc=${sourcedir}/trunk
#
EOF
       CreateBuildDir
       unpack05
     fi
   ;;
   chapter07|chapter08|chapter10)
       echo "PkgUserDir=$PkgUserDir
sourcedir=$sourcedir
sourceloc=$sourceloc
BuildLog=/$BuildLog
Chapter=$Chapter
pkguserdir=/tools/${pkgFileName}
wgetopts=\"$wgetopts\"
ncc=\"--no-check-certificate\"" >> $Output
       if [[ "$Chapter" = update && "$as_root" = false ]]; then
         echo "# make sure a pkguser can write to BuildLog
chgrp install $BuildLog
chmod 664 $BuildLog" >> $Output
       fi
       if $as_root; then
         CreateBuildDirasroot
         unpack07
       else
         setUserEnv # used in packageuser home dir to make sure .bash_profile and .bashrc are symlinks to /etc/pkgusr dir
         resetBashProfile # make sure Chapter is set in /etc/pkgusr
       fi
       if [ "$Chapter" = update ]; then cleanPkgDir; fi
       if [[ "$useDESTDIR" = true && "$installDEST" = false ]]; then createPkgFile; fi
   ;;
esac
} # end Header
#
unpackPkguser () {
#
# $1 is the pkguser filename
local pkguserFile=$1
if [ -L ${LFS}/tools ]; then
  echo "${LFS}/tools is currently a symbolic link"
  echo "It needs to be a directory."
  rm -v ${LFS}/tools
fi
if [ ! -d ${LFS}/tools ]; then install -vm755 -d ${LFS}/tools; fi
tar -xvf ${LFS}${sourcedir}/${pkguserFile} -C ${LFS}/tools --no-same-owner
if [ $? -ne 0 ]; then
  return $RETURN_PARAM
else
  rm ${LFS}${sourcedir}/${pkguserFile}
  return 0
fi
} #end unpackPkguser
#
copypkguserbin () { # when installing as root, may need listdelpkg.sh
cat >> $Output << "EOF"
copypkguserbin_ () {
FuncName=copypkguserbin
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName" #package already built so skip
  return 0
else
  echo "In function $FuncName"
fi
EOF
echo "pkguserdir=/tools/${pkgFileName}" >> $Output
cat >> $Output << "EOF"
cp ${pkguserdir}/bin/* /usr/bin/
echo "${FuncName}" >> $BuildLog
}
EOF
} # end copypkguserbin
#
pkguser () {
cat >> $Output << "EOF"
pkguser_ () {
FuncName=pkguser
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName" #package already built so skip
  return 0
else
  echo "In function $FuncName"
fi
EOF
echo "local pkguserdir=/tools/${pkgFileName}" >> $Output
cat >> $Output << "EOF"
cp ${pkguserdir}/sbin/* /usr/bin # groupadd, su and useradd (packages from shadow)
cp ${pkguserdir}/usr/sbin/* /usr/bin # installpkg
if [ $(uname -m) = x86_64 ]; then
  mv /usr/bin/su64 /usr/bin/su
  chmod 0755 /usr/bin/su
else
  echo "This doesn't exist"
  echo "You need to create su32 using shadow - aborting"
  exit 1
  mv /usr/bin/su32 /usr/bin/su
fi
if [ ! -d /etc/pkgusr/skel-package ]; then
  install -v -m0755 -d /etc/pkgusr/skel-package
fi
cp -r ${pkguserdir}/etc/* /etc/pkgusr/ # bash_profile, bashrc, skel-package symlinks
cp ${pkguserdir}/bin/* /usr/bin/ # listdelpkg.sh
# make them executable
chmod 755 /usr/bin/{groupadd,useradd,su,installpkg,listdelpkg.sh}
#
if [ "$(grep -q ^install\: /etc/group;echo $?)" != 0 ]; then
  groupadd -g 9999 install
fi
# make sure pkgusers can write to the logfile
chgrp install $BuildLog
chmod 664 $BuildLog
# set some initial dirs to install and sticky
chgrp 9999 $(cat ${pkguserdir}/installdirs.lst)
chmod 1775 $(cat ${pkguserdir}/installdirs.lst)
EOF
# if using sysvinit for init then build uses /usr/libexec
if [ "$SYSTEMD" = no ]; then
  echo "chgrp install /usr/libexec
chmod 1775 /usr/libexec" >> $Output
fi
cat >> $Output << "EOF"
#
cat >> /etc/pkgusr/bash_profile << "BashProfile"
#
complete -o default -o nospace -A user su finger pinky
#export PkgName=$LOGNAME
EOF
echo "Chapter=$currentChapter
testBuilt=\".\${Chapter/apter/}\${LOGNAME}\"" >> $Output
echo "if [ -e /usr/src/core/\${LOGNAME}/${build} -a ! -e ~/\${testBuilt} ]; then
  cd
  bash -e /usr/src/core/\${LOGNAME}/${build}" >> $Output
cat >> $Output << "EOF"
  exit
fi
BashProfile
install -v -d /usr/src/core/${LOGNAME}
echo "${FuncName}" >> $BuildLog
}
EOF
} # end of pkguser
#
resetBashProfile () {
# recreates bash_profile in /etc/pkgusr to reflect changes in chapter
cat >> $Output << "EOF"
resetBashProfile_ () {
cat > /etc/pkgusr/bash_profile << "BASHPEOF"
export PATH=/bin:/usr/bin

# Make prompt reflect that we are a package user.
export PROMPT_COMMAND='PS1="package \u:"`pwd`"> "'

# Go to the home directory when su to a package user.
cd
#
complete -o default -o nospace -A user su finger pinky
#export PkgName=$LOGNAME
EOF
if [ "$Chapter" = chapter10 ]; then
  if $useDESTDIR; then
    echo "Chapter=$Chapter
testBuilt=\".\${Chapter/apter/}\${LOGNAME}-destdir\"" >> $Output
  else
    echo "Chapter=$currentChapter
testBuilt=\".\${Chapter/apter/}\${LOGNAME}\"" >> $Output
  fi
elif [ "$Chapter" = update ]; then
  if $useDESTDIR; then
    echo "Chapter=update
testBuilt=\".\${Chapter}\${LOGNAME}-destdir\"" >> $Output
  else
    echo "Chapter=update
testBuilt=\".\${Chapter}\${LOGNAME}\"" >> $Output
  fi
else
  echo "Chapter=$currentChapter
testBuilt=\".\${Chapter/apter/}\${LOGNAME}\"" >> $Output
fi
cat >> $Output << "EOF"
if [ -e /usr/src/core/${LOGNAME}/build -a ! -e ~/${testBuilt} ]; then
  cd
  bash -e /usr/src/core/${LOGNAME}/build
  exit
fi
BASHPEOF
} # resetBashProfile
EOF
} # resetBashProfile
#
update_pkguser () {
cat >> $Output << "EOF"
update_pkguser_ () {
FuncName=update_pkguser
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName" #package already built so skip
  return
fi
EOF
echo "pkguserdir=/tools/${pkgFileName}" >> $Output
cat >> $Output << "EOF"
cp ${pkguserdir}/sbin/* /usr/bin # groupadd, su and useradd (packages from shadow)
cp ${pkguserdir}/usr/sbin/* /usr/bin # installpkg
if [ $(uname -m) = x86_64 ]; then
  mv /usr/bin/su64 /usr/bin/su
else
  echo "This doesn't exist"
  echo "You need to create su32 using shadow - aborting"
  exit 1
  mv /usr/bin/su32 /usr/bin/su
fi
# make sure pkgusers can write to the logfile
chgrp install $BuildLog
chmod 664 $BuildLog
#
cat > /etc/pkgusr/bash_profile << "BashProfile"
export PATH=/bin:/usr/bin:/opt/jdk/bin:/opt/ant/bin:/opt/qt/bin
export PROMPT_COMMAND='PS1="package \u:"$(pwd)"> "'
cd
EOF
echo "PkgUserDir=$PkgUserDir" >> $Output
cat >> $Output << "EOF"
complete -o default -o nospace -A user su finger pinky
#export PkgName=$LOGNAME
EOF
if $useDESTDIR; then
  echo "if [ -e \${PkgUserDir}/\${LOGNAME}/${build} -a ! -e ~/.\${LOGNAME}-destdir ]; then
  cd
  bash \${PkgUserDir}/\${LOGNAME}/$build" >> $Output
else
  echo "if [ -e \${PkgUserDir}/\${LOGNAME}/$build -a ! -e ~/.\${LOGNAME} ]; then
  cd
  bash \${PkgUserDir}/\${LOGNAME}/$build" >> $Output
fi
cat >> $Output << "EOF"
  exit
fi
BashProfile
echo "${FuncName}" >> $BuildLog
}
EOF
} # end update_pkguser
#
delSrcFile () {
echo "cd \$curdir
cd ..
rm -rf \$curdir
rm -rf .wget-hsts"
} # end of delSrcFile
#
setUserEnv () {
cat >> $Output << "EOF"
setUserEnv () {
# delete the .bashrc and .bash_profile files in /usr/src/core/PkgName and
# replace with symlinks to /etc/pkgusr versions. Used in chroot so no LFS needed
# $1 is the package user directory usually /usr/src/core
# $2 is the package name
local PkgUserDir=$1
local PkgName=$2
pushd ${PkgUserDir}/${PkgName} > /dev/null
# make sure .bash_profile and .basrc are symlinks to /etc/pkgusr
rm -rf .bash_profile .bashrc
ln -svf /etc/pkgusr/bash_profile .bash_profile
ln -svf /etc/pkgusr/bashrc .bashrc
chown -h $PkgName:$PkgName .bash*
popd > /dev/null
} # end setUserEnv
EOF
} # end setUserEnv
#
createPkgFile () {
cat >> $Output << "EOF"
createPkgfile () {
# get dir names, make the package tar file and delete the build directories
# $1 is the PkgUserDir directory
# $2 is the PkgName
# if present, $3 is the package version to use, bypassing SetPkgvers
# if present, $4 is the name of the dir that contains the pkg binary tarfile
local PkgUserDir=$1
local PkgName=$2
local pkgvers=${3:-""}
local pkgBinDir=${4:-"pkgbindir"}
local listDIRS extension packageName pkgfilename
local trimto=".tar"
local separator="-"
#
case $PkgName in
   expect)
      packageName="expect5"
      separator="."
   ;;
   jinja2)
      packageName="Jinja2"
   ;;
   kernel)
      packageName="linux"
   ;;
   markupsafe)
      packageName="MarkupSafe"
   ;;
   python3)
      packageName="Python"
   ;;
   tcl)
      packageName="tcl8"
      trimto="-src"
      separator="."
   ;;
   xml-parser)
      packageName="XML-Parser"
   ;;
   *)
      packageName=$PkgName
   ;;
esac
#
if [ $(uname -m) = x86_64 ]; then
  extension="x86_64.pkg.tar.xz"
else
  extension="i686.pkg.tar.xz"
fi
# go to the install dir
pushd ${PkgUserDir}/${PkgName} > /dev/null # make sure in the right dir
if [ ! -z "$pkgvers" ]; then
  pkgfilename="${packageName}-${pkgvers}-${extension}"
else
  echo "trimto is $trimto"
  fndSrcpkg=$(find . -name "${packageName}${separator}[0-9]*${trimto}.*z*")
  fndSrcpkg=${fndSrcpkg##*/} # filename only
#  echo "fndSrcpkg is $fndSrcpkg"
  pkgplusvers="${fndSrcpkg%${trimto}*}"
  pkgfilename="${pkgplusvers}-${extension}"
fi
echo "pkgfilename is $pkgfilename"
listDIRS=$(ls -l --time-style="long-iso" . | egrep '^d' | awk '{print $8}')
# check the dirs present so as not to delete any needed ones
local chknum=( $listDIRS )
for (( i=0; i<${#chknum[@]}; i++ )); do
  if [[ ${chknum[i]} != boot && ${chknum[i]} != etc && ${chknum[i]} != usr && ${chknum[i]} != var ]]; then
    echo "Directory ${chknum[i]} will be included in the package file"
    echo "Is this correct? (Y/n)"
    read reply
      case $reply in
         [yY]|[yY][Ee][Ss])
              echo "okay continuing"
         ;;
         [nN]|[nN][Oo])
              echo "Will delete ${chknum[i]} from listDIRS"
              listDIRS=${listDIRS/${chknum[i]}/}
echo "listDIRS is now ${listDIRS[@]}"
         ;;
         *)
              echo "okay continuing"
         ;;
      esac
  fi
done
# add the .INSTALL file if present
if [ -e .INSTALL ]; then
  listDIRS="$listDIRS .INSTALL"
fi
tar -cJf $pkgfilename $listDIRS
# mv the package binary file to its own dir
# to be distinct from the source tarfile
mkdir -pv $pkgBinDir
mv -v $pkgfilename $pkgBinDir
if ! $AS_ROOT; then chown -R $PkgName:$PkgName $pkgBinDir; fi
# ask to delete the destdir directories
for dir in $listDIRS; do
  if [ -d $dir ]; then
    echo "Delete dir $dir? (Y/n)"
  elif [ -f $dir ]; then
    echo "Delete file $dir? (Y/n)"
  fi
  read reply
    case $reply in
         [yY]|[yY][Ee][Ss])
              echo "okay deleting $dir"
              rm -rf $dir
         ;;
         [nN]|[nN][Oo])
              echo "okay continuing"
         ;;
         *)
              echo "okay deleting $dir"
              rm -rf $dir
         ;;
    esac
done
popd > /dev/null
} # end createPkgfile
#
EOF
} # end createPkgFile
#
getUrlSrcDnld () {
# get the url to download the src file and, if downloaded already, the location to copy it
# $1 is either unpack or unpack07, depending either ! root or root install, respectively
local unpackType=$1
for srcURL in ${sourceURL[@]}; do
  serchstr="*$SrcName*.tar.*z*"
  useThisSrcLoc=""
  case $FuncName in # can modify the src file name to search for
# and add the location for already downloaded src files
     bash|coreutils|diffutils|file|findutils|gawk|glibc|grep|gzip|m4|ncurses|openssl|patch|sed|tar|xz)
       useThisSrcLoc="/build/${FuncName}"
     ;;
     binutils)
       useThisSrcLoc="/build/binutilspass1"
     ;;
     gcc|gmp|libstdc++pass2|mpc|mpfr)
       useThisSrcLoc="/build/gccpass1"
     ;;
     kernel)
       serchstr="*/linux-[0-9]*"
       useThisSrcLoc="/build/linuxheaders"
     ;;
     linuxheaders)
       if [ "$WHICH_CHAPTER" = update ]; then # use the latest kernel
         serchstr="*/linux-[0-9]*"
         useThisSrcLoc="/usr/src/core/linux-headers"
       fi
     ;;
     make) # get make not automake
       serchstr="*/make-[0-9]*"
       useThisSrcLoc="/build/${FuncName}"
     ;;
  esac
  case $srcURL in
     $serchstr)
       echo "$unpackType \$SrcName \"$srcURL\" \"$useThisSrcLoc\"" >> $Output
       break
     ;;
  esac
done
} # end getUrlSrcDnld
#
dnldAddFiles () {
case $FuncName in
#   autoconf) # need the patch
#     cat >> $Output << "EOF"
#if [ -e ${CUR_DIR}/autoconf-*-consolidated_fixes-1.patch  ]; then
#  echo "patch already in place - will use that"
#elif [ -e ${sourceloc}/autoconf-*-consolidated_fixes-1.patch  ]; then
#  cp -v ${sourceloc}/autoconf-*-consolidated_fixes-1.patch ../
#else # download it
#  if [ -e /usr/bin/wget ]; then # wget exists on target machine
#    wget $wgetopts -O ../autoconf-2.69-consolidated_fixes-1.patch "http://www.linuxfromscratch.org/patches/lfs/development/autoconf-2.69-consolidated_fixes-1.patch"
#  else
#    echo "/usr/bin/wget not found on the target machine"
#    echo "Install it to continue"
#    echo "Aborting"
#    exit 1
#  fi
#fi
#EOF
#   ;;
   binutils) # need the patch
     echo "binutilsPatch=\"$binutilsPatch\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${binutilsPatch} ]; then
  echo "patch already in place - will use that"
elif [ -e ${sourceloc}/${binutilsPatch} ]; then
  cp -v ${sourceloc}/${binutilsPatch} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../${binutilsPatch} "http://www.linuxfromscratch.org/patches/lfs/development/${binutilsPatch}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
   bzip2) # need the patch
     echo "bzip2Patch=\"$bzip2Patch\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${bzip2Patch} ]; then
  echo "patch already in place - will use that"
elif [ -e ${sourceloc}/${bzip2Patch} ]; then
  cp -v ${sourceloc}/${bzip2Patch} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../${bzip2Patch} "http://www.linuxfromscratch.org/patches/lfs/development/${bzip2Patch}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
   coreutils) # need the patches
     echo "coreutilsPatch1=\"$coreutilsPatch1\"" >> $Output
     echo "coreutilsPatch2=\"$coreutilsPatch2\"" >> $Output
     for ((ij=1; ij<3; ij++)); do
       cat >> $Output << EOF
if [ -e \${CUR_DIR}/\${coreutilsPatch${ij}} ]; then
  echo "patch already in place - will use that"
elif [ -e \${sourceloc}/\${coreutilsPatch${ij}} ]; then
  cp -v \${sourceloc}/\${coreutilsPatch${ij}} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget \$wgetopts \$ncc -O ../\${coreutilsPatch${ij}} "http://www.linuxfromscratch.org/patches/lfs/development/\${coreutilsPatch${ij}}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
     done
   ;;
#   gcc) # need the patch
#     echo "gccPatch=\"gcc-11.1.0-upstream_fixes-1.patch\"" >> $Output
#     cat >> $Output << "EOF"
#if [ -e ${CUR_DIR}/${gccPatch} ]; then
#  echo "$gccPatch patch already in $CUR_DIR, will use that"
#elif [ -e ${sourceloc}/${gccPatch} ]; then
#  cp -v ${sourceloc}/${gccPatch} ../
#else
#  if [ -e /usr/bin/wget ]; then # wget exists on target machine
#    wget $wgetopts $ncc -O ../${gccPatch} https://www.linuxfromscratch.org/patches/lfs/development/${gccPatch}
#  else
#    echo "/usr/bin/wget not found on the target machine"
#    echo "Install it to continue"
#    echo "Aborting"
#    exit 1
#  fi
#fi
#EOF
#   ;;
   glibc) # need the patch and the time zone data
     echo "glibcPatch=\"${glibcPatch}\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${glibcPatch} ]; then
  echo "$glibcPatch patch already in $CUR_DIR, will use that"
elif [ -e ${sourceloc}/${glibcPatch} ]; then
  cp -v ${sourceloc}/${glibcPatch} ../
else
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts -O ../${glibcPatch} http://www.linuxfromscratch.org/patches/lfs/development/${glibcPatch}
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
     echo "tzdataFile=\"$tzdataFile\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${tzdataFile} ]; then
  echo "$tzdataFile file already downloaded - will use that one"
elif [ -e ${sourceloc}/${tzdataFile} ]; then
  cp -v ${sourceloc}/${tzdataFile} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../${tzdataFile} "https://www.iana.org/time-zones/repository/releases/${tzdataFile}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
   kbd) # need the patch
     echo "kbdPatch=\"${kbdPatch}\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${kbdPatch} ]; then
  echo "patch already in place - will use that"
elif [ -e ${sourceloc}/${kbdPatch} ]; then
  cp -v ${sourceloc}/${kbdPatch} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../${kbdPatch} "http://www.linuxfromscratch.org/patches/lfs/development/${kbdPatch}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
   kernel) # if making the kernel, need to add mproper
     if [ "$MAKE_KERNEL" = yes ]; then
       cat >> $Output << "EOF"
make mrproper
cp ${sourcedir}/.config .
# copy the firmware to /usr/lib/firmware
cp -r /tools/pkguser/firmware/* /usr/lib/firmware/
EOF
     fi
   ;;
#   meson) # need the patch
#     cat >> $Output << "EOF"
#if [ -e ${CUR_DIR}/meson-0.56.0-upstream_fix-1.patch ]; then
#  echo "patch already in place - will use that"
#elif [ -e ${sourceloc}/meson-0.56.0-upstream_fix-1.patch ]; then
#  cp -v ${sourceloc}/meson-0.56.0-upstream_fix-1.patch ../
#else # download it
#  if [ -e /usr/bin/wget ]; then # wget exists on target machine
#    wget $wgetopts $ncc -O ../meson-0.56.0-upstream_fix-1.patch "http://www.linuxfromscratch.org/patches/lfs/development/meson-0.56.0-upstream_fix-1.patch"
#  else
#    echo "/usr/bin/wget not found on the target machine"
#    echo "Install it to continue"
#    echo "Aborting"
#    exit 1
#  fi
#fi
#EOF
#   ;;
#    perl) # need the patch
#     echo "perlPatch=\"${perlPatch}\"" >> $Output
#     cat >> $Output << "EOF"
#if [ -e ${CUR_DIR}/${perlPatch} ]; then
#  echo "patch already in place - will use that"
#elif [ -e ${sourceloc}/${perlPatch} ]; then
#  cp -v ${sourceloc}/${perlPatch} ../
#else # download it
#  if [ -e /usr/bin/wget ]; then # wget exists on target machine
#    wget $wgetopts $ncc -O ../${perlPatch} "http://www.linuxfromscratch.org/patches/lfs/development/${perlPatch}"
#  else
#    echo "/usr/bin/wget not found on the target machine"
#    echo "Install it to continue"
#    echo "Aborting"
#    exit 1
#  fi
#fi
#EOF
#   ;;
# no shadow patch currently
#   shadow)
#     echo "shadowPatch=\"${shadowPatch}\"" >> $Output
#     cat >> $Output << "EOF"
#if [ -e ${CUR_DIR}/${shadowPatch} ]; then 
#  echo "patch already in place - will use that"
#elif [ -e ${sourceloc}/${shadowPatch} ]; then 
#  cp -v ${sourceloc}/${shadowPatch} ../
#else # download it
#  if [ -e /usr/bin/wget ]; then # wget exists on target machine
#    wget $wgetopts $ncc -O ../${shadowPatch} "http://www.linuxfromscratch.org/patches/lfs/development/${shadowPatch}"
#  else
#    echo "/usr/bin/wget not found on the target machine"
#    echo "Install it to continue"
#    echo "Aborting"
#    exit 1
#  fi
#fi
#EOF
#   ;;
   systemd) # need the man-pages
     echo "systemdManPages=\"$systemdManPages\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${systemdManPages} ]; then
  echo "systemd-man-pages already downloaded - will use that one"
elif [ -e ${sourceloc}/${systemdManPages} ]; then
  cp -v ${sourceloc}/${systemdManPages} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../${systemdManPages} "http://anduin.linuxfromscratch.org/LFS/${systemdManPages}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
  ;;
   tcl) # need the html file
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${SrcName}*html.tar.*z* ]; then
  echo "tcl8 html file already downloaded - will use that one"
elif [ -e ${sourceloc}/${SrcName}*html.tar.*z* ]; then
  cp -v ${sourceloc}/${SrcName}*html.tar.*z* ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../tcl8.6.12-html.tar.gz "https://downloads.sourceforge.net/tcl/tcl8.6.12-html.tar.gz"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
   xz) # need the patch
     echo "xzPatch=\"${xzPatch}\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${xzPatch} ]; then
  echo "patch already in place - will use that"
elif [ -e ${sourceloc}/${xzPatch} ]; then
  cp -v ${sourceloc}/${xzPatch} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../${xzPatch} "http://www.linuxfromscratch.org/patches/lfs/development/${xzPatch}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
   zstd) # need the patch
     echo "zstdPatch=\"${zstdPatch}\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${zstdPatch} ]; then
  echo "patch already in place - will use that"
elif [ -e ${sourceloc}/${zstdPatch} ]; then
  cp -v ${sourceloc}/${zstdPatch} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../${zstdPatch} "http://www.linuxfromscratch.org/patches/lfs/development/${zstdPatch}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
esac
} # end dnldAddFiles
#
setInstallDirs () {
#set required dirs to be install dirs
# $1 is the package name
local pkgname=$1
# first deal with any .INSTALL files
case $pkgname in
   autoconf|automake|bc|coreutils|diffutils|findutils|flex|gawk|gdbm|gettext|gperf|groff|grub|gzip|libtool|m4|make|shadow|tar|texinfo)
     if $useDESTDIR; then # include the INSTALL file
       cat >> $Output << "EOF"
if [ -f "${pkguserdir}/installFiles/${PkgName}/INSTALL" ]; then
  install -m644 ${pkguserdir}/installFiles/${PkgName}/INSTALL ${PkgUserDir}/${PkgName}/.INSTALL
  if ! $AS_ROOT; then chown $PkgName:$PkgName ${PkgUserDir}/${PkgName}/.INSTALL; fi
fi
EOF
     fi
   ;;
esac
# now set install dirs
case $pkgname in
   bash) #/usr/share/aclocal
     if ! $useDESTDIR; then
        cat >> $Output << "EOF"
chgrp install /usr/share/aclocal
chmod g+w,o+t /usr/share/aclocal
chown -h bash:bash /bin/sh
exec /bin/bash --login
EOF
     fi
   ;;
   binutils)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/lib/bfd-plugins
chmod g+w,o+t /usr/lib/bfd-plugins
EOF
     fi
   ;;     
   bison)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/aclocal
chmod g+w,o+t /usr/share/aclocal
EOF
     fi
   ;;
   bzip2) # prepare locales for installation
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/locale/*/LC_MESSAGES
chmod g+w,o+t /usr/share/locale/*/LC_MESSAGES
chgrp install /usr/share/doc
chmod g+w,o+t /usr/share/doc
EOF
     fi
   ;;
   coreutils)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown 0:coreutils /etc/{group,group-}
chmod 644 /etc/{group,group-}
EOF
     fi
   ;;
   dejagnu)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown root:install /usr/share/info/{,dir}
chmod g+w,o+t /usr/share/info
chmod 664 /usr/share/info/dir
EOF
     fi
   ;;
   dbus)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown root /usr/lib/dbus-1.0/dbus-daemon-launch-helper
chmod 4750 /usr/lib/dbus-1.0/dbus-daemon-launch-helper
chgrp install /usr/lib/dbus-1.0
chmod g+w,o+t /usr/lib/dbus-1.0
chgrp install /usr/share/dbus-1
chmod g+w,o+t /usr/share/dbus-1
chgrp install /usr/share/dbus-1/services
chmod g+w,o+t /usr/share/dbus-1/services
chgrp install /usr/share/dbus-1/system-services
chmod g+w,o+t /usr/share/dbus-1/system-services
chgrp install /usr/include/dbus-1.0/dbus
chmod g+w,o+t /usr/include/dbus-1.0/dbus
chgrp install /usr/lib/systemd/
chmod g+w,o+t /usr/lib/systemd/
chgrp install /usr/lib/systemd/system
chmod g+w,o+t /usr/lib/systemd/system
chgrp install /usr/lib/systemd/system/sockets.target.wants
chmod g+w,o+t /usr/lib/systemd/system/sockets.target.wants
chgrp install /usr/lib/systemd/system/multi-user.target.wants
chmod g+w,o+t /usr/lib/systemd/system/multi-user.target.wants
EOF
     else
       cat >> $Output << "EOF"
chown root ${PkgUserDir}/${PkgName}/usr/lib/dbus-1.0/dbus-daemon-launch-helper
chmod 4750 ${PkgUserDir}/${PkgName}/usr/lib/dbus-1.0/dbus-daemon-launch-helper
mkdir -pv ${PkgUserDir}/${PkgName}/run/dbus
chown 0:0 ${PkgUserDir}/${PkgName}/run
chown dbus:dbus ${PkgUserDir}/${PkgName}/run/dbus
chmod 1777 ${PkgUserDir}/${PkgName}/run
EOF
     fi
   ;;
   eudev)
     cat >> $Output << "EOF"
chgrp install /lib/udev/rules.d
chmod g+w,o+t /lib/udev/rules.d
chgrp install /lib/firmware
chmod g+w,o+t /lib/firmware
EOF
   ;;
   expat)
     cat >> $Output << "EOF"
chgrp install /usr/lib/cmake
chmod g+w,o+t /usr/lib/cmake
EOF
   ;;
   file)
     cat >> $Output << "EOF"
rm -rf ${PkgUserDir}/${PkgName}/usr/share/man/man5 # this is empty
EOF
   ;;
   glibc) #/usr/share/info/dir
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown root:install /usr/share/info/dir
chmod 664 /usr/share/info/dir
chgrp install /usr/include/sys # for libcap
chmod g+w,o+t /usr/include/sys
if [ -d /usr/lib/systemd ]; then
  chgrp install /usr/lib/systemd
  chmod g+w,o+t /usr/lib/systemd
  chgrp install /usr/lib/systemd/system
  chmod g+w,o+t /usr/lib/systemd/system
  chgrp install /usr/lib/tmpfiles.d
  chmod g+w,o+t /usr/lib/tmpfiles.d
fi
# check the symlink ld-linux.so.2 is set up
if [ ! -L /usr/lib/ld-linux.so.2 ]; then
EOF
       echo "  ln -svf ld-${glibcvers}.so /usr/lib/ld-linux.so.2" >> $Output
       cat >> $Output << "EOF"
fi
if ! $AS_ROOT; then chown -h glibc:glibc /usr/lib/ld-linux.so.2; fi
EOF
     fi
   ;;
   grub)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /etc/bash_completion.d
chmod g+w,o+t /etc/bash_completion.d
EOF
     fi
   ;;
   inetutils) # ping, etc setuid root
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown root /bin/ping*
chmod 4755 /bin/ping*
chown root /bin/traceroute
chmod 4755 /bin/traceroute
EOF
     else
       cat >> $Output << "EOF"
chown root ${PkgUserDir}/${PkgName}/usr/bin/ping*
chmod 4755 ${PkgUserDir}/${PkgName}/usr/bin/ping*
chown root ${PkgUserDir}/${PkgName}/usr/bin/traceroute
chmod 4755 ${PkgUserDir}/${PkgName}/usr/bin/traceroute
EOF
     fi
   ;;
#   iproute2)
#     if $useDESTDIR; then
#       cat >> $Output << "EOF"
#mkdir -pv ${PkgUserDir}/${PkgName}/usr/bin
#mv ${PkgUserDir}/${PkgName}/sbin/* ${PkgUserDir}/${PkgName}/usr/bin
#rm -rf ${PkgUserDir}/${PkgName}/sbin
#if ! $AS_ROOT; then
#  chown -R -h iproute2:iproute2 ${PkgUserDir}/${PkgName}/usr/bin
#fi
#EOF
#     fi
#   ;;
   kmod)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/bash-completion/completions
chmod g+w,o+t /usr/share/bash-completion/completions
EOF
     fi
   ;;
   libcap) # add libcap module to /etc/pam.d/system-auth 
     if [[ "$useDESTDIR" = true || "$single_package" = true ]]; then
       cat >> $Output << "EOF"
install -dm0755 ${PkgUserDir}/${PkgName}/etc/pam.d
cat > ${PkgUserDir}/${PkgName}/etc/pam.d/system-auth << "CAPEOF" &&
# Begin /etc/pam.d/system-auth
auth      required    pam_unix.so
# add libcap addition
auth      optional    pam_cap.so
# End /etc/pam.d/system-auth
CAPEOF
if ! $AS_ROOT; then chown linux-pam:linux-pam ${PkgUserDir}/${PkgName}/etc/pam.d/system-auth; fi
EOF
     fi
   ;;
   linux-headers)
     if [[ "$useDESTDIR" = true || "$single_package" = true ]]; then
       cat >> $Output << "EOF"
chgrp install ${PkgUserDir}/${PkgName}/usr/include/scsi
chmod g+w,o+t ${PkgUserDir}/${PkgName}/usr/include/scsi
EOF
     else
       cat >> $Output << "EOF"
chgrp install /usr/include/scsi
chmod g+w,o+t /usr/include/scsi
# linux-headers is not reinstalled so store the src tarfile in $PkgUserDir/$PkgName
# because the src tarfile in ${buildDir}/${FuncName} will get deleted eventually
EOF
     fi
     echo "if [ -e \${PkgUserDir}/\${PkgName}/linux-[0-9]*.tar.*z* ]; then
  echo \"kernel srcfile present in \${PkgUserDir}/\${PkgName}\"
elif [ -e ${chrootBuild}/${FuncName}/linux-[0-9]*.tar.*z* ]; then
  cp -v ${chrootBuild}/${FuncName}/linux-[0-9]*.tar.*z* \${PkgUserDir}/\${PkgName}
fi" >> $Output
   ;;
   man-db) #/es,it
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/man/it
chgrp install /usr/share/man/it/man*
chmod g+w,o+t /usr/share/man/it
chmod g+w,o+t /usr/share/man/it/man*
EOF
     fi
   ;;
   man-pages)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/man/{,man{1..8}}
chmod 1775 /usr/share/man/{,man{1..8}}
EOF
     else
       cat >> $Output << "EOF"
chgrp install ${PkgUserDir}/${PkgName}/usr/share/man/{,man{1..8}}
chmod 1775 ${PkgUserDir}/${PkgName}/usr/share/man/{,man{1..8}}
# these are included in coreutils
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man1/{chgrp,chmod,chown,cp,dir,dd}.1
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man1/{df,dircolors,du,install,ln,ls}.1
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man1/{mkdir,mkfifo,mknod,mv,rm,rmdir}.1
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man1/{touch,vdir}.1
# this is included in shadow
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man5/passwd.5
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man3/getspnam.3
# this is included in diffutils
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man1/diff.1
# this is included in xf86-input-mouse
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man4/mouse.4
# this is included in attr
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man5/attr.5
# this is included in tzdata
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man5/tzfile.5
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man8/{tzselect,zdump,zic}.8
EOF
     fi
   ;;
   meson)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
cat > /usr/bin/arch-meson << "MESONEOF"
EOF
     else
       cat >> $Output << "EOF"
cat > ${PkgUserDir}/${PkgName}/usr/bin/arch-meson << "MESONEOF"
EOF
     fi
     cat >> $Output << "EOF"
#!/bin/bash -ex
# Arch Linux Meson wrapper

exec meson setup \
  --prefix         /usr \
  --libdir         /usr/lib \
  --libexecdir     /usr/lib \
  --bindir         /usr/bin \
  --sbindir        /usr/bin \
  --includedir     /usr/include \
  --datadir        /usr/share \
  --mandir         /usr/share/man \
  --infodir        /usr/share/info \
  --localedir      /usr/share/locale \
  --sysconfdir     /etc \
  --localstatedir  /var \
  --sharedstatedir /var/lib \
  --wrap-mode      nodownload \
  -D               b_lto=true \
  -D               b_pie=true \
  "$@"
MESONEOF
EOF
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chmod 755 /usr/bin/arch-meson
if ! $AS_ROOT; then chown $PkgName:$PkgName /usr/bin/arch-meson; fi
chgrp install /usr/share/polkit-1
chgrp install /usr/share/polkit-1/actions
chmod g+w,o+t /usr/share/polkit-1
chmod g+w,o+t /usr/share/polkit-1/actions
EOF
     else
       cat >> $Output << "EOF"
chmod 755 ${PkgUserDir}/${PkgName}/usr/bin/arch-meson
if ! $AS_ROOT; then chown $PkgName:$PkgName ${PkgUserDir}/${PkgName}/usr/bin/arch-meson; fi
chgrp install ${PkgUserDir}/${PkgName}/usr/share/polkit-1
chgrp install ${PkgUserDir}/${PkgName}/usr/share/polkit-1/actions
chmod g+w,o+t ${PkgUserDir}/${PkgName}/usr/share/polkit-1
chmod g+w,o+t ${PkgUserDir}/${PkgName}/usr/share/polkit-1/actions
EOF
     fi
   ;;
   ncurses)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown 0:0 /etc/ld.so.cache
EOF
     fi
   ;;
   ninja)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/zsh/site-functions
chmod g+w,o+t /usr/share/zsh/site-functions
EOF
     fi
   ;;
   openssl)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /etc/ssl/{,certs}
chmod g+w,o+t /etc/ssl/{,certs}
EOF
     fi
   ;;
   perl)
     if ! $useDESTDIR; then
       echo "case \$(uname -m) in
   x86_64) archi=x86_64-linux-thread-multi
   ;;
   *)      archi=i686-linux-thread-multi
   ;;
esac
chgrp install /usr/lib/perl5/${perlseries}/{core_perl,site_perl}
chmod g+w,o+t /usr/lib/perl5/${perlseries}/{core_perl,site_perl}" >> $Output
     fi
   ;;
   pkg-config) #/usr/share/aclocal
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/aclocal
chmod g+w,o+t /usr/share/aclocal
chgrp install /usr/lib/pkgconfig
chmod g+w,o+t /usr/lib/pkgconfig
EOF
     fi
   ;;
   python3)
     if ! $useDESTDIR; then
       echo "chgrp install /usr/lib/python${pythonseries}/site-packages
chmod g+w,o+t /usr/lib/python${pythonseries}/site-packages" >> $Output
     fi
   ;;
   shadow)
     if [[ "$Chapter" != update && "$useDESTDIR" = false ]]; then # need pwconv and grpconv
       cat >> $Output << "EOF"
pwconv
grpconv
EOF
     fi
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown 0:shadow /etc/{group,group-,gshadow,gshadow-,passwd,passwd-,shadow,shadow-}
chmod 644 /etc/{group,group-,passwd,passwd-}
chmod 640 /etc/{gshadow,gshadow-,shadow,shadow-}
EOF
       if [ "$SYSTEMD" = yes ]; then
         echo "chown root /usr/bin/{chage,chfn,chsh,expiry,gpasswd,newgidmap,newgrp,newuidmap,passwd,su}
chmod 4755 /usr/bin/{chage,chfn,chsh,expiry,gpasswd,newgidmap,newgrp,newuidmap,passwd,su}" >> $Output
       else
         echo "chown root /bin/passwd
chmod 4755 /bin/passwd" >> $Output
       fi
     else # using DESTDIR
       cat >> $Output << "EOF"
chown root ${PkgUserDir}/${PkgName}/usr/bin/{chage,chfn,chsh,expiry,gpasswd,newgidmap,newgrp,newuidmap,passwd,su}
chmod 4755 ${PkgUserDir}/${PkgName}/usr/bin/{chage,chfn,chsh,expiry,gpasswd,newgidmap,newgrp,newuidmap,passwd,su}
mv ${PkgUserDir}/${PkgName}/usr/sbin/* ${PkgUserDir}/${PkgName}/usr/bin/
rm -rf ${PkgUserDir}/${PkgName}/usr/sbin
EOF
     fi
   ;;
   systemd)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/lib/udev/rules.d
chmod g+w,o+t /usr/lib/udev/rules.d
chgrp install /etc/udev/rules.d
chmod g+w,o+t /etc/udev/rules.d
chgrp install /usr/share/pkgconfig
chmod g+w,o+t /usr/share/pkgconfig
chgrp install /usr/share/polkit-1 # for polkit
chmod g+w,o+t /usr/share/polkit-1
chgrp install /usr/share/polkit-1/actions
chmod g+w,o+t /usr/share/polkit-1/actions
chgrp install /usr/share/dbus-1
chmod g+w,o+t /usr/share/dbus-1
chgrp install /etc/xdg # for at-spi2-core
chmod g+w,o+t /etc/xdg
chgrp install /usr/share/bash-completion/completions
chmod g+w,o+t /usr/share/bash-completion/completions
chgrp install /usr/lib/systemd/system
chmod g+w,o+t /usr/lib/systemd/system
chgrp install /usr/lib/systemd/system/sockets.target.wants # for dbus
chmod g+w,o+t /usr/lib/systemd/system/sockets.target.wants
chgrp install /usr/lib/systemd/system/multi-user.target.wants
chmod g+w,o+t /usr/lib/systemd/system/multi-user.target.wants
chgrp install /usr/lib/tmpfiles.d
chmod g+w,o+t /usr/lib/tmpfiles.d
chown root:systemd-journal /var/log/journal
chmod 2755 /var/log/journal
chown 0:0 /usr # had to change it to systemd to allow time update
systemctl preset-all
systemctl disable systemd-time-wait-sync.service
systemctl disable systemd-sysupdate
rm -fv /etc/sysctl.d/50-pid-max.conf
rm -fv /usr/lib/lib{blkid,uuid,mount}.so*
rm -fv /usr/lib/tmpfiles.d/systemd-nologin.conf
EOF
     else
       cat >> $Output << "EOF"
chown root:systemd-journal ${PkgUserDir}/${PkgName}/var/log/journal
chmod 2755 ${PkgUserDir}/${PkgName}/var/log/journal
if [ -f "${pkguserdir}/installFiles/${PkgName}/INSTALL" ]; then
  install -m644 ${pkguserdir}/installFiles/${PkgName}/INSTALL ${PkgUserDir}/${PkgName}/.INSTALL
  if ! $AS_ROOT; then chown systemd:systemd ${PkgUserDir}/${PkgName}/.INSTALL; fi
fi
EOF
     fi
   ;;
   sysvinit)
     cat >> $Output << "EOF"
rm -f /dev/initctl
mknod -m 600 /dev/initctl p
EOF
   ;;
   tcl) # if update, put man3/Thread.3 back to Perl
     if [ "$Chapter" = update ]; then
       if ! $useDESTDIR; then
         cat >> $Output << "EOF"
mv -v /usr/share/man/man3/{Thread_Perl,Thread}.3
if ! $AS_ROOT; then chown perl:perl /usr/share/man/man3/Thread.3; fi
EOF
       fi
     fi
   ;;
   util-linux) # mount setuid root
     if ! $useDESTDIR; then
       if [ "$currentChapter" = chapter07 ]; then
         if [ "$SYSTEMD" = yes ]; then
           cat >> $Output << "EOF"
chgrp install /usr/lib/systemd # for glibc
chmod g+w,o+t /usr/lib/systemd
chgrp install /usr/lib/systemd/system
chmod g+w,o+t /usr/lib/systemd/system
EOF
         fi
       elif [ "$currentChapter" = chapter08 ]; then
         cat >> $Output << "EOF"
chown root /bin/{mount,umount}
chmod 4755 /bin/{mount,umount}
chown root:tty /usr/bin/wall
chmod 2755 /usr/bin/wall
chgrp install /usr/share/bash-completion/completions
chmod g+w,o+t /usr/share/bash-completion/completions
chown root /usr/bin/su
chmod 4755 /usr/bin/su
EOF
         if [ "$SYSTEMD" = yes ]; then
           cat >> $Output << "EOF"
chgrp install /usr/lib/systemd # if dbus installed
chmod g+w,o+t /usr/lib/systemd
chgrp install /usr/lib/systemd/system
chmod g+w,o+t /usr/lib/systemd/system
chgrp install /usr/share/bash-completion/completions
chmod g+w,o+t /usr/share/bash-completion/completions
# do this here because libmount is now installed
systemd-machine-id-setup
chown systemd:systemd /etc/machine-id
EOF
         fi
       fi
     else # using DESTDIR
       cat >> $Output << "EOF"
chown root ${PkgUserDir}/${PkgName}/usr/bin/{mount,umount}
chmod 4755 ${PkgUserDir}/${PkgName}/usr/bin/{mount,umount}
chown root:tty ${PkgUserDir}/${PkgName}/usr/bin/wall
chmod 2755 ${PkgUserDir}/${PkgName}/usr/bin/wall
mv ${PkgUserDir}/${PkgName}/usr/sbin/* ${PkgUserDir}/${PkgName}/usr/bin/
rm -rf ${PkgUserDir}/${PkgName}/usr/sbin # rm symlink
EOF
     fi
   ;;
   vim)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/man/fr*
chgrp install /usr/share/man/it*
chgrp install /usr/share/man/it/man1
chgrp install /usr/share/man/ja
chgrp install /usr/share/man/pl*
chgrp install /usr/share/man/ru*
chmod g+w,o+t /usr/share/man/fr*
chmod g+w,o+t /usr/share/man/it*
chmod g+w,o+t /usr/share/man/it/man1
chmod g+w,o+t /usr/share/man/ja
chmod g+w,o+t /usr/share/man/pl*
chmod g+w,o+t /usr/share/man/ru*
EOF
     fi
   ;;
   xml-parser)
     if ! $useDESTDIR; then
echo "chgrp install /usr/lib/perl5/${perlseries}/site_perl/XML
chmod g+w,o+t /usr/lib/perl5/${perlseries}/site_perl/XML
chgrp install /usr/lib/perl5/${perlseries}/site_perl/auto
chmod g+w,o+t /usr/lib/perl5/${perlseries}/site_perl/auto
chgrp install /usr/lib/perl5/${perlseries}/site_perl/auto/XML
chmod g+w,o+t /usr/lib/perl5/${perlseries}/site_perl/auto/XML
chgrp install /usr/lib/perl5/${perlseries}/core_perl/perllocal.pod
chmod 664 /usr/lib/perl5/${perlseries}/core_perl/perllocal.pod" >> $Output
     fi
   ;;
esac
} # end setInstallDirs
#
Function () {
case $PkgName in
    changingowner)
        if [[ $as_root && "$Chapter" != update ]]; then
          WriteScript
          return
        fi
    ;;
    kernfs|chroot)
        if [ "$Chapter" != update ]; then
          WriteScript
          return
        fi
    ;;
esac
echo "${FuncName}_ () {" >> $Output
case $currentChapter in
   chapter05|chapter06|chapter07|chapter08|chapter10)
        case "$currentChapter" in
            chapter05|chapter06)
              echo "FuncName=$FuncName
PkgName=$PkgName" >> $Output
              if $as_root; then
                TestBuiltCh56
                echo "SrcName=$SrcName
starttime=\$( date +%s )" >> $Output
                cat >> $Output << "EOF"
# check env variables set correctly
echo "Running as $(whoami)"
if [ "$LFS" != /mnt/lfs ]; then
  echo "LFS is $LFS"
  echo "It should be /mnt/lfs"
  echo "Abort"
  exit 1
fi
if [ -z "$LFS_TGT" ]; then # not set. This will not work so abort
  echo "env variable LFS_TGT not set"
  echo "Aborting"
  exit 1
elif [ "$LFS_TGT" != x86_64-lfs-linux-gnu ]; then
  echo "LFS_TGT is not set to x86_64-lfs-linux-gnu"
  echo "It is set to $LFS_TGT"
  echo "check that this is what you intended, then modify this script"
  exit 1
fi
EOF
                echo "CreateBuildDir \$FuncName" >> $Output
# download any additional files
                case $FuncName in
                   gccpass1)
                     if [ "$SOURCES" = atinstall ]; then
                       echo "gmpvers=$gmpvers
mpcvers=$mpcvers
mpfrvers=$mpfrvers" >> $Output
                       cat >> $Output << "EOF"
# download the extra files
gmpFile="gmp-${gmpvers}.tar.xz"
mpcFile="mpc-${mpcvers}.tar.gz"
mpfrFile="mpfr-${mpfrvers}.tar.xz"
if [ -e ${CUR_DIR}/${gmpFile} ]; then
  echo "file $gmpFile already in $CUR_DIR, will use that"
else
  wget $wgetopts http://ftp.gnu.org/gnu/gmp/${gmpFile}
fi
if [ -e ${CUR_DIR}/${mpcFile} ]; then
  echo "file $mpcFile already in $CUR_DIR, will use that"
else
  wget $wgetopts https://ftp.gnu.org/gnu/mpc/${mpcFile}
fi
if [ -e ${CUR_DIR}/${mpfrFile} ]; then
  echo "file $mpfrFile already in $CUR_DIR, will use that"
else
  wget $wgetopts http://www.mpfr.org/mpfr-${mpfrvers}/${mpfrFile}
fi
EOF
                     else
                       cat >> $Output << "EOF"
unpack05 $SrcName
# in chapter5 and chapter6 gcc require unpacking mpfr, mpc and gmp
for i in mpfr gmp mpc
do
  ln -sfv ${LFS}${sourceloc}/${i}*.tar.*z* $CUR_DIR
done
EOF
                     fi
                   ;;
                   gccpass2)
                     if [ "$SOURCES" = atinstall ]; then
                       cat >> $Output << "EOF"
# copy the extra files from gccpass1
if [ -e ${CUR_DIR}/gmp*.tar.*z* ]; then
  echo "a gmp file is already in $CUR_DIR, will use that"
else
  cp -v ${LFS}/build/gccpass1/gmp*.tar.*z* .
fi
if [ -e ${CUR_DIR}/mpc*.tar.*z* ]; then
  echo "an mpc file is already in $CUR_DIR, will use that"
else
  cp -v ${LFS}/build/gccpass1/mpc*.tar.*z* .
fi
if [ -e ${CUR_DIR}/mpfr*.tar.*z* ]; then
  echo "an mpfr file is already in $CUR_DIR, will use that"
else
  cp -v ${LFS}/build/gccpass1/mpfr*.tar.*z* .
fi
EOF
                     else
                       cat >> $Output << "EOF"
unpack05 $SrcName
# in chapter5 and chapter6 gcc require unpacking mpfr, mpc and gmp
for i in mpfr gmp mpc
do
  ln -sfv ${LFS}${sourceloc}/${i}*.tar.*z* $CUR_DIR
done
EOF
                     fi
                   ;;
	           glibc)
                     if [ "$SOURCES" = atinstall ]; then
# download the patch
                       echo "glibcPatch=\"${glibcPatch}\"" >> $Output
                       cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${glibcPatch} ]; then
  echo "patch $glibcPatch already in $CUR_DIR, will use that"
else
  wget $wgetopts http://www.linuxfromscratch.org/patches/lfs/development/${glibcPatch}
fi
EOF
                     else
                       cat >> $Output << "EOF"
unpack05 $SrcName
EOF
                     fi
		   ;;
                   *)
                     echo "unpack05 \$SrcName" >> $Output
                   ;;
                esac
              else # as pkguser
                TestBuiltCh56
		echo "starttime=\$( date +%s )" >> $Output
	        uidVal=0
      	        gidVal=0
                if [ "$FuncName" = binutilspass1 ]; then # set initial value of 10000
  		  uidVal=10000 
		  gidVal=10000
		elif [ "$FuncName" = openssl ]; then # set the GID to 10055, the value in Ch8
                  uidVal=10055
                  gidVal=10055
                elif [ "$FuncName" = wget ]; then # set the GID to 10170, it is deleted at end of LFS
# because it is reinstalled in BLFS
                  uidVal=10170
                  gidVal=10170
	        fi
                echo "uidVal=$uidVal
gidVal=$gidVal" >> $Output
                cat >> $Output << "EOF"
createPkguser $uidVal $gidVal
chown -h -R $PkgName:$PkgName ${PkgUserDir}/${PkgName}
EOF
	        cat >> $Output << "EOF"
# create the install script
cat > ${LFS}/install${PkgName}.sh << "IPS"
EOF
                cat >> $Output << "EOF"
#!/bin/bash -e
#
if [ $UID -eq 0 ]; then 
  echo "Running as root."
EOF
                echo "  echo \"Please run this script as user $PkgName.\"" >> $Output
                cat >> $Output << "EOF"
  exit 1
fi
echo "Running as $(whoami)"
LFS=/mnt/lfs
PkgUserDir=${LFS}/usr/src/core
buildDir=${LFS}/build
BuildLog=${LFS}/LFS-build.log
sourcedir=${LFS}/sources
sourceloc=${sourcedir}/trunk
EOF
                case $SrcName in
		   libstdc++-)
		     SrcName=gcc-
		   ;;
      	           python-)
	    	     SrcName=Python-
		   ;;
                esac	 
                echo "Chapter=$currentChapter
AS_ROOT=$as_root
#" >> $Output
                cat >> $Output << "EOF"
unpack05 () {
# $1 is the source name
# $2 is the url to download the source file
# $3, if present, is the sourceloc of the file already downloaded
sourcelocOld=$sourceloc # sourceloc is global - store it to reset it at the end
local srcname=$1
local srcURL=$2
local altSourceloc=${3:-""}
if [ ! -z "$altSourceloc" ]; then # set sourceloc to this location
  sourceloc=$altSourceloc
fi
echo "sourceloc is $sourceloc"
starttime=$( date +%s )
if [ -e ${CUR_DIR}/${srcname}*.tar.*z* ]; then # src exists in current dir - use that
  echo "$srcname already in current dir - will use that one"
elif [ -e ${LFS}${sourceloc}/${srcname}*.tar.*z* ]; then # src exists so copy it to current dir
  cp -v ${LFS}${sourceloc}/${srcname}*.* . # copy any patches as well
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on the host
    wget $wgetopts $srcURL
  else
    echo "Install wget on the host to continue"
    echo "Aborting"
    exit 1
  fi
fi
cd $(tar vxf ${srcname}*z* | awk -F\/ 'END{print $1}')
curdir=$(echo $PWD)
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
sourceloc=$sourcelocOld
} # end unpack05
#
EOF
                case $FuncName in
                   make|tar|wget) # can't use any name that is a linux command
                     echo "${FuncName}Make () {
FuncName=$FuncName
PkgName=$PkgName
SrcName=$SrcName" >> $Output
                   ;;
                   *)
                     echo "${FuncName} () {
FuncName=$FuncName
PkgName=$PkgName
SrcName=$SrcName" >> $Output
                   ;;
                esac
                cat >> $Output << "EOF"
starttime=$( date +%s )
BuildDir=${buildDir}/${FuncName}
if [ ! -d $BuildDir ]; then mkdir -pv $BuildDir; fi
cd $BuildDir
CUR_DIR=$(echo $PWD) # will write logs to this dir
EOF
                case $FuncName in
                   gccpass1)
                     if [ "$SOURCES" = atinstall ]; then
                       echo "gmpvers=$gmpvers
mpcvers=$mpcvers
mpfrvers=$mpfrvers" >> $Output
                       cat >> $Output << "EOF"
# download the extra files
gmpFile="gmp-${gmpvers}.tar.xz"
mpcFile="mpc-${mpcvers}.tar.gz"
mpfrFile="mpfr-${mpfrvers}.tar.xz"
if [ -e ${CUR_DIR}/${gmpFile} ]; then
  echo "file $gmpFile already in $CUR_DIR, will use that"
else
  wget $wgetopts http://ftp.gnu.org/gnu/gmp/${gmpFile}
fi
if [ -e ${CUR_DIR}/${mpcFile} ]; then
  echo "file $mpcFile already in $CUR_DIR, will use that"
else
  wget $wgetopts https://ftp.gnu.org/gnu/mpc/${mpcFile}
fi
if [ -e ${CUR_DIR}/${mpfrFile} ]; then
  echo "file $mpfrFile already in $CUR_DIR, will use that"
else
  wget $wgetopts http://www.mpfr.org/mpfr-4.1.0/${mpfrFile}
fi
EOF
                     else
                       cat >> $Output << "EOF"
# in chapter5 and chapter6 gcc require unpacking mpfr, mpc and gmp
for i in mpfr gmp mpc
do
  ln -sfv ${LFS}${sourceloc}/${i}*.tar.*z* .
done
EOF
                     fi
                   ;;
                   gccpass2)
                     if [ "$SOURCES" = atinstall ]; then
                       cat >> $Output << "EOF"
# copy the extra files from gccpass1
if [ -e ${CUR_DIR}/gmp*.tar.*z* ]; then
  echo "a gmp file is already in $CUR_DIR, will use that"
else
  cp -v ${LFS}/build/gccpass1/gmp*.tar.*z* .
fi
if [ -e ${CUR_DIR}/mpc*.tar.*z* ]; then
  echo "an mpc file is already in $CUR_DIR, will use that"
else
  cp -v ${LFS}/build/gccpass1/mpc*.tar.*z* .
fi
if [ -e ${CUR_DIR}/mpfr*.tar.*z* ]; then
  echo "an mpfr file is already in $CUR_DIR, will use that"
else
  cp -v ${LFS}/build/gccpass1/mpfr*.tar.*z* .
fi
EOF
                     else
                       cat >> $Output << "EOF"
# in chapter5 and chapter6 gcc require unpacking mpfr, mpc and gmp
for i in mpfr gmp mpc
do
  ln -sfv ${LFS}${sourceloc}/${i}*.tar.*z* .
done
EOF
                     fi
                   ;;
                   glibc)
                     if [ "$SOURCES" = atinstall ]; then
# download the patch
                       echo "glibcPatch=\"${glibcPatch}\"" >> $Output
                       cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${glibcPatch} ]; then
  echo "patch $glibcPatch already in $CUR_DIR, will use that"
else
  wget $wgetopts http://www.linuxfromscratch.org/patches/lfs/development/${glibcPatch}
fi
EOF
                     fi
                   ;;
                esac
                case $FuncName in
                   wget) # special case for wget because it's not in LFS
                     srcURL="https://ftp.gnu.org/gnu/wget/wget-1.21.3.tar.gz"
                     useThisSrcLoc=""
                     echo "unpack05 \$SrcName \"$srcURL\" \"$useThisSrcLoc\"" >> $Output
                   ;;
                   *)
                     for srcURL in ${sourceURL[@]}; do # find the url for this src file
#echo "srcURL is $srcURL"
#echo "srcname is $SrcName"
                       serchstr="*$SrcName*"
                       useThisSrcLoc=""
                       case $FuncName in # modify some of the src file names to search for
                          binutilspass2)
                            useThisSrcLoc="/build/binutilspass1"
                          ;;
#                          gccpass2|gcclibstdc++pass1|libstdc++)
                          gccpass2|gcclibstdc++|libstdc++)
                            useThisSrcLoc="/build/gccpass1"
                          ;;
                          linuxheaders)
                            serchstr="*linux-[0-9]*"
                          ;;
                          make) # make not automake
                            serchstr="*/make-[0-9]*"
                          ;;
                       esac
                       case $srcURL in
                          $serchstr)
                            echo "unpack05 \$SrcName \"$srcURL\" \"$useThisSrcLoc\"" >> $Output
                            break
                          ;;
                       esac
                     done
		   ;;
		esac
                cat >> $Output << "EOF"
# source the environment variables in the home dir
EOF
echo ". \${PkgUserDir}/\${PkgName}/.bashrc" >> $Output
                cat >> $Output << "EOF"
# check some env variable values
if [ "$LFS" != /mnt/lfs ]; then
  echo "LFS is set to $LFS"
  echo "It should be /mnt/lfs"
  echo "Abort"
  exit 1
fi
if [ -z "$LFS_TGT" ]; then # not set. This will not work so abort
  echo "env variable LFS_TGT not set"
  echo "Aborting"
  exit 1
elif [ "$LFS_TGT" != x86_64-lfs-linux-gnu ]; then
  echo "LFS_TGT is not set to x86_64-lfs-linux-gnu"
  echo "It is set to $LFS_TGT"
  echo "check that this is what you intended, then modify this script"
  exit 1
fi
EOF
              fi
            ;;
            chapter07|chapter08|chapter10) # no revisedchroot since 03/22. Is now cleanup in Ch8
              case $PkgName in
                 chroot|cleanup|kernfs|creatingdirs|createfiles|stripping)
                   echo "FuncName=$FuncName" >> $Output
                   cat >> $Output << "EOF"
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName"
  return 0
else
  echo "In function $FuncName"
fi
EOF
                 ;;
	         *)
                   addPattern="" # extra bit to add to the cd line in unpack
	           case $PkgName in
                      glibc)
                        addPattern="*.tar"
                      ;;
		      kernel)
		        SrcName="linux-"
		      ;;
	              python)
		        PkgName=python3
		        SrcName="Python-"
		      ;;
                      python3) # case for Chapter=update, currentChapter=chapter08 and single package is python3
                        SrcName="Python-"
                        CmdName="Python"
                      ;;
                      systemd) # need the srcfile, not the man file
                        addPattern="[0-9]"
                      ;;
                      tcl)
                        addPattern="*-src"
                      ;;
                   esac
                   echo "PkgName=$PkgName" >> $Output
		   if [[ ("$useDESTDIR" = true && "$installDEST" = false) || "$single_package" = true ]]; then # uses DESTDIR
                     TestBuiltUpdtDest $Chapter
                   elif [[ "$Chapter" = update ]]; then
                     TestBuiltUpdate
                   else
		     TestBuiltCh78
                   fi
                   if ! $as_root; then
                     cat >> $Output << "EOF"
install -v -m0755 -d ${PkgUserDir}/${PkgName}
EOF
                     if [ "$Chapter" = update ]; then # clean the install directory
                       echo "cleanpkgdir \$PkgUserDir \$PkgName" >> $Output
                     fi
                     cat >> $Output << "EOF"
touch ${PkgUserDir}/${PkgName}/build
echo "#!/bin/bash" > ${PkgUserDir}/${PkgName}/build
cat >> ${PkgUserDir}/${PkgName}/build << "IPS"
set +h
EOF
                     echo "Chapter=$currentChapter
PkgName=\$LOGNAME
CUR_DIR=\$HOME" >> $Output
                     echo "SrcName=$SrcName
sourcedir=$sourcedir
sourceloc=$sourceloc
wgetopts=\"$wgetopts\"
ncc=\"$ncc\"
BuildLog="/$BuildLog"
#" >> $Output
                     if [ ! "$Chapter" = update ]; then
                       case $PkgName in
                          iproute2) # built with DESTDIR so add destdirInstall
                            destdirInstall
                          ;;
                       esac
                     fi
                     unpack >> $Output
		     getUrlSrcDnld "unpack" "$PkgUserDir" "$chrootBuild"
# download any additional files
                     dnldAddFiles
                   else # building as root
                     echo "CreateBuildDirasroot \$PkgName
SrcName=$SrcName" >> $Output
                     if [[ "$SOURCES" = download || "$SOURCES" = local ]]; then
                       case $PkgName in
                          glibc)
                            echo "unpack07 \$SrcName \"\" \"\" \"$addPattern\"" >> $Output
# get the tzdata file
                            cat >> $Output << "EOF"
if [ -e ${sourceloc}/tzdata*.tar.*z* ]; then
  cp -v ${sourceloc}/tzdata*.tar.*z* ..
else
  echo "*** No tzdata file found in $sourceloc ***"
  echo "Place it there in order to continue."
  exit 1
fi
EOF
                          ;;
                          systemd) # distinguish the srcfile from the manpage file
                            echo "unpack07 \$SrcName \"\" \"\" \"$addPattern\" true" >> $Output
                          ;;
                          *)
                            echo "unpack07 \$SrcName \"\" \"\" \"$addPattern\"" >> $Output
                          ;;
                       esac
                     elif [[ "$SOURCES" = atinstall ]]; then # get the srcURL and download any extra files
                       getUrlSrcDnld "unpack07" "$PkgUserDir" "$chrootBuild"
                       dnldAddFiles
                     fi
                   fi # end test building as root
                 ;;
              esac
          ;;
        esac
   ;;
esac # case currentChapter in
# add seds here to alter Makefiles
case $PkgName in
   man-pages)
     echo "sed -i '/install -d -m 755 \\\\\$(DESTDIR)\\\\\$(MANDIR)/d ' Makefile" >> $Output
   ;;
esac
WriteScript
closefunction
} # end of Function
closefunction () {
case "$currentChapter" in
    chapter05|chapter06)
       cat >> $Output << "EOF"
touch ${curdir}/../.${Chapter/apter/}${PkgName}
endtime=$( date +%s )
set +e
cd $curdir/..
rm -rf $curdir
elapsedtime=$( expr $endtime - $starttime )
set -e
EOF
       if $as_root; then
         cat >> $Output << "EOF"
echo "$FuncName $unpacktime $elapsedtime" >> ${LFS}${BuildLog}
EOF
echo "} # end $FuncName" >> $Output
       else
         cat >> $Output << "EOF"
echo "$FuncName $unpacktime $elapsedtime" >> ${BuildLog}
EOF
echo "} # end $FuncName" >> $Output
       fi
       if ! $as_root; then
         case $FuncName in
    	    make|tar|wget) # can't use any name that is a linux command  
              makeName="${FuncName}Make"
              echo "$makeName" >> $Output
	    ;;
            *)
              echo "$FuncName" >> $Output
            ;;
         esac	  
         cat >> $Output << "EOF"
IPS
chmod 755 "${LFS}/install${PkgName}.sh"
# run the script specified in .bash_profile
su - $PkgName -c "${LFS}/install${PkgName}.sh"
# set required dirs to be install dirs
EOF
#set required dirs to be install dirs
         case $FuncName in
            bash)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/lib/pkgconfig
chmod 1775 $LFS/usr/lib/pkgconfig
chgrp install $LFS/usr/share/doc
chmod 1775 $LFS/usr/share/doc
EOF
              fi
            ;;
            binutilspass1)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/tools/{bin,lib,share/{,info,man/{,man1}},x86_64-lfs-linux-gnu/{,bin,lib/{,ldscripts}}}
chmod 1775 $LFS/tools/{bin,lib,share/{,info,man/{,man1}},x86_64-lfs-linux-gnu/{,bin,lib/{,ldscripts}}}
EOF
              fi
            ;;
            coreutils)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/share/man/man8
chmod 1775 $LFS/usr/share/man/man8
EOF
              fi
	    ;;
            file)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/share/man/{man3,man4,man5}
chmod 1775 $LFS/usr/share/man/{man3,man4,man5}
EOF
              fi
            ;;
            gccpass1)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/tools/{include,lib,libexec}
chmod 1775 $LFS/tools/{include,lib,libexec}
EOF
              fi
	    ;;
            glibc)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/libexec
chmod 1775 $LFS/usr/libexec
chgrp install $LFS/usr/share/{,i18n,locale}
chmod 1775 $LFS/usr/share/{,i18n,locale}
rm -rf $LFS/usr/share/locale/* # don't need these in chapter 5 or 6
mkdir -pv $LFS/usr/share/info # for m4 in chap 6
chgrp install $LFS/usr/share/info
chmod 1775 $LFS/usr/share/info
chgrp install $LFS/var/lib
chmod 1775 $LFS/var/lib
# run this as root and set resulting files owned by gcc
LFS_TGT="x86_64-lfs-linux-gnu"
EOF
echo '$LFS/tools/libexec/gcc/$LFS_TGT/"'$gccvers'"/install-tools/mkheaders
chown gcc:gcc /mnt/lfs/tools/lib/gcc/$LFS_TGT/"'$gccvers'"/include-fixed/{limits.h,pthread.h,syslimits.h}' >> $Output
              fi
            ;;
            linuxheaders)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/include/{,scsi}
chmod 1775 $LFS/usr/include/{,scsi}
EOF
              fi
            ;;
            m4)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/share/man/{,man1}
chmod 1775 $LFS/usr/share/man/{,man1}
EOF
              fi
	    ;;
            ncurses)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/share/man/{man3,man5,man7}
chmod 1775 $LFS/usr/share/man/{man3,man5,man7}
EOF
              fi
            ;;
         esac
         cat >> $Output << "EOF"
# delete the install script
rm -v "${LFS}/install${PkgName}.sh"
EOF
         case $FuncName in
            wget) # add the /etc/resolv.conf file as root
              cat >> $Output << "EOF"
cat > ${LFS}/etc/resolv.conf << "RESOLVEOF"
nameserver 192.168.1.1
search mynet
RESOLVEOF
EOF
            ;;
         esac
         echo "} # end $FuncName" >> $Output
       fi
    ;;
    chapter07|chapter08) # no revisedchroot since (03/22). Now cleanup in Ch8
       case $PkgName in
           chroot|cleanup|kernfs|creatingdirs|createfiles|stripping)
               cat >> $Output << "EOF"
echo "${FuncName}" >> $BuildLog
}
EOF
           ;;
           *)
             case $PkgName in
                ncurses) # need the non-wide libs for chromium
                  cat >> $Output << "EOF"
echo "installing non-wide-character Ncurses libraries"
make distclean
non-wideconfigure_commands()
{ :
  ./configure --prefix=/usr    \
              --with-shared    \
              --without-normal \
              --without-debug  \
              --without-cxx-binding \
              --with-abi-version=5
}
non-widemake_commands()
{ :
  make sources libs
}
non-wideinstall_commands()
{ :
EOF
                  if [[ "$Chapter" = update && "$useDESTDIR" = true ]]; then
                    echo "cp -av lib/lib*.so.5* \"\${CUR_DIR}\"/usr/lib" >> $Output
                  else
                    echo "cp -av lib/lib*.so.5* /usr/lib" >> $Output
                  fi
                  cat >> $Output << "EOF"
}
echo -n non-wideConfigure...
{ non-wideconfigure_commands 3>&1 1>&2 2>&3 | tee "$CUR_DIR/non-wideconfigure.err" ;} &>"$CUR_DIR/non-wideconfigure.log"
test_pipe
echo -n non-wideCompile...
{ non-widemake_commands 3>&1 1>&2 2>&3 | tee "$CUR_DIR/non-widemake.err" ;} &>"$CUR_DIR/non-widemake.log"
test_pipe
echo -n non-wideInstall...
{ non-wideinstall_commands 3>&1 1>&2 2>&3 | tee "$CUR_DIR/non-wideinstall.err" ;} &>"$CUR_DIR/non-wideinstall.log"
test_pipe
EOF
                  if [[ "$Chapter" = update && "$useDESTDIR" = true ]]; then
                    echo "ln -sv libncurses.so.5.9 \"\${CUR_DIR}\"/usr/lib/libtinfo.so.5" >> $Output # this link is for chromium
                  else
                    echo "ln -sv libncurses.so.5.9 /usr/lib/libtinfo.so.5" >> $Output
                  fi
                ;;
                iproute2) # built with DESTDIR so install the package
                  if [ ! "$Chapter" = update ]; then # chapter08
                    echo "# install the package
set +e
destdirInstall \"\$CUR_DIR\"
set -e" >> $Output
                  fi
                ;;
             esac
             if ! $as_root; then
               if [ "$Chapter" = update ]; then
                 if $useDESTDIR; then
                   cat >> $Output << "EOF"
testBuilt=".update${PkgName}-destdir"
touch ~/${testBuilt}
endtime=$( date +%s )
set +e
EOF
                 else # not destdir
                   cat >> $Output << "EOF"
testBuilt=".update${PkgName}"
touch ~/${testBuilt}
endtime=$( date +%s )
set +e
EOF
                 fi
               else
                 if $useDESTDIR; then
                   cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}-destdir"
touch ~/${testBuilt}
endtime=$( date +%s )
set +e
EOF
                 else # not destdir
                   cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}"
touch ~/${testBuilt}
endtime=$( date +%s )
set +e
EOF
                 fi
               fi
             else # as root
                cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}"
touch ${PkgUserDir}/${PkgName}/${testBuilt}
endtime=$( date +%s )
set +e
EOF
             fi # as root test
             delSrcFile >> $Output
             if [ "$PkgName" = glibc ]; then #also delete glibc-build
               echo "rm -rf glibc-build" >> $Output
             elif [ "$PkgName" = binutils ]; then #also delete binutils-build
               echo "rm -rf binutils-build" >> $Output
             elif [ "$PkgName" = gcc ]; then #also delete gcc-build
               echo "rm -rf gcc-build" >> $Output
             fi
             cat >> $Output << "EOF"
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "$PkgName $unpacktime $elapsedtime" >> $BuildLog
EOF
             if ! $as_root; then
               echo "IPS" >> $Output
               setuplinks # setup any preprocessing commands
               if [[ ! -z "$otherPrePro" || ! -z "$doFirst" || ! -z "$links" ]]; then resolvelinks; fi # not null
               case $PkgName in
                  openssl)
                    cat >> $Output << "EOF"
if [ "$(grep -q ^$PkgName\: /etc/passwd;echo $?)" != 0 ]; then
  installpkg $PkgName "core" 10055
fi
EOF
                  ;;
                  wheel)
                    cat >> $Output << "EOF"
if [ "$(grep -q ^$PkgName\: /etc/passwd;echo $?)" != 0 ]; then
  installpkg $PkgName "core" 97
fi
EOF
                  ;;
                  *)
                    cat >> $Output << "EOF"
if [ "$(grep -q ^$PkgName\: /etc/passwd;echo $?)" != 0 ]; then
  installpkg $PkgName
fi
EOF
               esac
	       if [[ ! -z "$otherPrePro" || ! -z "$doFirst" || ! -z "$links" ]]; then # preprocessing
cat >> $Output << "EOF"
resolvelinks
EOF
               fi
	       cat >> $Output << "EOF"
chmod 755 ${PkgUserDir}/${PkgName}/build
# make sure .bash_profile and .bashrc are symlinks to /etc/pkgusr
setUserEnv $PkgUserDir $PkgName
su $PkgName -c "source ${PkgUserDir}/${PkgName}/.bash_profile"
EOF
               if [ "$Chapter" = update ]; then
                 if $useDESTDIR; then
                   cat >> $Output << "EOF"
if [ ! -e ${PkgUserDir}/${PkgName}/.update${PkgName}-destdir ]; then
  echo "update $PkgName using DESTDIR failed"
  exit 1
fi
EOF
                 else # not destdir
                   cat >> $Output << "EOF"
if [ ! -e ${PkgUserDir}/${PkgName}/.update${PkgName} ]; then
  echo "update $PkgName failed"
  exit 1
fi
EOF
                 fi
               else
                 if $useDESTDIR; then
                   cat >> $Output << "EOF"
if [ ! -e ${PkgUserDir}/${PkgName}/.${PkgName}-destdir ]; then
  echo "$PkgName using DESTDIR failed"
  exit 1
fi
EOF
                 else # not destdir
                   cat >> $Output << "EOF"
if [ ! -e ${PkgUserDir}/${PkgName}/.${PkgName} ]; then
  echo "$PkgName failed"
  exit 1
fi
EOF
                 fi
               fi
               echo "chown \$PkgName:\$PkgName \${PkgUserDir}/\${PkgName}/$build" >> $Output
               case $PkgName in
                  linux-headers|man-pages) # do not ldconfig - not installed until glibc
                    :
                  ;;
                  *)
                    if ! $useDESTDIR; then
                      cat >> $Output << "EOF"
if [ -e "/etc/ld.so.cache~" ]; then # make sure owner is root
  chown 0 /etc/ld.so.cache~
fi
ldconfig
EOF
                    fi
                  ;;
               esac
# set required dirs to be install dirs
               setInstallDirs $PkgName
               if $useDESTDIR; then
                 case $PkgName in
                    linux-headers)
                        if [ -z "$linuxvers" ]; then # get the linux version no.
                          GetLinuxVersion $SourceDir
                        fi 
                        echo "createPkgfile \$PkgUserDir \$PkgName $linuxvers" >> $Output
                    ;;
                    libelf)
                        echo "createPkgfile \$PkgUserDir \$PkgName \"0.187\"" >> $Output
                    ;;
                    *)
                        echo "createPkgfile \$PkgUserDir \$PkgName" >> $Output
                    ;;
                 esac
               fi
               echo "} # end $FuncName" >> $Output
             else # as root
               case $PkgName in
                  meson)
                    cat >> $Output << "EOF"
cat > /usr/bin/arch-meson << "MESONEOF"
#!/bin/bash -ex
# Arch Linux Meson wrapper

exec meson setup \
  --prefix         /usr \
  --libdir         /usr/lib \
  --libexecdir     /usr/lib \
  --bindir         /usr/bin \
  --sbindir        /usr/bin \
  --includedir     /usr/include \
  --datadir        /usr/share \
  --mandir         /usr/share/man \
  --infodir        /usr/share/info \
  --localedir      /usr/share/locale \
  --sysconfdir     /etc \
  --localstatedir  /var \
  --sharedstatedir /var/lib \
  --buildtype      plain \
  --warnlevel      2 \
  --auto-features  enabled \
  --wrap-mode      nodownload \
  -D               b_lto=true \
  "$@"
MESONEOF
chmod 755 /usr/bin/arch-meson
EOF
                  ;;
               esac
               echo "} # end $FuncName" >> $Output
             fi # end of as_root test
         ;; #name loop
       esac
    ;; # close chapter07/08 loop
    chapter10)
      if ! $as_root; then
        if $useDESTDIR; then
          if [ "$Chapter" = update ]; then
            cat >> $Output << "EOF"
testBuilt=".update${PkgName}-destdir"
touch ~/${testBuilt}
EOF
          else
            cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}-destdir"
touch ~/${testBuilt}
EOF
          fi
        elif [ "$Chapter" = update ]; then # not destdir
          cat >> $Output << "EOF"
testBuilt=".update${PkgName}"
touch ~/${testBuilt}
EOF
        else
          cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}"
touch ~/${testBuilt}
EOF
        fi
        cat >> $Output << "EOF"
endtime=$( date +%s )
set +e
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "$PkgName $unpacktime $elapsedtime" >> $BuildLog
EOF
        echo "IPS" >> $Output
        setuplinks # setup any preprocessing commands
        if [[ ! -z "$otherPrePro" || ! -z "$doFirst" || ! -z "$links" ]]; then resolvelinks; fi # not null
        cat >> $Output << "EOF"
if [ "$(grep -q ^$PkgName\: /etc/passwd;echo $?)" != 0 ]; then
  installpkg $PkgName
fi
EOF
        if [[ ! -z "$otherPrePro" || ! -z "$doFirst" || ! -z "$links" ]]; then # preprocessing
cat >> $Output << "EOF"
resolvelinks
EOF
        fi
        echo "if ! \$AS_ROOT; then chown \$PkgName:\$PkgName \${PkgUserDir}/\${PkgName}/build; fi
chmod 755 \${PkgUserDir}/\${PkgName}/build
# make sure .bash_profile and .bashrc are symlinks to /etc/pkgusr
setUserEnv \$PkgUserDir \$PkgName
su \$PkgName -c \"source \${PkgUserDir}/\${PkgName}/.bash_profile\"" >> $Output
        if $useDESTDIR; then
          if [ "$Chapter" = chapter10 ]; then
            cat >> $Output << "EOF"
if [ ! -e ${PkgUserDir}/${PkgName}/.${Chapter/apter/}${PkgName}-destdir ]; then
  echo "$PkgName using DESTDIR failed"
  exit 1
fi
ldconfig
EOF
          elif [ "$Chapter" = update ]; then
            cat >> $Output << "EOF"
testBuilt=".update${PkgName}-destdir"
if [ ! -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
  echo "$PkgName failed"
  exit 1
fi
ldconfig
EOF
          else
             cat >> $Output << "EOF"
if [ ! -e ${PkgUserDir}/${PkgName}/.${PkgName}-destdir ]; then
  echo "$PkgName using DESTDIR failed"
  exit 1
fi
ldconfig
EOF
          fi
        elif [ "$Chapter" = update ]; then # not destdir
          cat >> $Output << "EOF"
testBuilt=".update${PkgName}"
if [ ! -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
  echo "$PkgName failed"
  exit 1
fi
ldconfig
EOF
        else
          cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}"
if [ ! -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
  echo "$PkgName failed"
  exit 1
fi
ldconfig
EOF
        fi
        if [ "$Chapter" != update ]; then
          if [ "$useDESTDIR" = false ]; then
            if [ "$SYSTEMD" = yes ]; then
              cat >> $Output << "EOF"
rm -v ${PkgUserDir}/{dbus/build,systemd/build,libcap/build,shadow/build} # in prep for blfs
if [ -e ${PkgUserDir}/libcap/.libcap ]; then
  rm -v ${PkgUserDir}/libcap/.libcap
fi
if [ -e ${PkgUserDir}/shadow/.shadow ]; then
  rm -v ${PkgUserDir}/shadow/.shadow
fi
EOF
            else # SYSTEMD is no
               cat >> $Output << "EOF"
rm -v ${PkgUserDir}/{eudev/build,libcap/build,shadow/build} # in prep for blfs
if [ -e ${PkgUserDir}/libcap/.libcap ]; then
  rm -v ${PkgUserDir}/libcap/.libcap
fi
if [ -e ${PkgUserDir}/shadow/.shadow ]; then
  rm -v ${PkgUserDir}/shadow/.shadow
fi
EOF
            fi # test SYSTEMD
          fi # test useDESTDIR
        else # Chapter is update so clean out the files in /boot if not useDESTDIR
          if [ "$useDESTDIR" = false ]; then
            cat >> $Output << "EOF"
# clean the /boot dir 
rm -v /boot/{config-*,System.map-*,vmlinuz-*}
EOF
          fi # test useDESTDIR
        fi # test Chapter != update
      else # as root
# TODO account for Chapter=update when user is root
         if $useDESTDIR; then
echo "touch \${PkgUserDir}/\${PkgName}/.\${PkgName}-destdir" >> $Output
         else
echo "touch \${PkgUserDir}/\${PkgName}/.\${PkgName}" >> $Output
         fi
         cat >> $Output << "EOF"
endtime=$( date +%s )
set +e
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "$PkgName $unpacktime $elapsedtime" >> $BuildLog
EOF
         cat >> $Output << "EOF"
rm -rf ${PkgUserDir}/{dbus/build,systemd/build,libcap/build,shadow/build} # in prep for blfs
if [ -e ${PkgUserDir}/libcap/.libcap ]; then
  rm ${PkgUserDir}/libcap/.libcap
fi
if [ -e ${PkgUserDir}/shadow/.shadow ]; then
  rm ${PkgUserDir}/shadow/.shadow
fi
EOF
      fi # end as_root test
#
      if [ "$MAKE_KERNEL" = yes ]; then
# write out the cp commands
        IFS='
' # set to CRLF
        kerneldir="\${PkgUserDir}/\${PkgName}/linux-"
        rtrnCom=""
        CmdName=kernel
        getComms $currentChapter
        for line in ${rtrnCom[@]}; do
          case $line in
             *bzImage*) # cp the bzImage
                    lineNoCP=${line#"cp -iv "} # remove the cp -iv 
                    if $useDESTDIR; then
                      echo "mkdir -pv \${PkgUserDir}/\${PkgName}/boot" >> $Output
                      echo "kernLatestVers=$kernLatestVers" >> $Output
                      linout=$(echo "cp -iv ${kerneldir}\${kernLatestVers}/${lineNoCP}" | sed -e 's/\/boot\/vmlinuz/${PkgUserDir}\/${PkgName}\/boot\/vmlinuz/')
                    else
                      echo "kernLatestVers=$kernLatestVers" >> $Output
                      linout=$(echo "cp -iv ${kerneldir}\${kernLatestVers}/${lineNoCP}")
                    fi
                    if [ ! -z "$kernLatestVers" ]; then
                      echo $linout | sed -e 's/'"$linuxcomvers"'/'"$kernLatestVers"'/' >> $Output
                    else
                      echo $linout >> $Output
                    fi
              ;;
              "cp -iv"*) # cp the System.map and the .config file
                    lineNoCP=${line#"cp -iv "}
                    if $useDESTDIR; then
                      linout=$(echo "cp -iv ${kerneldir}\${kernLatestVers}/${lineNoCP}" | sed -e 's/\/boot/${PkgUserDir}\/${PkgName}\/boot/')
                    else
                      linout=$(echo "cp -iv ${kerneldir}\${kernLatestVers}/${lineNoCP}")
                    fi
                    if [ ! -z "$kernLatestVers" ]; then
                      echo $linout | sed -e 's/'"$linuxcomvers"'/'"$kernLatestVers"'/' \
                      >> $Output
                    else
                      echo $linout >> $Output
                    fi
              ;;
          esac
        done
	echo "# finally change the name of the vmlinuz file" >> $Output
        if $useDESTDIR; then
          echo "if [ -e \${PkgUserDir}/\${PkgName}/boot/vmlinuz-\${kernLatestVers}-lfs-* ]; then
  mv -v \${PkgUserDir}/\${PkgName}/boot/vmlinuz-\$kernLatestVers-lfs-* \${PkgUserDir}/\${PkgName}/boot/vmlinuz-\$kernLatestVers-lfs
fi " >> $Output
        else
          echo "if [ -e /boot/vmlinuz-$linuxvers-lfs-* ]; then
  mv -v /boot/vmlinuz-$linuxvers-lfs-* /boot/vmlinuz-$linuxvers-lfs
fi " >> $Output
        fi
# only want the following code if Chapter is not update
        if [ "$Chapter" != update ]; then
          rtrnCom=""
          CmdName=theend
          getComms "chapter11"
          for line in ${rtrnCom[@]}; do
            case $line in
              DISTRIB_CODENAME*|VERSION_CODENAME*)
                echo $line | sed -e 's@<your name here>@LFS@' >> $Output
              ;;
              *"/etc/lfs-release"*|*"/etc/lsb-release"*|*"/etc/os-release"*)
                if $useDESTDIR; then echo $line | sed -e 's|/etc/lfs-release|${PkgUserDir}/${PkgName}/etc/lfs-release|' \
                                                      -e 's|/etc/lsb-release|${PkgUserDir}/${PkgName}/etc/lsb-release|' \
                                                      -e 's|/etc/os-release|${PkgUserDir}/${PkgName}/etc/os-release|' \
                                     >> $Output
                else
                  echo $line >> $Output
                fi
              ;;
              *)
                echo $line >> $Output
              ;;
            esac
          done
          if $useDESTDIR; then
            cat >> $Output << "EOF"
if ! $AS_ROOT; then chown $PkgName:$PkgName ${PkgUserDir}/${PkgName}/etc/{lfs-release,lsb-release,os-release}; fi
EOF
            echo "createPkgfile \$PkgUserDir \$PkgName $linuxvers" >> $Output
          else
            cat >> $Output << "EOF"
if ! $AS_ROOT; then chown $PkgName:$PkgName /etc/{lfs-release,lsb-release,os-release}
# delete files owned by wget  in Chapter06
/usr/bin/listdelpkg.sh 10170 10170 delete
rm -rf /usr/src/core/wget
# delete the build dir from Ch. 5 and 6
rm -rf /build
# change owner of /usr/share/locale/en_GB and rw installed by wget
chown bash:bash /usr/share/locale/{en_GB,rw}
chown bash:install /usr/share/locale/{rw/LC_MESSAGES,en_GB/LC_MESSAGES}
EOF
          fi
	fi # end Chapter not update
      fi # end MAKE_KERNEL
      echo "}" >> $Output
    ;;
esac
} #end closefunction
#
setuplinks () { # setup preprocessing
# links sets the owner of the file to the pkguser
# doFirst sets the given dir(s) to group install and sticky
# otherPrePro is anything else to do before install package
#
links=""
doFirst=""
otherPrePro=""
case $PkgName in
    gcc)
        if ! $useDESTDIR; then
          links="/usr/lib/libstdc++.{a,la} /usr/lib/libgcc_s.so{,.1} /usr/lib/libstdc++.so{,.6} /usr/lib/gcc"
        fi
    ;;
    glibc)
        if ! $useDESTDIR; then
          otherPrePro="if [ -d /lib64 ]; then chgrp install /lib64 && chmod 1775 /lib64; fi"
        fi
        if [ "$WHICH_CHAPTER" = update ]; then # /info/dir is owned by root
          links="/usr/share/info/dir"
        fi
    ;;
    bash)
        if ! $useDESTDIR; then
          links="/bin/bash /bin/sh"
        fi
    ;;
    coreutils)
        if ! $useDESTDIR; then
          links="/bin/{cat,chmod,dd,echo,env,false,install,ln,mkdir,printf,pwd,rm,stty,touch} /etc/group"
        fi
    ;;
    flex)
        if ! $useDESTDIR; then
          otherPrePro="if [ -L /usr/bin/lex ]; then rm /usr/bin/lex; fi"
          links="/usr/lib/libfl.so.2.0.0"
        fi
    ;;
    gettext)
        if ! $useDESTDIR; then
          doFirst="/usr/share/man/*"
        fi
    ;;
    inetutils)
        if ! $useDESTDIR; then
          links="/usr/bin/{dnsdomainname,hostname,ping,ping6,traceroute} /usr/share/man/man1/{dnsdomainname.1,hostname.1}"
        fi
    ;;
    jinja2)
        if ! $useDESTDIR; then
          otherPrePro="chgrp install /usr/lib/python3.10/site-packages/easy-install.pth && chmod 664 /usr/lib/python3.10/site-packages/easy-install.pth"
        fi
    ;;
    kmod)
        if ! $useDESTDIR; then
          doFirst="/usr/share/bash-completion/completions"
        fi
    ;;
    kernel) # install /lib/firmware dir
        if [ "$Chapter" != update ]; then
          otherPrePro="mkdir -pv /usr/lib/firmware"
          doFirst="/usr/lib/firmware"
        fi
    ;;
    man-pages) # in update mode, need to own some man pages
        if [ "$WHICH_CHAPTER" = update ]; then
          if ! $useDESTDIR; then
            otherPrePro="chown man-pages:man-pages /usr/share/man/man{1..8}" 
            links="/usr/share/man/{man3/getspnam.3,man5/{attr.5,passwd.5}} "
          fi
        else
          if ! $useDESTDIR; then
            doFirst="/usr/share/man/{man2,man6}"
          fi
        fi
    ;;
    ncurses)
        if ! $useDESTDIR; then
          links="/etc/ld.so.cache /usr/lib/libncurses.so"
        fi
    ;;
    openssl)
        if ! $useDESTDIR; then
          links="/usr/lib/libcrypto.so* /usr/include/openssl/aes.h"
        fi
    ;;
    perl)
        if ! $useDESTDIR; then
          links="/usr/bin/perl"
        fi
    ;;
    shadow)
        if ! $useDESTDIR; then
          links="/usr/share/man/man{5/passwd.5,3/getspnam.3} /etc/{passwd,shadow,group,gshadow}{,-} /usr/bin/{chage,chfn,chsh,expiry,gpasswd,groupadd,newgidmap,newgrp,newuidmap,passwd,su,useradd}"
        fi
    ;;
    sysklogd)
        if ! $useDESTDIR; then
          links="/usr/share/man/man8/sysklogd.8"
        fi
    ;;
    systemd)
        if ! $useDESTDIR; then
          otherPrePro="if [ \"\$(grep -q ^systemd-journal\: /etc/group;echo \$?)\" != 0 ]; then
  groupadd -g 23 systemd-journal
fi"
          links="/usr"
        fi
    ;;
    eudev)
        if ! $useDESTDIR; then
          links="/lib/{firmware,udev,udev/devices,udev/devices/pts}"
        fi
    ;;
    tcl) # if update, need to mv man3/Thread.3 out the way cos it's owned by Perl
        if [ "$WHICH_CHAPTER" = update ]; then
          if ! $useDESTDIR; then
            otherPrePro="mv -v /usr/share/man/man3/{Thread,Thread_Perl}.3"
          fi
        fi
    ;;
    util-linux)
        if [ "$WHICH_CHAPTER" = update ]; then
          if ! $useDESTDIR; then
            links="/usr/bin/{mount,su,umount,wall} /usr/share/man/man1/su.1"
          fi
        else
          otherPrePro="rm -rf /usr/{lib/{libmount.a,libuuid.a,libblkid.a,pkgconfig/{blkid,fdisk,mount,uuid}.pc},include/{blkid,libfdisk,libmount,uuid}}"
          links="/usr/lib/lib{blkid,fdisk,mount,uuid}.so* /usr/bin/{mount,umount,wall}"
        fi
    ;;
    vim)
        if ! $useDESTDIR; then
          links="/usr/share/vim/vim80/syntax/ninja.vim"
        fi
    ;;
    xz)
        if ! $useDESTDIR; then
          otherPrePro="rm -rf /usr/lib/liblzma.a"
          links="/usr/lib/liblzma.*"
        fi
    ;;
    zlib)
        if ! $useDESTDIR; then
          doFirst="/usr/lib/pkgconfig"
        fi
    ;;
    *)
        doFirst=""
        links=""
        otherPrePro=""
    ;;
esac
} # end setuplinks
#
resolvelinks () {
# At the beginning of chapter 6 there are symlinks that point to the tools dir
# These are owned by root so need to change owner to the package user
echo "resolvelinks () {" >> $Output
if [ ! -z "$otherPrePro" ];then echo "$otherPrePro" >> $Output; fi
if [ ! -z "$doFirst" ]; then
echo "for doDir in $doFirst; do
 if [ -d "\$doDir" ]; then
   chgrp install \$doDir # set to install group
   chmod 1775 \$doDir # set sticky bit
 fi
done" >> $Output
fi
if [ ! -z "$links" ]; then
echo "for link in $links; do
  if [ -e "\$link" -o -L "\$link" ]; then
    chown -h \$PkgName:\$PkgName \$link # change owner to package user so can overwrite
  fi
done" >> $Output
fi
echo "return 0
} # end resolvelinks" >> $Output
} #end resolvelinks
#
CreateBuildDir () {
# only used in chapter 5 and 6
cat >> $Output << "EOF"
CreateBuildDir () {
BuildDir=${buildDir}/${1}
if [ ! -e $BuildDir ]; then install -d $BuildDir; fi
cd $BuildDir
CUR_DIR=$(echo $PWD)
}
EOF
} #end CreateBuildDir
#
CreateBuildDirasroot () {
cat >> $Output << "EOF"
CreateBuildDirasroot () {
# $1 is the package name, PkgName
BuildDirasroot=${PkgUserDir}/${1}
if [ ! -e $BuildDirasroot ]; then install -d -m755 $BuildDirasroot; fi
cd $BuildDirasroot
CUR_DIR=$(echo $PWD)
} # end CreateBuildDirasroot
EOF
} # end CreateBuildDirasroot
#
unpack05 () {
cat >> $Output << "EOF"
unpack05 () {
# $1 is the source name
# $2, if present, is the url to download the source file
# $3, if present, is the sourceloc of the file already downloaded
sourcelocOld=$sourceloc # sourceloc is global - store it to reset it at the end
local srcname=$1
local srcURL=${2:-""}
local altSourceloc=${3:-""}
if [ ! -z "$altSourceloc" ]; then # set sourceloc to this location
  sourceloc=$altSourceloc
fi
echo "sourceloc is $sourceloc"
starttime=$( date +%s )
if [ -e ${CUR_DIR}/${srcname}*.tar.*z* ]; then # src exists in current dir - use that
  echo "$srcname already in current dir - will use that one"
elif [ -e ${LFS}${sourceloc}/${srcname}*.tar.*z* ]; then # src exists so copy it to current dir
  cp -v ${LFS}${sourceloc}/${srcname}*.* . # copy any patches as well
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on the host
    if [ ! -z "$srcURL" ]; then
      wget $wgetopts $srcURL
    else
      echo "No srcURL given. You need to download the source file"
      echo "Aborting"
      exit 1
    fi
  else
    echo "Install wget on the host to continue"
    echo "Aborting"
    exit 1
  fi
fi
cd $(tar vxf ${srcname}*z* | awk -F\/ 'END{print $1}')
curdir=$(echo $PWD)
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
sourceloc=$sourcelocOld
}
EOF
} #end unpack05
#
unpack07 () {
# used when installing as root for chapter07, 8 and 10
cat >> $Output << "EOF"
unpack07 () {
# $1 is the source name
# $2, if present, is the url to download the source file
# $3, if present, is the sourceloc of the file already downloaded
# $4, if present, is the pattern to add to the cd line to untar the correct file
# $5, if true, add this pattern to the tests
sourcelocOld=$sourceloc # sourceloc is global - store it to reset it at the end
local srcname=$1
local srcURL=${2:-""}
local altSourceloc=${3:-""}
local pattern=${4:-""}
local tstPat="${5:-false}"
if [ ! -z "$altSourceloc" ]; then # set sourceloc to this location
  sourceloc=$altSourceloc
fi
echo "sourceloc is $sourceloc"
addPat=""
if $tstPat; then addPat=$pattern; fi
starttime=$( date +%s )
if [ -e ${CUR_DIR}/${srcname}${addPat}*.tar.*z* ]; then # src exists in current dir - use that
  echo "$srcname already in current dir - will use that one"
elif [ -e ${sourceloc}/${srcname}${addPat}*.tar.*z* ]; then # src exists so copy it to current dir
  cp -v ${sourceloc}/${srcname}*.* . # copy any patches as well
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on the target machine
    if [ ! -z "$srcURL" ]; then
      wget $wgetopts $ncc $srcURL
    else
      echo "No srcURL given. You need to download the source file"
      echo "Aborting"
      exit 1
    fi
  else
    echo "/usr/bin/wget not present on the target machine"
    echo "Install it in order to continue"
    echo "Aborting"
    exit 1
  fi
fi
cd $(tar vxf ${srcname}${pattern}*z* | awk -F\/ 'END{print $1}')
curdir=$(echo $PWD)
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
sourceloc=$sourcelocOld
} # end unpack07
#
EOF
}
# the unpack used in update
unpack () {
     cat << "EOF"
unpack () {
# $1 is the source name
# $2 is the url to download the source file
# $3, if present, is the sourceloc of the file already downloaded
sourcelocOld=$sourceloc # sourceloc is global - store it to reset it at the end
local srcname=$1
local srcURL=$2
local altSourceloc=${3:-""}
if [ ! -z "$altSourceloc" ]; then # set sourceloc to this location
  sourceloc=$altSourceloc
fi
echo "sourceloc is $sourceloc"
local srcFile=${srcURL##*/}
echo "srcFile to install is $srcFile"
# is this file already in $CUR_DIR
starttime=$( date +%s )
EOF
   case $SrcName in
      systemd-) # distinguish from the man-pages file
        cat << "EOF"
if [ -e ${CUR_DIR}/${srcname}[0-9]*.tar.*z* ]; then # a srcfile exists in current dir - use that
  echo "$srcname already in current dir - will use that one"
elif [ -e ${sourceloc}/${srcname}[0-9]*.tar.*z* ]; then # src exists so copy it to current dir
EOF
      ;;
      tcl8.) # need to specify -src to distinguish from the html file
        cat << "EOF"
if [ -e ${CUR_DIR}/${srcname}*-src.tar.*z* ]; then # a srcfile exists in current dir - use that
  echo "$srcname already in current dir - will use that one"
elif [ -e ${sourceloc}/${srcname}*-src.tar.*z* ]; then # src exists so copy it to current dir
EOF
      ;;
      *)
        cat << "EOF"
if [ -e ${CUR_DIR}/${srcname}*.tar.*z* ]; then # a srcfile exists in current dir - use that
  echo "$srcname already in current dir - will use that one"
elif [ -e ${sourceloc}/${srcname}*.tar.*z* ]; then # src exists so copy it to current dir
EOF
      ;;
   esac
   if [[ "$Chapter" = update && "$PkgName" = "linux-headers" ]]; then # the linux src dir is open
     echo "    cp -v \${sourceloc}/\${srcname}*.tar.*z* ." >> $Output
   else
     echo "    cp -v \${sourceloc}/\${srcname}*.* . # copy any patches as well" >> $Output
   fi
   cat << "EOF"
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on the target machine
    wget $wgetopts $ncc $srcURL
  else
    echo "Install wget on the target machine in order to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
     case $SrcName in
        systemd-) # distinguish from the man-pages file
          cat << "EOF"
cd $(tar vxf ${srcname}[0-9]*.tar.*z* | awk -F\/ 'END{print $1}')
EOF
        ;;
        tcl8.) # need to specify -src to distinguish from the html file
          cat << "EOF"
cd $(tar vxf ${srcname}*-src.tar.*z* | awk -F\/ 'END{print $1}')
EOF
        ;;
        *)
          cat << "EOF"
cd $(tar vxf ${srcname}*z* | awk -F\/ 'END{print $1}')
EOF
        ;;
     esac
     cat << "EOF"
curdir=$( echo $PWD ) #store the source dir for later deletion
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
sourceloc=$sourcelocOld
} # end unpack
EOF
# if need the package version for the script, print it here
case $SrcName in
   bzip2-)
     echo "bzip2Vers=$bzip2vers" >> $Output
   ;;
   gcc-)
     echo "gccVers=$gccvers" >> $Output
   ;;
esac
} # end unpack
#
TestBuiltCh56 () {
    cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}"
if [ -e ${buildDir}/${FuncName}/${testBuilt} ]; then
  echo "skipping $FuncName"
  return 0
  echo "Building $FuncName"
fi
EOF
} #end TestBuiltCh56
#
TestBuiltCh78 () {
    cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}"
if [ -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
  echo "skipping $PkgName"
  return 0
else
  echo "Building $PkgName"
fi
EOF
} # end TestBuiltCh78
#
TestBuiltUpdtDest () {
# a single package uses DESTDIR, so test $PkgName-destdir
# if present, $1 is the chapter which is used to test if built already
local chapter=${1:-""}
if [ ! -z "$chapter" ]; then
  local testBuilt=".${chapter/apter/}${PkgName}-destdir"
else
  local testBuilt=".${PkgName}-destdir"
fi
echo "testBuilt=\"$testBuilt\"" >> $Output
    cat >> $Output << "EOF"
if [ -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
  echo "skipping $PkgName"
  return 0
else
  echo "Building $PkgName"
fi
EOF
} # end TestBuiltUpdtDest
#
TestBuiltUpdate () {
    cat >> $Output << "EOF"
testBuilt=".${PkgName}-update"
if [ -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
  echo "Updated $PkgName"
  return 0
else
  echo "Updating $PkgName"
fi
EOF
} # end TestBuiltUpdate
#
destdirInstall () {
cat >> $Output << "EOF"
destdirInstall () {
# install the files from a DESTDIR build
# $1 is the directory containing the files to install
local pkgfileDir=$1
local eachDir=""
pushd $pkgfileDir > /dev/null
local listDIRS=$(ls -l --time-style="long-iso" . | grep '^d' | awk '{print $8}')
echo "directories are $listDIRS"
for eachDir in $listDIRS; do
  if [[ $eachDir != etc && $eachDir != lib && $eachDir != usr && $eachDir != var && $eachDir != opt && $eachDir != run && $eachDir != srv && $eachDir != sbin ]]; then
  echo "Install files from directory $eachDir? [y/N]"
    read reply
      case $reply in
         [yY]|[yY][Ee][Ss])
            echo "okay continuing"
         ;;
         [nN]|[nN][Oo])
            echo "Okay, ignoring directory $eachDir"
            continue
         ;;
         *)
            echo "Okay, ignoring directory $eachDir"
            continue
         ;;
      esac
  fi
  echo "installing files in $eachDir"
# take account of symlinks /bin /lib /sbin
  if [ -L "/$eachDir" ]; then # for /bin and /lib it's /usr/$eachDir. For /sbin, /usr/sbin is also a symlink
    echo "dir $eachDir is a symlink"
    if [ "$eachDir" = sbin ]; then # use /usr/bin, not /usr/sbin
      cp -a $eachDir/* /usr/bin
    else
      cp -a $eachDir/* /usr/${eachDir}
    fi
  elif [ "$eachDir" = usr ]; then # deal with symlink usr/sbin if it exists
    pushd usr > /dev/null
    local usrDIRS=$(ls -l --time-style="long-iso" . | grep '^d' | awk '{print $8}')
    echo "directories under usr are $usrDIRS"
    for eachusrDir in $usrDIRS; do
      if [ "$eachusrDir" = sbin ]; then # deal with the /usr/sbin symlink
        cp -a $eachusrDir/* /usr/bin
      elif [ "$eachusrDir" = libexec ]; then # use /usr/lib instead of /usr/libexec
        cp -a $eachusrDir/* /usr/lib
      elif [ "$eachusrDir" = man ]; then
        cp -a $eachusrDir/* /usr/share/man
      elif [ "$eachusrDir" = usr ]; then
        cp -a $eachusrDir/share/man/* /usr/share/man
      else
        cp -a $eachusrDir /usr
      fi
    done
    popd > /dev/null
  elif [ "$eachDir" = var ]; then # deal with symlink /var/run if it exists
    pushd var > /dev/null
    local varDIRS=$(ls -l --time-style="long-iso" . | grep '^d' | awk '{print $8}')
    echo "directories under var are $varDIRS"
    for eachvarDir in $varDIRS; do
      if [ "$eachvarDir" = run ]; then # deal with the /var/run symlink
        cp -a $eachvarDir/* /run
      else
        cp -a $eachvarDir /var
      fi
    done
    popd > /dev/null
  else
    cp -a $eachDir /
  fi
  echo "Delete dir $eachDir? [Y/n]"
  read reply
    case $reply in
         [yY]|[yY][Ee][Ss])
            echo "okay deleting $eachDir"
            rm -rf $eachDir
         ;;
         [nN]|[nN][Oo])
            echo "okay leaving $eachDir in place"
         ;;
         *)
            echo "okay deleting $eachDir"
            rm -rf $eachDir
         ;;
    esac
done
popd > /dev/null
} # end destdirInstall
#
EOF
} # end destdirInstall
#
WriteScript () {
case $PkgName in
    acl)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/make install install-dev/make DIST_ROOT="$CUR_DIR" install install-dev/' \
                 -e 's/chmod -v 755 \/usr\/lib\/libacl.so/chmod -v 755 ${CUR_DIR}\/usr\/lib\/libacl.so/' \
                 -e '/mv -v/,/ln -sfv/d' \
           >> $Output
        else
          GetCommands \
           | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
                 -e '/prefix=\/usr/a\              --libdir=\/usr\/lib \\' \
                 -e '/mv -v/,/ln -sfv/d' \
           >> $Output
        fi
    ;;
    attr)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/make install install-dev/make DIST_ROOT="$CUR_DIR" install install-dev/' \
                 -e '/chmod -v 755 \/usr\/lib\/libattr.so/i rm -f ${CUR_DIR}\/usr\/lib\/libattr.a' \
                 -e 's/chmod -v 755 \/usr\/lib\/libattr.so/chmod -v 755 ${CUR_DIR}\/usr\/lib\/libattr.so/' \
                 -e '/mv -v/,/ln -sfv/d' \
           >> $Output 
        else
          if [ "$SYSTEMD" = yes -a "$isSystemdBook" = false ]; then
            GetCommands \
             | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
                   -e '/prefix=\/usr/a\              --libdir=\/usr\/lib \\' \
                   -e '/mv -v/,/ln -sfv/d' \
             >> $Output
          else # book is systemd
            GetCommands \
             | sed -e 's/disable-static/disable-static --bindir=\/usr\/bin --libdir=\/usr\/lib/' \
                   -e '/mv -v/,/ln -sfv/d' \
             >> $Output
          fi
        fi
    ;;
    bash)
        if [ "$currentChapter" = chapter06 ]; then
	  GetCommands \
	   | sed -e '/mv $LFS\/usr\/bin\/bash/d' \
	         -e 's/bin\/sh/usr\/bin\/sh/' \
	   >> $Output
	else # chapter08
          if [ "$SYSTEMD" = yes ]; then 
            if $useDESTDIR; then 
              GetCommands \
              | sed -e '/docdir=\/usr\/share\/doc/i\              --bindir=\/usr\/bin            \\' \
                    -e '/chown -Rv tester/,/exit/d' \
                    -e '/EOF/d' \
                    -e '/exec \/usr\/bin\/bash/i ln -s bash ${CUR_DIR}\/usr\/bin\/sh' \
                    -e '/exec \/usr\/bin\/bash --login/d' \
              >> $Output
            else
              GetCommands \
              | sed -e '/docdir=\/usr\/share\/doc/i\              --bindir=\/usr\/bin            \\' \
                    -e '/chown -Rv tester/,/exit/d' \
                    -e '/EOF/d' \
                    -e '/exec \/usr\/bin\/bash/i rm -rf \/usr\/bin\/sh\n\ln -s bash \/usr\/bin\/sh' \
                    -e '/exec \/usr\/bin\/bash --login/d' \
              >> $Output
            fi
          else
            GetCommands \
            | sed -e '/chown -Rv tester/,/exit/d' \
                  -e '/EOF/d' \
            >> $Output
          fi
	fi
    ;;
    bc)
       GetCommands \
        | sed -e '/echo "quit"/d' \
        >> $Output
    ;;
    binutils)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/expect -c/d' \
                 -e 's/make tooldir=\/usr install/make prefix="${CUR_DIR}"\/usr tooldir="${CUR_DIR}"\/usr install/' \
                 -e '/rm -fv \/usr\/lib/i\install -m644 libiberty\/pic\/libiberty.a "${CUR_DIR}\/usr\/lib"' \
                 -e '/rm -fv \/usr\/lib/i\rm -fv "${CUR_DIR}"\/usr\/share\/man\/man1\/{dlltool,windres,windmc}*' \
                 -e 's/rm -fv \/usr\/lib\/lib{bfd/rm -fv ${CUR_DIR}\/usr\/lib\/lib{bfd/' \
           | awk '{
if ($1 == "mkdir" && $2 =="-v")
  print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
  print $0;
}' \
           >> $Output
        else
          GetCommands \
           | sed -e '/expect -c/d' \
           | awk '{
if ($1 == "mkdir" && $2 =="-v")
  print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
  print $0;
}' \
           >> $Output
        fi
    ;;
    bzip2) # ch6 only
        if [ "$Chapter" != update ]; then
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e '/make PREFIX=\/usr/i\  make bzip2 bzip2recover' \
                   -e 's/cp -v bzip2-shared \/bin\/bzip2/cp -v bzip2-shared \/usr\/bin\/bzip2/' \
                   -e 's/cp -av libbz2.so\* \/lib/cp -av libbz2.so\* \/usr\/lib/' \
                   -e '/ln -sv ..\/..\/lib/d' \
                   -e '/rm -v/i ln -sv libbz2.so.1.0 /usr/lib/libbz2.so' \
                   -e 's/bunzip2,bzcat,bzip2/bunzip2,bzcat/' \
                   -e 's/\/bin\/bunzip2/\/usr\/bin\/bunzip2/' \
                   -e 's/\/bin\/bzcat/\/usr\/bin\/bzcat/' \
             >> $Output
          else
            GetCommands \
             | sed -e "/patch/i sed -e 's\/^CFLAGS=\\\(.\*\\\)\$\/CFLAGS=\\\1 \\\\\$(BIGFILES)\/' -i ./Makefile-libbz2_so" \
                   -e '/make PREFIX=\/usr/i\  make bzip2 bzip2recover' \
             >> $Output
          fi
        else # update
          if $useDESTDIR; then
            GetCommands \
             | sed -e "/patch/i sed -e 's\/^CFLAGS=\\\(.\*\\\)\$\/CFLAGS=\\\1 \\\\\$(BIGFILES)\/' -i ./Makefile-libbz2_so" \
                   -e '/make PREFIX=\/usr/i\  make bzip2 bzip2recover' \
                   -e 's/make PREFIX=\/usr install/make PREFIX=${CUR_DIR}\/usr install/' \
                   -e 's/cp -av libbz2.so.\* \/usr/cp -av libbz2.so.\* ${CUR_DIR}\/usr/' \
                   -e 's/libbz2.so.'"${bzip2vers}"' \/usr/libbz2.so.${bzip2Vers} ${CUR_DIR}\/usr/' \
                   -e 's/cp -v bzip2-shared \/usr/cp -v bzip2-shared ${CUR_DIR}\/usr/' \
                   -e 's/for i in \/usr/for i in ${CUR_DIR}\/usr/' \
                   -e 's/rm -fv \/usr\/lib\/libbz2.a/rm -fv ${CUR_DIR}\/usr\/lib\/libbz2.a/' \
             >> $Output
          else
            GetCommands \
             | sed -e "/patch/i sed -e 's\/^CFLAGS=\\\(.\*\\\)\$\/CFLAGS=\\\1 \\\\\$(BIGFILES)\/' -i ./Makefile-libbz2_so" \
                   -e '/make PREFIX=\/usr/i\  make bzip2 bzip2recover' \
                   -e '/ln -sv libbz2.so/i rm -v \/usr\/lib\/libbz2.so' \
                   -e '/ln -sfv bzip2/i\  rm -v \$i' \
             >> $Output
          fi
        fi
    ;;
    changingowner) # add this if running as root
	if $as_root; then
          GetCommands \
           | sed -e 's/usr,lib,var,etc,bin,sbin,tools/build,"LFS-build.log",etc,var,tools,usr/' \
            >> $Output; fi
    ;;
    check)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/ install/ DESTDIR="$CUR_DIR" install/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    cleanup) # chapter07
        if [ "$currentChapter" = chapter07 ]; then
          GetCommands \
           | sed -e '/rm -rf \/tools/,/tar -cJpf/d' \
                 -e 's/\(.*\)&&$/\1/' \
           >> $Output
        elif [ "$currentChapter" = chapter08 ]; then
          GetCommands \
           | sed -e '/rm -rf \/tmp\/\*/a echo "copy'\''n'\''paste the following:\n' \
                 -e "/find \/usr\/lib \/usr\/libexec/i logout\n\"\necho \"chroot \\\\\"\\\\\$LFS\\\\\" \/usr\/bin\/env -i          \\\\\\\\\"\necho \"    HOME=\/root TERM=\\\\\"\\\\\$TERM\\\\\"            \\\\\\\\\"\necho \"    PS1='(lfs chroot) \\\u:\\\w\\\\\\\\$ '        \\\\\\\\\"\necho \"    PATH=\/usr\/bin:\/usr\/sbin            \\\\\\\\\"\necho \"    \/bin\/bash --login\"\n" \
                 -e '/find \/usr -depth/aecho "*** do not delete the \/tools dir, needed for chapter10 ***"' \
                 -e '/rm -rf \/tools/d' \
                 -e 's/^/echo "/' \
                 -e 's/\$/\\$/g' \
                 -e 's/\\$/\\\\/' \
                 -e 's/$/"/' \
           >> $Output
          cat >> $Output << "EOF"
echo "
#
# Install chapter 9 and then su kernel to install the kernel.
# Don't forget:
# 1. set a root password
# 2. check for broken symlinks with: find /usr/lib -xtype l
EOF
echo "#\"" >> $Output
        fi
    ;;
    coreutils)
	if [ "$currentChapter" = chapter06 ]; then
	  GetCommands \
	   | sed -e '/mv -v $LFS\/usr\/bin\/chroot/d' \
	   >> $Output
	else # chapter08
          if $useDESTDIR; then
            if [ "$SYSTEMD" = yes ]; then
              GetCommands \
               | sed -e 's/uptime/uptime \\\n\              --libexecdir=\/usr\/lib/' \
                     -e "/make NON_ROOT_USERNAME=nobody/,/sed -i '\/dummy\/d' \/etc\/group/d" \
                     -e '/mv -v \/usr\/bin\/chroot \/usr\/sbin/d' \
                     -e '/mv -v \/usr\/bin\/{head/d' \
                     -e '/chroot.1/i mkdir -pv ${CUR_DIR}\/usr\/share\/man\/man8' \
                     -e 's/\/usr\/share\/man/${CUR_DIR}\/usr\/share\/man/g' \
               >> $Output
            else
              GetCommands \
               | sed -e "/make NON_ROOT_USERNAME=nobody/,/sed -i '\/dummy\/d' \/etc\/group/d" \
                     -e '/mv -v \/usr\/bin\/chroot \/usr\/sbin/d' \
                     -e 's/\/usr\/bin\//${CUR_DIR}\/usr\/bin\//g' \
                     -e '/chroot.1/i mkdir -pv ${CUR_DIR}\/usr\/share\/man\/man8' \
                     -e 's/\/usr\/share\/man/${CUR_DIR}\/usr\/share\/man/g' \
               >> $Output
            fi
          else # not useDESTDIR
            if [ "$SYSTEMD" = yes ]; then
              GetCommands \
               | sed -e 's/uptime/uptime \\\n\              --libexecdir=\/usr\/lib/' \
                     -e "/make NON_ROOT_USERNAME=nobody/,/sed -i '\/dummy\/d' \/etc\/group/d" \
                     -e '/mv -v \/usr\/bin\/chroot \/usr\/sbin/d' \
               >> $Output
            else
              GetCommands \
               | sed -e "/make NON_ROOT_USERNAME=nobody/,/sed -i '\/dummy\/d' \/etc\/group/d" \
                     -e '/mv -v \/usr\/bin\/chroot \/usr\/sbin/d' \
               >> $Output
            fi
          fi
	fi
    ;;
    createfiles)
        if ! $as_root; then 
          GetCommands \
           | sed -e '/mounts \/etc\/mtab/iif [ ! -L \/etc\/mtab ]; then' \
                 -e '/mounts \/etc\/mtab/afi' \
                 -e '/nobody/ibinutils:x:10000:10000::/mnt/lfs/usr/src/core/binutils:/bin/bash\ngcc:x:10001:10001::/mnt/lfs/usr/src/core/gcc:/bin/bash\nlinux-headers:x:10002:10002::/mnt/lfs/usr/src/core/linux-headers:/bin/bash\nglibc:x:10003:10003::/mnt/lfs/usr/src/core/glibc:/bin/bash\nm4:x:10004:10004::/mnt/lfs/usr/src/core/m4:/bin/bash\nncurses:x:10005:10005::/mnt/lfs/usr/src/core/ncurses:/bin/bash\nbash:x:10006:10006::/mnt/lfs/usr/src/core/bash:/bin/bash\ncoreutils:x:10007:10007::/mnt/lfs/usr/src/core/coreutils:/bin/bash\ndiffutils:x:10008:10008::/mnt/lfs/usr/src/core/diffutils:/bin/bash\nfile:x:10009:10009::/mnt/lfs/usr/src/core/file:/bin/bash\nfindutils:x:10010:10010::/mnt/lfs/usr/src/core/findutils:/bin/bash\ngawk:x:10011:10011::/mnt/lfs/usr/src/core/gawk:/bin/bash\ngrep:x:10012:10012::/mnt/lfs/usr/src/core/grep:/bin/bash\ngzip:x:10013:10013::/mnt/lfs/usr/src/core/gzip:/bin/bash\nmake:x:10014:10014::/mnt/lfs/usr/src/core/make:/bin/bash\npatch:x:10015:10015::/mnt/lfs/usr/src/core/patch:/bin/bash\nsed:x:10016:10016::/mnt/lfs/usr/src/core/sed:/bin/bash\ntar:x:10017:10017::/mnt/lfs/usr/src/core/tar:/bin/bash\nxz:x:10018:10018::/mnt/lfs/usr/src/core/xz:/bin/bash' \
                 -e '/nogroup/iinstall:x:9999:binutils,gcc,linux-headers,glibc,m4,ncurses,bash,coreutils,diffutils,file,findutils,gawk,grep,gzip,make,patch,sed,tar,xz\nbinutils:x:10000:\ngcc:x:10001:\nlinux-headers:x:10002:\nglibc:x:10003:\nm4:x:10004:\nncurses:x:10005:\nbash:x:10006:\ncoreutils:x:10007:\ndiffutils:x:10008:\nfile:x:10009:\nfindutils:x:10010:\ngawk:x:10011:\ngrep:x:10012:\ngzip:x:10013:\nmake:x:10014:\npatch:x:10015:\nsed:x:10016:\ntar:x:10017:\nxz:x:10018:' \
                 -e '/wheel/d' \
		 -e 's/nobody:x:99:99/nobody:x:65534:65534/' \
                 -e 's/nogroup:x:99/nogroup:x:65534/' \
                 -e '/tester/d' \
                 -e '/exec \/usr\/bin\/bash --login/d' \
                 -e "/600  \/var\/log\/btmp/ased -i 's/\\\/mnt\\\/lfs//' /etc/passwd" \
             >> $Output
        else # as root 
          GetCommands \
           | sed -e '/mounts \/etc\/mtab/iif [ ! -L \/etc\/mtab ]; then' \
                 -e '/mounts \/etc\/mtab/afi' \
                 -e '/exec \/usr\/bin\/bash --login/d' \
           >> $Output
        fi
    ;;
    creatingdirs)
        if [ "$SYSTEMD" = yes ]; then # symlink /bin, /lib and /sbin to /usr...
          GetCommands \
           | sed -e 's/pv \/lib\/firmware/pv \/usr\/lib\/firmware/' \
                 -e 's/bin,include,lib,sbin,src/bin,include,lib,src/' \
                 -e 's/cache,local,log/cache,local\/{,la-files},log/' \
           >> $Output
        else
          GetCommands \
           | sed -e 's/cache,local,log/cache,local\/{,la-files},log/' \
           >> $Output
        fi
    ;;
    dbus)
        if $useDESTDIR; then
          GetInternalCommands dbusComms \
           | sed -e 's/\/var\/lib\/dbus/${CUR_DIR}\/var\/lib\/dbus/' \
           >> $Output
        else
          GetInternalCommands dbusComms >> $Output
        fi
    ;;
    e2fsprogs)
        if $useDESTDIR; then
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/mkdir -v build/mkdir -v e2fsprogs-build/' \
                   -e 's/cd       build/cd e2fsprogs-build/' \
                   -e '/configure --prefix=\/usr/a\              --sysconfdir=/etc \\' \
                   -e '/enable-elf-shlibs/i\               --libdir=\/usr\/lib       \\\n\               --sbindir=\/usr\/bin      \\' \
                   -e 's/rm -fv \/usr\/lib\/{libcom_err/rm -fv "${CUR_DIR}"\/usr\/lib\/{libcom_err/' \
                   -e 's/\/usr\/share\/info/${CUR_DIR}\/usr\/share\/info/g' \
                   -e '/makeinfo -o      doc/,/install-info --dir-file=\/usr/d' \
             >> $Output
          else
            GetCommands \
             | sed -e 's/mkdir -v build/mkdir -v e2fsprogs-build/' \
                   -e 's/cd       build/cd e2fsprogs-build/' \
                   -e 's/rm -fv \/usr\/lib\/{libcom_err/rm -fv "${CUR_DIR}"\/usr\/lib\/{libcom_err/' \
                   -e 's/\/usr\/share\/info/${CUR_DIR}\/usr\/share\/info/' \
                   -e '/makeinfo -o      doc/,/install-info --dir-file=\/usr/d' \
             >> $Output
           fi
        else
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/mkdir -v build/mkdir -v e2fsprogs-build/' \
                   -e 's/cd       build/cd e2fsprogs-build/' \
                   -e '/configure --prefix=\/usr/a\               --sysconfdir=/etc        \\' \
                   -e '/enable-elf-shlibs/i\               --libdir=\/usr\/lib       \\\n\               --sbindir=\/usr\/bin      \\' \
             >> $Output
          else
            GetCommands \
             | sed -e 's/mkdir -v build/mkdir -v e2fsprogs-build/' \
                   -e 's/cd       build/cd e2fsprogs-build/' \
             >> $Output
           fi
        fi
    ;;
    eudev)
        GetCommands \
         | sed -e '/make LD_LIBRARY_PATH=\/tools\/lib check/d' \
         >> $Output
    ;;
    expect)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/\.so \/usr\/lib/\.so "${CUR_DIR}"\/usr\/lib/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    file) # in chapter06 and 08 don't need to mv libmagic
        GetCommands \
         | sed -e '/libmagic.so/d' \
         >> $Output
    ;;
    findutils)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/locate/locate --libexecdir=\/usr\/lib\/findutils/' \
                 -e '/mv -v/,/sed -i/d' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    flex)
        if [ "$Chapter" = update ]; then # don't re-create /usr/bin/lex
          if $useDESTDIR; then
            GetCommands \
             | sed -e 's/ln -sv flex \/usr/ln -sv flex ${CUR_DIR}\/usr/' \
             >> $Output
          else
            GetCommands \
             | sed -e '/ln -s flex/d' \
             >> $Output
          fi
        else
          GetCommands >> $Output
        fi
    ;;
    gawk)
	if [ "$currentChapter" = chapter08 ]; then
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/prefix=\/usr/prefix=\/usr \\\n\              --libexecdir=\/usr\/lib \\\n\              --sysconfdir=\/etc \\\n\              --localstatedir=\/var/' \
             >> $Output
          else
            GetCommands >> $Output
          fi
	else
	  GetCommands >> $Output
	fi
    ;;
    gcc)
	if [ "FuncName" = libstdc++ ]; then
          GetCommands \
           | awk '{
if ($1 == "mkdir" && $2 =="-v")
  print "if [ ! -e "$NF" ]; then\n  "$0"\nfi\n";
else
  print $0;
}' \
           >> $Output
	else # gcc not libstdc++
          if [ "$Chapter" != update ]; then
            if [ "$SYSTEMD" = yes ]; then
              if $useDESTDIR; then
                GetCommands \
                 | sed -e 's/with-system-zlib/with-system-zlib       \\\n\              --libdir=\/usr\/lib \\\n\              --libexecdir=\/usr\/lib/' \
                       -e '/make install/a\  mv ${CUR_DIR}\/usr\/lib64\/\* ${CUR_DIR}\/usr\/lib\n\  rm -rf ${CUR_DIR}\/usr\/lib64' \
                       -e 's/ln -sv ..\/usr\/bin\/cpp \/lib/ln -sv ..\/bin\/cpp ${CUR_DIR}\/usr\/lib/' \
                       -e "/ln -sv gcc/ a set +e" \
                       -e 's/ln -sv gcc \/usr\/bin\/cc/ln -sv gcc ${CUR_DIR}\/usr\/bin\/cc/' \
                       -e 's/install -v -dm755 \/usr\/lib\/bfd-plugins/install -v -dm755 ${CUR_DIR}\/usr\/lib\/bfd-plugins/' \
                       -e "/echo 'main(){}' > dummy.c/,/rm -v dummy.c a.out dummy.log/d" \
                       -e 's/..\/..\/libexec/../' \
                       -e 's/so \/usr\/lib\/bfd-plugins/so ${CUR_DIR}\/usr\/lib\/bfd-plugins/' \
                       -e 's/\/usr\/share\/gdb\/auto-load/${CUR_DIR}\/usr\/share\/gdb\/auto-load/' \
                       -e 's/\/usr\/lib\/\*gdb.py/${CUR_DIR}\/usr\/lib\/libstdc++.so.6.0.21-gdb.py/' \
                 | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0;
}' \
                >> $Output
              else # not DESTDIR
                if [ "$currentChapter" = chapter05 ]; then 
                  GetCommands \
                   | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0;
}' \
                   >> $Output
                else # chapter 6 and 8
                  GetCommands \
                   | sed -e 's/--prefix=\/usr/--prefix=\/usr \\\n\               --libdir=\/usr\/lib \\\n\               --libexecdir=\/usr\/lib/' \
                         -e '/chown -v -R root:root/,/\/usr\/lib\/gcc\/\$(gcc/d' \
                         -e 's|/../libexec||' \
                   | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0;
}' \
                   >> $Output
                fi # test Chapter = update
              fi # test useDESTDIR
            else # SYSTEMD is no
              GetCommands \
               | sed -e "/ln -sv gcc/ a set +e" \
               | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0;
}' \
               >> $Output
            fi
          else # Chapter is update
            if $useDESTDIR; then
              GetInternalCommands gccDestdirComms >> $Output
            else
              GetInternalCommands gccComms >> $Output
            fi
          fi
	fi # end test of gcc or libstdc
        echo "set -e" >> $Output
    ;;
    gettext)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/chmod -v 0755 \/usr\/lib\/preloadable/chmod -v 0755 "${CUR_DIR}"\/usr\/lib\/preloadable/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    glibc)
        if [ "$Chapter" != update ]; then
          if [ "$currentChapter" = chapter08 ]; then
# set up glibc's timezone
# test if the build dir exists
# if SYSTEMD=yes, but the book is not systemd, then need to add the nscd systemd files
            if [ "$SYSTEMD" = yes -a "$isSystemdBook" = false ]; then
              GetCommands \
               | sed -e 's/prefix=\/usr/prefix=\/usr --libexecdir=\/usr\/lib/' \
                     -e '/mkdir -pv \/usr\/lib\/locale/i install -v -Dm644 ..\/nscd\/nscd.tmpfiles \/usr\/lib\/tmpfiles.d\/nscd.conf\ninstall -v -Dm644 ..\/nscd\/nscd.service \/usr\/lib\/systemd\/system\/nscd.service' \
                     -e '/tzselect/d' \
                     -e 's/zic/\/usr\/sbin\/zic/' \
                     -e 's[\*\*EDITME<xxx>EDITME\*\*['$TZ'[' \
               | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0
}' \
               | awk '{if ($1 == "mkdir" && $NF =="/etc/ld.so.conf.d")
print "if [ ! -e "$NF" ]; then\n  "$1" -v "$NF"\nfi";
else
print $0
}' \
               >> $Output
            else
              GetCommands \
               | sed -e 's/prefix=\/usr/prefix=\/usr --libexecdir=\/usr\/lib/' \
	             -e 's/libc_cv_slibdir=\/lib/libc_cv_slibdir=\/usr\/lib/' \
		     -e 's/ld-linux.so.2        \/lib/ld-linux.so.2        \/usr\/lib/' \
		     -e 's/ld-linux-x86-64.so.2 \/lib/ld-linux-x86-64.so.2 \/usr\/lib/' \
		     -e 's/service \/lib\/systemd\/system/service \/usr\/lib\/systemd\/system/' \
                     -e '/tzselect/d' \
                     -e 's/zic/\/usr\/sbin\/zic/' \
                     -e 's[\*\*EDITME<xxx>EDITME\*\*['$TZ'[' \
               | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0
}' \
               | awk '{if ($1 == "mkdir" && $NF =="/etc/ld.so.conf.d")
print "if [ ! -e "$NF" ]; then\n  "$1" -v "$NF"\nfi";
else
print $0
}' \
               >> $Output
            fi
          else # chapter05
	    if ! $as_root; then
              GetCommands \
	       | sed -e '/install-tools\/mkheaders/d' \
               | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0
}' \
               >> $Output
            else
              GetCommands \
               | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0
}' \
               >> $Output
            fi
          fi
        else # update so modify some of the commands
          if $useDESTDIR; then
            GetCommands \
             | sed -e '/configure_commands()/i echo "slibdir=\/usr\/lib" >> configparms\necho "rtlddir=\/usr\/lib" >> configparms\necho "sbindir=\/usr\/bin" >> configparms\necho "rootsbindir=\/usr\/bin" >> configparms' \
                   -e '/--disable-werror/i\               --libdir=\/usr\/lib --libexecdir=\/usr\/lib                \\' \
                   -e '/touch \/etc\/ld.so.conf/i\  install -dm755 ${CUR_DIR}/etc' \
                   -e 's/touch \/etc\/ld.so.conf/touch ${CUR_DIR}\/etc\/ld.so.conf/' \
                   -e 's/\/etc\/nscd.conf/${CUR_DIR}\/etc\/nscd.conf/' \
                   -e 's/\/var\/cache\/nscd/${CUR_DIR}\/var\/cache\/nscd/' \
                   -e'/\/usr\/lib\/tmpfiles.d/i install -dm755 ${CUR_DIR}\/usr\/lib\/{locale,systemd\/system,tmpfiles.d}' \
                   -e 's/\/usr\/lib\/tmpfiles.d\/nscd.conf/${CUR_DIR}\/usr\/lib\/tmpfiles.d\/nscd.conf/' \
                   -e 's/\/usr\/lib\/systemd\/system\/nscd.service/${CUR_DIR}\/usr\/lib\/systemd\/system\/nscd.service/' \
                   -e '/mkdir -pv \/usr\/lib\/locale/,/make localedata\/install-locales/d' \
                   -e '/localedef -i POSIX /,/localedef -i ja_JP /d' \
                   -e 's/cat > \/etc\/nsswitch.conf/cat > ${CUR_DIR}\/etc\/nsswitch.conf/' \
                   -e 's/$ZONEINFO/${CUR_DIR}$ZONEINFO/' \
                   -e 's[\*\*EDITME<xxx>EDITME\*\*['$TZ'[' \
                   -e 's/\/etc\/localtime/${CUR_DIR}\/etc\/localtime/' \
                   -e 's/cat > \/etc\/ld.so.conf/cat > ${CUR_DIR}\/etc\/ld.so.conf/' \
                   -e 's/cat >> \/etc\/ld.so.conf/cat >> ${CUR_DIR}\/etc\/ld.so.conf/' \
                   -e 's/mkdir -pv \/etc\/ld.so.conf.d/mkdir -pv ${CUR_DIR}\/etc\/ld.so.conf.d/' \
                   -e '/tzselect/d' \
             | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0
}' \
             >> $Output
          else # not DESTDIR
            GetCommands \
             | sed -e '/--disable-werror/i\               --libexecdir=\/usr\/lib                   \\' \
	           -e '/touch \/etc\/ld.so.conf/d' \
                   -e '/mkdir -pv \/usr\/lib\/locale/,/End \/etc\/nsswitch.conf/d' \
                   -e '/EOF/d' \
                   -e '/tzselect/,/mkdir -pv \/etc\/ld.so.conf.d/d' \
             | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0
}' \
             >> $Output
           fi 
        fi
    ;;
    gmp)
        # if building for 64bit need to remove config for 32
        # remove cp commands for less capable CPU than the host
        GetCommands \
         | sed -e '/ABI=32/d' \
               -e '/cp -v configfsf/d' \
         >> $Output
    ;;
    grep)
        if [ "$SYSTEMD" = yes ]; then
           GetCommands \
            | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
            >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    groff)
        if [ "$Chapter" = update ]; then
          GetCommands \
           | sed -e 's/\*\*EDITME<paper_size>EDITME\*\*/'$PAPER_SIZE'/' \
                 -e 's/prefix=\/usr/prefix=\/usr \\\n              --sysconfdir=\/etc \\\n              --with-appresdir=\/etc\/X11\/app-defaults/' \
                 -e '/End of editable block/d' \
                 -e '/ln -sv/d' \
           >> $Output
        else
          GetCommands \
           | sed -e 's/\*\*EDITME<paper_size>EDITME\*\*/'$PAPER_SIZE'/' \
                 -e '/End of editable block/d' \
           >> $Output
        fi
    ;;
    grub)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/grub \/usr\/share/grub "${CUR_DIR}"\/usr\/share/' \
           >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    gzip)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
                 -e '/mv -v/d' \
           >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    iana-etc)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/cp services/i\  install -dm0755 "${CUR_DIR}"\/etc' \
                 -e 's/protocols \/etc/protocols "${CUR_DIR}"\/etc/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    inetutils)
        if [ "$SYSTEMD" = yes ]; then
          if [ "$Chapter" != update -o $useDESTDIR ]; then
            GetCommands \
             | sed -e '/disable-logger/i\              --libexecdir=/usr/lib  \\' \
                   -e '/mv -v/d' \
             >> $Output
          else
            GetCommands \
             | sed -e '/disable-logger/i\              --libexecdir=/usr/lib  \\' \
                   -e 's/disable-servers/disable-servers \\\n              --disable-hostname \\\n              --disable-ifconfig/' \
                   -e '/mv -v/d' \
             >> $Output
          fi
        else
          GetCommands  >> $Output
        fi
    ;;
    iproute2) # installed using destdir
        GetCommands \
         | sed -e 's/make SBINDIR=\/usr\/sbin/make DESTDIR="$CUR_DIR" SBINDIR=\/usr\/bin/' \
         >> $Output
    ;;
    jinja2)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/pip3 install/i\  PYTHONPATH=src python3 -m installer --destdir=\"\$CUR_DIR\" dist/*.whl' \
                 -e '/pip3 install/d' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    kbd)
          GetCommands \
           | sed -e "/make install/i\  sed -i '0,/install -d -m 755 \\\$(DESTDIR)\\\$(datadir)/ s///' data/Makefile" \
           >> $Output
    ;;
    kernel)
        if [ "$MAKE_KERNEL" = yes ]; then
          if $useDESTDIR; then
              GetCommands \
               | sed -e '/make mrproper/,/make menuconfig/d' \
                     -e 's/make modules_install/make INSTALL_MOD_PATH="${CUR_DIR}\/usr" modules_install/' \
                     -e '/mount --bind \/boot/,/cp -iv \.config/d' \
                     -e 's/install -v -m755 -d \/etc/install -v -m755 -d ${CUR_DIR}\/etc/' \
                     -e 's/cat > \/etc/cat > ${CUR_DIR}\/etc/' \
               >> $Output
          else # not DESTDIR
            if [ "$Chapter" = update ]; then
              GetCommands \
               | sed -e '/make mrproper/,/make menuconfig/d' \
                     -e '/mount --bind \/boot/,/End \/etc\/modprobe.d\/usb.conf/d' \
                     -e '/EOF/d' \
                     -e 's/linux-'"${linuxcomvers}"'/linux-'"${linuxvers}"'/' \
               >> $Output
            else # not update
              GetCommands \
               | sed -e '/make mrproper/,/make menuconfig/d' \
                     -e '/mount --bind \/boot/,/cp -iv \.config/d' \
                     -e 's/linux-'"${linuxcomvers}"'/linux-'"${linuxvers}"'/' \
               >> $Output
            fi   
          fi  # test useDESTDIR
	else # MAKE_KERNEL is no so just do make mrproper
	  GetCommands \
           | sed -e '/make menuconfig/d' \
	         -e '/^$/d;/make$/d' \
	         -e 's/make modules_install/echo "No install script for this package"/' \
		 -e '/mount --bind /,/^EOF/d' \
           >> $Output
        fi
    ;;
    kernfs) # change permissions on /dev/shm
        GetCommands \
         | sed -e '/fi/i\  chmod 1777 $LFS\/dev\/shm/' \
         >> $Output
    ;;
    kmod)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/for target in depmod/,/ln -sfv kmod/d' \
                 -e '/make install/a\  install -dm755 ${CUR_DIR}\/{etc,usr\/lib}\/{depmod,modprobe}.d\n\  for tool in {ins,ls,rm,dep}mod mod{probe,info}; do\n\   ln -sfv kmod ${CUR_DIR}\/usr\/bin\/${tool}\n\  done' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    libcap)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '0,/make prefix=\/usr lib=lib/s//make prefix=\/usr lib=lib\n\  make -C pam_cap/' \
                 -e '/make prefix=\/usr lib=lib install/a\  install -dm0755 "${CUR_DIR}"\/usr\/lib\/security\n\  install -v -m755 pam_cap\/pam_cap.so "${CUR_DIR}"\/usr\/lib\/security\n\  install -dm0755 "${CUR_DIR}"\/etc\/security\n\  install -v -m644 pam_cap\/capability.conf "${CUR_DIR}"\/etc\/security' \
                 -e 's/make prefix=\/usr lib=lib install/make DESTDIR="$CUR_DIR" prefix=\/usr lib=lib sbindir=bin install/' \
           >> $Output
        else
          GetCommands \
           | sed -e 's/make prefix=\/usr lib=lib install/make prefix=\/usr lib=lib sbindir=bin install/' \
           >> $Output
        fi
    ;;
    libelf)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/libelf install/libelf DESTDIR="$CUR_DIR" install/' \
                 -e 's/libelf.pc \/usr\/lib\/pkgconfig/libelf.pc "${CUR_DIR}"\/usr\/lib\/pkgconfig/' \
                 -e 's/rm \/usr\/lib\/libelf.a/rm "${CUR_DIR}"\/usr\/lib\/libelf.a/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    libtool)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/rm -fv \/usr\/lib\/libltdl/rm -fv "${CUR_DIR}"\/usr\/lib\/libltdl/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    linux-headers)
        if [[ "$useDESTDIR" = true || "$single_package" = true ]]; then
          GetCommands \
           | sed -e '/cp -rv usr\/include/i\  mkdir -pv ${CUR_DIR}\/usr\/include' \
                 -e 's/include \/usr/include ${CUR_DIR}\/usr/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    man-db)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/disable-setuid/i\              --libexecdir=\/usr\/lib \\\n\              --sbindir=/usr/bin \\' \
                 -e 's/\/usr\/lib\/tmpfiles.d\/man-db.conf/"${CUR_DIR}"\/usr\/lib\/tmpfiles.d\/man-db.conf/' \
           >> $Output
        else
          if [ "$SYSTEMD" = yes ]; then
            if $as_root; then
              GetCommands \
               | sed -e 's/bin\/grap/bin\/grap --libexecdir=\/usr\/lib/' \
               >> $Output
            else
              GetCommands \
               | sed -e 's/bin\/grap/bin\/grap --libexecdir=\/usr\/lib/' \
                     -e 's/man root:root root/man man:man-db man-db/' \
               >> $Output
            fi
          else
            GetCommands >> $Output
          fi
        fi
    ;;
    man-pages)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/make prefix=\/usr install/make prefix=\/usr DESTDIR="$CUR_DIR" install/' \
           >> $Output
        else
          GetCommands \
           | sed -e '/configure_commands/i sed -i "s|prefix := /usr/local|prefix := /usr|g" Makefile' \
           >> $Output
        fi
    ;;
    markupsafe)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/pip3 install/i\  PYTHONPATH=src python3 -m installer --destdir=\"\$CUR_DIR\" dist/*.whl' \
                 -e '/pip3 install/d' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    meson)
        if $useDESTDIR; then
          GetInternalCommands mesonDestdirComms >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    ncurses)
        if [ "$currentChapter" = chapter06 ]; then
          GetCommands >> $Output
	else # chapter08 and update
          if [ "$SYSTEMD" = yes ]; then
            if $useDESTDIR; then
              GetInternalCommands ncursesDestdirComms >> $Output
            else
              GetInternalCommands ncursesComms >> $Output
            fi
          else # sysv
             GetCommands \
              | sed -e '/make distclean/,/cp -av lib\/lib/d' \
              >> $Output
          fi
	fi # chapter06 or 08
    ;;
    ninja)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/install -vm755 ninja/i\  install -dm0755 "${CUR_DIR}"\/usr\/{bin,share}' \
                 -e 's/ \/usr\/bin/ "${CUR_DIR}"\/usr\/bin/' \
                 -e 's/ \/usr\/share/ "${CUR_DIR}"\/usr\/share/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    openssl)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/make MANSUFFIX/make DESTDIR="$CUR_DIR" MANSUFFIX/' \
                 -e 's/mv -v \/usr\/share\/doc\/openssl \/usr/mv -v "${CUR_DIR}"\/usr\/share\/doc\/openssl "${CUR_DIR}"\/usr/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    procps-ng)
        if [ "$SYSTEMD" = yes ]; then # add the sysctl.conf file
          if [ "$Chapter" != update ]; then
            GetCommands \
             | sed -e '/libdir=\/usr\/lib/i\              --bindir=\/usr\/bin \\\n\              --sbindir=\/usr\/bin \\\n\              --with-systemd                           \\' \
                   -e '/sed -i/,/make check/d' \
                   -e '/ln -sfv/a touch \/etc\/sysctl.conf' \
                   -e '/mv -v/,/ln -sfv/d' \
             >> $Output
          else # update
            GetCommands \
             | sed -e '/libdir=\/usr\/lib/i\              --bindir=\/usr\/bin \\\n\              --sbindir=\/usr\/bin \\\n\              --with-systemd                           \\' \
                   -e '/sed -i/,/make check/d' \
                   -e '/mv -v/,/ln -sfv/d' \
             >> $Output
          fi
        else
           GetCommands >> $Output
        fi
    ;;
    psmisc)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e '/mv -v/d' \
           >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    python3) # remove doc commands
        if $useDESTDIR; then # assuming Chapter=update and/or a single package
          GetCommands \
           | sed -e '/configure --prefix/i\  CXX=\"\/usr\/bin\/g++\"               \\' \
                 -e 's/-i \/usr\/lib/-i "${CUR_DIR}"\/usr\/lib/' \
                 -e '/tar --strip-components/,/-xvf /d' \
           >> $Output
        else
          GetCommands \
           | sed -e '/tar --strip-components/,/-xvf /d' \
           >> $Output
        fi
    ;;
    readline)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/lncursesw\" install/lncursesw\" DESTDIR=\"\$CUR_DIR\" install/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    sed)
        if $useDESTDIR; then
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
                   -e 's/make -C doc install/make -C doc DESTDIR="$CUR_DIR" install/' \
             >> $Output
          else
             GetCommands \
              | sed -e 's/make -C doc install/make -C doc DESTDIR="$CUR_DIR" install/' \
              >> $Output
          fi
        else # not using DESTDIR
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
             >> $Output
          else
             GetCommands >> $Output
          fi
        fi
    ;;
    shadow)
        # the following apply if not update:
        # assume without cracklib support
        # do not install foreign man pages
        # do not set root passwd
        # setup shadow passwd files
        # delete pwconv and grpconv because cannot lock /etc/passwd
        # do pwconv and grpconv later as root
      if [ "$Chapter" != update ]; then
        if $useDESTDIR; then
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e '/DICTPATH/d' \
                   -e "/configure_commands()/i sed -i -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\\\\//' \\\\\n\       -e 's\/zh_CN zh_TW\/\/' \\\\\n\       -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr\//'  man/Makefile.in" \
                   -e 's/sysconfdir=\/etc/sysconfdir=\/etc \\\n\              --bindir=\/usr\/bin \\\n\              --sbindir=\/usr\/bin \\\n\              --libdir=\/usr\/lib/' \
                   -e '/mv -v/,/grpconv/d' \
                   -e '/passwd root/d' \
                   -e "s/sed -i 's\/yes\/no\/' \/etc\/default\/useradd/sed -i 's\/yes\/no\/' \${CUR_DIR}\/etc\/default\/useradd/" \
             >> $Output
          else
            GetCommands \
             | sed -e '/DICTPATH/d' \
                   -e "/configure_commands()/i sed -i -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\\\\//' \\\\\n\       -e 's\/zh_CN zh_TW\/\/' \\\\\n\       -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr\//'  man/Makefile.in" \
                   -e 's/sysconfdir=\/etc/sysconfdir=\/etc \\\n\              --bindir=\/usr\/bin \\\n\              --sbindir=\/usr\/bin \\\n\              --libdir=\/usr\/lib/' \
                   -e '/pwconv/,/grpconv/d' \
                   -e '/passwd root/d' \
                   -e "s/sed -i 's\/yes\/no\/' \/etc\/default\/useradd/sed -i 's\/yes\/no\/' \${CUR_DIR}\/etc\/default\/useradd/" \
             >> $Output
          fi
        else # not useDESTDIR
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e '/DICTPATH/d' \
                   -e "/configure_commands()/i sed -i -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\\\\//' \\\\\n\       -e 's\/zh_CN zh_TW\/\/' \\\\\n\       -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr\//'  man/Makefile.in" \
                   -e '/mv -v/d' \
                   -e '/passwd root/d' \
                   -e '/pwconv/ i touch /etc/shadow\nchmod 640 /etc/shadow' \
                   -e '/grpconv/ i touch /etc/gshadow\nchmod 640 /etc/gshadow' \
                   -e '/pwconv/d' \
                   -e '/grpconv/d' \
             >> $Output
          else
            GetCommands \
             | sed -e '/DICTPATH/d' \
                   -e "/configure_commands()/i sed -i -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\\\\//' \\\\\n\       -e 's\/zh_CN zh_TW\/\/' \\\\\n\       -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr\//'  man/Makefile.in" \
                   -e '/passwd root/d' \
                   -e '/pwconv/ i touch /etc/shadow\nchmod 640 /etc/shadow' \
                   -e '/grpconv/ i touch /etc/gshadow\nchmod 640 /etc/gshadow' \
                   -e '/pwconv/d' \
                   -e '/grpconv/d' \
             >> $Output
          fi
        fi
      else # update
          if $useDESTDIR; then # use the destdir commands
            GetInternalCommands shadowDestdirComms >> $Output
          else
            GetInternalCommands shadowComms >> $Output
         fi 
      fi
    ;;
    stripping)
        echo "set +e" >> $Output
        if ! $as_root; then 
          GetCommands \
           | sed -e "/strip --strip-unneeded \/tmp\/\$LIB/a\    USER=\$(stat -c '%U' \/usr\/lib\/\$LIB)\n\    GROUP=\$(stat -c '%G' \/usr\/lib\/\$LIB)" \
                 -e "/strip --strip-unneeded \/tmp\/\$BIN/a\    USER=\$(stat -c '%U' \/usr\/bin\/\$BIN)\n\    GROUP=\$(stat -c '%G' \/usr\/bin\/\$BIN)" \
                 -e 's/install -vm755 \/tmp\/$LIB \/usr\/lib/install -vm755 -o $USER -g $GROUP \/tmp\/$LIB \/usr\/lib\n\    if [ -e "$LIB.dbg" ]; then chown -v $USER:$GROUP $LIB.dbg; fi/' \
                 -e 's/install -vm755 \/tmp\/$BIN \/usr\/bin/install -vm755 -o $USER -g $GROUP \/tmp\/$BIN \/usr\/bin/' \
           >> $Output
        fi
    ;;
    sysklogd)
        if ! $as_root; then
        # fix the Make file to use the install wrapper and not the default install bin
          GetCommands \
           | awk '{if ($NF == "install" && $1 == "make") $1 = "  make INSTALL=install"; print $0}' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    systemd)
        if ! $as_root; then
          if $useDESTDIR; then
            GetCommands \
             | sed -e 's/ninja install/DESTDIR="$CUR_DIR" ninja install/' \
                   -e '/tar -xf /i install -dm0755 "${CUR_DIR}"\/usr\/share\/man' \
                   -e 's/ --strip-components=1//' \
                   -e 's/-C \/usr\/share\/man/-C "${CUR_DIR}"\/usr\/share\/man/' \
                   -e '/systemd-machine-id-setup/,/systemctl disable systemd-sysupdate/d' \
             >> $Output
          else
            GetCommands \
             | sed -e '/systemd-machine-id-setup/,/systemctl disable systemd-sysupdate/d' \
                   -e 's/ --strip-components=1//' \
             >> $Output
          fi
        else
          GetCommands >> $Output
	fi
    ;;
    sysvinit)
        if [ "$SYSTEMD" = yes ]; then
          GetInternalCommands sysvinitComms >> $Output
        else
          GetCommands \
           | sed -e "/patch/a sed -i '/dev\\\/initctl/d' src/Makefile" \
           >> $Output
        fi
    ;;
    tar)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/bindir=\/bin/bindir=\/usr\/bin --libexecdir=\/usr\/lib\/tar/' \
                 -e 's/make -C doc install-html/make -C doc DESTDIR=\"\$CUR_DIR\" install-html/' \
           >> $Output
        else
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/bindir=\/bin/bindir=\/usr\/bin --libexecdir=\/usr\/lib\/tar/' \
             >> $Output
          else
            GetCommands >> $Output
          fi
        fi
    ;;
    tcl)
      if [ "$Chapter" != update ]; then
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/chmod -v u+w \/usr/chmod -v u+w \"\${CUR_DIR}\"\/usr/' \
                 -e 's/ln -sfv tclsh8.6 \/usr/ln -sfv tclsh8.6 \"\${CUR_DIR}\"\/usr/' \
                 -e 's/mv \/usr\/share\/man\/man3/mv \"\${CUR_DIR}\"\/usr\/share\/man\/man3/' \
	   >> $Output
        else
          GetCommands >> $Output
        fi
      else # update
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/chmod -v u+w \/usr/chmod -v u+w \"\${CUR_DIR}\"\/usr/' \
                 -e 's/ln -sfv tclsh8.6 \/usr/ln -sfv tclsh8.6 \"\${CUR_DIR}\"\/usr/' \
                 -e 's/mv \/usr\/share\/man\/man3/mv \"\${CUR_DIR}\"\/usr\/share\/man\/man3/' \
           >> $Output
        else
          GetCommands \
           | sed -e '/ln -sfv tclsh8.6 /irm -v \/usr\/bin\/tclsh' \
                 -e '/mv \/usr\/share\/man\/man3/i\if [ -e "\/usr\/share\/man\/man3\/Tcl_Thread.3" ]; then\n\  rm -v "\/usr\/share\/man\/man3\/Tcl_Thread.3"\nfi' \
           >> $Output
        fi
      fi
    ;;
    texinfo)
        # tries and fails to rebuild /usr/share/info/dir
        GetCommands \
         | sed -e '/make TEXMF=/d' \
               -e '/pushd/,/popd/d' \
         >> $Output
    ;;
    util-linux)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/mkdir -pv \/var\/lib\/hwclock/mkdir -pv \${CUR_DIR}\/var\/lib\/hwclock/' \
                 -e '/docdir=\/usr\/share\/doc/i\              --libdir=/usr/lib \\\n\              --bindir=/usr/bin \\\n\              --sbindir=/usr/bin \\' \
                 -e '/disable-login/,/disable-su/d' \
                 -e '/disable-setpriv/i\              --enable-vipw \\' \
                 -e 's/without-python/without-python     \\\n\              --with-systemdsystemunitdir=\/usr\/lib\/systemd\/system/' \
           >> $Output
        else
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e '/docdir=/d' \
                     -e '/disable-chfn-chsh/i\              --docdir=\/usr\/share\/doc\/util-linux-'"${utillinuxvers}"' \\' \
                     -e '/without-python/i\              --with-systemdsystemunitdir=\/usr\/lib\/systemd\/system \\\n\              --disable-makeinstall-chown \\\n\              --disable-makeinstall-setuid \\' \
                     -e '/tar -xf ..\/util-linux-man-pages/d' \
             >> $Output
          else
            GetCommands \
             | sed -e '/docdir=/d' \
                   -e '/disable-chfn-chsh/i\              --docdir=\/usr\/share\/doc\/util-linux-'"${utillinuxvers}"'' \
             >> $Output
          fi
        fi
    ;;
    vim)
        if [ "$Chapter" != update ]; then
          GetCommands \
           | sed -e 's/make test/make -j1 test/' \
                 -e '/:options/d' \
           >> $Output
        else
          if $useDESTDIR; then
            GetCommands \
             | sed -e 's/ln -sv vim \/usr/ln -sv vim ${CUR_DIR}\/usr/' \
                   -e 's/for L in  \/usr/for L in  ${CUR_DIR}\/usr/' \
                   -e '/ln -sv ..\/vim\/vim82\/doc/i mkdir -pv ${CUR_DIR}\/usr\/share\/doc' \
                   -e 's/vim82\/doc \/usr/vim82\/doc ${CUR_DIR}\/usr/' \
                   -e '/cat > \/etc\/vimrc/i mkdir -pv ${CUR_DIR}\/etc' \
                   -e 's/cat > \/etc\/vimrc/cat > ${CUR_DIR}\/etc\/vimrc/' \
                   -e '/:options/d' \
             >> $Output
          else
            GetCommands \
             | sed -e '/:options/d' \
             >> $Output
          fi
        fi
    ;;
    wheel)
        if [ "$Chapter" != update ]; then
          GetCommands >> $Output
        else # update
          if $useDESTDIR; then # needs py3-build and py3-installer installed
            GetInternalCommands wheelDestdirComms >> $Output
          else
            GetCommands \
             | sed -e 's/pip3 install --no-index/pip3 install --no-index --upgrade/' \
             >> $Output
          fi
        fi
    ;;
    xz)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/prefix=\/usr/prefix=\/usr --libdir=\/usr\/lib/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    zlib)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/make install/make DESTDIR="$CUR_DIR" install/' \
                 -e 's/rm -fv \/usr\/lib\/libz/rm -fv "${CUR_DIR}"\/usr\/lib\/libz/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    zstd)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/make prefix=\/usr install/make PREFIX=\/usr DESTDIR="$CUR_DIR" install/' \
                 -e 's/make prefix=\/usr/make PREFIX=\/usr/' \
                 -e '/rm -v \/usr/i ln -sf \/usr\/bin\/zstd "${CUR_DIR}\/usr\/bin\/zstdmt"' \
                 -e 's/rm -v \/usr\/lib\/libzstd/rm -v "${CUR_DIR}"\/usr\/lib\/libzstd/' \
           >> $Output
        else
          GetCommands  >> $Output
        fi
    ;;
    *)
        GetCommands >> $Output
        return_val=$?
        if [ $return_val -eq $RETURN_PARAM ]; then # no build file
          echo "No build file available in ${LFS}/tools/pkguser"
          echo "Please place the build file there to continue."
          exit 1
        elif [ $return_val -eq $RETURN_NO_CMNDS ]; then
          echo "*** WARNING ***"
          echo "No commands found for package $PkgName"
	  if $single_package; then
	    echo "Package $SINGLE_PACKAGE not found in $Chapter"
	    echo "You should set Chapter to the one you want and try again"
	    echo "Exiting now"
	    exit 1
	  fi
        fi
    ;;
esac
} # end WriteScript
#
cleanstart () {
# $1 is the script name to delete. Can be all
if [ "$1" = all ]; then
  scriptToDelete="$ch7asroot $ch7chroot $ch5script $ch6script $ch8script LFS-chroot.sh"
elif [[ "$1" = chapter05 || "$1" = chapter06 || "$1" = update ]]; then
  scriptToDelete=${1}.sh
elif [ "$1" = chapter07 ]; then
  scriptToDelete="$ch7asroot $ch7chroot $ch7script"
elif [ "$1" = chapter08 ]; then
  scriptToDelete="$ch8script LFS-chroot.sh"
fi
for Script in $scriptToDelete; do
  for loc in $LFS ~/; do
    if [ -e $loc/$Script ]; then rm $loc/$Script; fi
  done
done
} #end cleanstart
#
addCommands () {
# adds commands to the /lfs-commands dir for a given book-chapter and package
# $1 is the package name
# $2 is the number to add to the front of the package name (must be unique)
# $3 is the chapter in the book where this package is installed
# $4 is the commands to add
local pkgnm=$1
local number=$2
local chapter=$3
local commands=("${!4}")
# the location of the commands
local location="${LFS}/lfs-commands/${chapter}"
local com
if [ ! -d "$location" ]; then
  return $RETURN_PARAM
else
  local fileLoc="${location}/${number}-${pkgnm}"
# check if required commands are in place
  if [ -e "$fileLoc" ]; then # exists
    return 0
  else
# add the commands for pkgnm to location
    if $printit; then msg "will add commands for $pkgnm to $location"; fi
    cat > $fileLoc << EOF
$(
    for com in "${commands[@]}"; do
      echo "$com"
    done
 )
EOF
  fi
  return 0
fi
} # end addCommands
#
arrangeOrder () {
# $1 is the script to arrange
# $2 is the chapter
tmpfile=/tmp/$(date +%d%B%Y_%H:%M)tmp.file
local IFS=' ' # set the separator to a space
local scriptToArrange=$1
local chapter=$2
#
for scrpt in $scriptToArrange; do
  Output=$scrpt
# match the start line for each function and output it
  awk '/_[[:space:]]\(\)[[:space:]]\{/ {print $1}' $Output >> $tmpfile

#
# the install order for Chapter08 in book version sysv is different from version systemd
# need to change the install order here
#
# TODO - this is a mess, but not sure there is an elegant solution to rearranging
#
  while read eachFunc; do
    if [[ "$chapter" = chapter08 || "$WHICH_CHAPTER" = update ]]; then
      if [[ "$SYSTEMD" = yes ]]; then # don't need sysklogd and sysvinit
        if [[ "$isSystemdBook" = false ]]; then # need to change the order
          if [[ "$eachFunc" = sysklogd_ || "$eachFunc" = sysvinit_ ]]; then
            : # don't write it
          elif [[ "$eachFunc" = procpsng_ || "$eachFunc" = e2fsprogs_ || "$eachFunc" = coreutils_ || "$eachFunc" = gperf_ || "$eachFunc" = intltool_ || "$eachFunc" = diffutils_ || "$eachFunc" = gawk_ || "$eachFunc" = findutils_ || "$eachFunc" = xz_ || "$eachFunc" = kmod_ || "$eachFunc" = utillinux_ || "$eachFunc" = mandb_ || "$eachFunc" = eudev_ ]]; then # will be moved
            :
          elif [[ "$eachFunc" = gdbm_ ]]; then # add gperf
            echo "$eachFunc
gperf_" >> $Output
          elif [[ "$eachFunc" = xmlparser_ ]]; then # add intltool
            echo "$eachFunc
intltool_" >> $Output
          elif [[ "$eachFunc" = automake_ ]]; then # ad xz
            echo "$eachFunc
xz_
kmod_" >> $Output
          elif [[ "$eachFunc" = systemd_ ]]; then # add procps-ng, etc
            echo "$eachFunc
procpsng_
e2fsprogs_
coreutils_
diffutils_
gawk_
findutils_" >> $Output
          elif [[ "$eachFunc" = dbus_ ]]; then # add util-linux and man-db
            echo "$eachFunc
utillinux_
mandb_" >> $Output
          else
            echo $eachFunc >> $Output
          fi
        else # SYSTEMD=yes and isSystemdBook=true, so keep the order unchanged
          if [[ "$eachFunc" = sysklogd_ || "$eachFunc" = sysvinit_ ]]; then
            : # don't write it
          else
            echo $eachFunc >> $Output
          fi
        fi
      else # chapter08 or update and SYSTEMD=no
        if [[ "$eachFunc" = dbus_ || "$eachFunc" = systemd_ ]]; then
          : # don't write it
        else 
          echo $eachFunc >> $Output
        fi
      fi
    else # chapter07 - need to move creatingdirs first
      if [[ "$eachFunc" = resetBashProfile_ ]]; then # has to come after pkguser
	    :
      elif [[ "$eachFunc" = pkguser_ ]]; then
         echo "$eachFunc
resetBashProfile_" >> $Output
      else # write them
        echo $eachFunc >> $Output
      fi
    fi
  done < $tmpfile
  rm $tmpfile
  chmod 700 $Output
done
} # end arrangeOrder
#
removeTests () {
# removes all the test commands from a script
# $1 is the script file
local scriptFile=$1
echo "Removing test commands for script $scriptFile"
sed -e '/make -k check 2>&1 | tee glibc-check-log/d' \
    -e '/grep Error glibc-check-log/d' \
    -e '/make check/d' \
    -e '/make -j1 check/d' \
    -e '/make -j4 check/d' \
    -e '/make -k check/d' \
    -e '/make -kj1 check/d' \
    -e '/make -k -j1 check/d' \
    -e '/make RUN_EXPENSIVE_TESTS=yes check/d' \
    -e '/TZ=UTC make test/d' \
    -e '/make check 2>&1 | tee gmp-check-log/d' \
    -e "/awk '\/# PASS:\/{total+=\$3} ; END{print total}' gmp-check-log/d" \
    -e '/ulimit -s 32768/,/contrib\/test_summary/d' \
    -e '/make NON_ROOT_USERNAME=nobody check-root/d' \
    -e '/echo "dummy:x:1000:nobody" >> \/etc\/group/d' \
    -e '/bash tests\/run.sh --srcdir=\$PWD --builddir=\$PWD/d' \
    -e '/chown -Rv nobody ./d' \
    -e '/su nobody -s \/bin\/bash -c "PATH=\$PATH make check"/d' \
    -e '/su nobody -s \/bin\/bash -c \"make RUN_EXPENSIVE_TESTS=yes check\"/d' \
    -e '/su nobody -s \/bin\/bash -c "make tests"/d' \
    -e "/sed -i '\/dummy\/d' \/etc\/group/d" \
    -e '/tester/d' \
    -e '/make test/d' \
    -e '/make -k test/d' \
    -e '/make -j1 test/d' \
    -e '/ninja_test/d' \
    -e '/make PERL5LIB=\$PWD\/tests/d' \
    -e '/make localedata\/install-locales/d' \
    -e '/ln -sfv \/tools\/lib\/lib{blk,uu}id.so.1 lib/,/make LD_LIBRARY_PATH=\/tools\/lib check/d' \
    -i $scriptFile
} # end removeTests
#
containsElement () {
#msg "in containsElement"
# check if an array contains a value
# $1 is the element to find
# $2 is the array to search
local toFind=$1
declare -a anArray=("${!2}")
local elem
for elem in $anArray; do
  if [[ "$toFind" == "$elem" ]]; then return 0; fi
done
return $RETURN_PARAM
} # end containsElement
#
Start () {
cleanstart $WHICH_CHAPTER
local bookdir=$1
local book_version=$2
# if a single package used, then $3 is the package name
local singlePackage=$3
local listPackages
#
REPODIR="${bookdir}/${trunkDIR}"
Chapter=$WHICH_CHAPTER # don't change Chapter, change reqChaps
# build the requested chapters or a single package
if [ "$singlePackage" != no ]; then
  if [ "$singlePackage" = kernel ]; then
    reqChaps=chapter10
  else
    reqChaps=chapter08
  fi
  scriptName="${LFS}/${SINGLE_PACKAGE}.sh"
else # not a single package
  reqChaps=$WHICH_CHAPTER
  if [ "$WHICH_CHAPTER" = update ]; then
    if $installKernel; then
      reqChaps=chapter10
    else
      reqChaps=chapter08
    fi
  fi
  if [ "$reqChaps" = all ]; then # *** this currently (05/2022) doesn't work ***
    reqChaps=$allChaps # doesn't include update
    msg "*** WARNING *** all chapters doesn't work. It is not tested"
  fi
  msg "reqChaps is $reqChaps"
  msg "Chapter is $Chapter"
fi
# cycle through the requested chapters
for currentChapter in $reqChaps; do
# set the output script name
  msg "currentChapter is $currentChapter"
  case $currentChapter in
     chapter05)
       scriptName=${LFS}/${ch5script}
     ;;
     chapter06)
       scriptName=${LFS}/${ch6script}
     ;;
     chapter07)
       scriptName=${LFS}/${ch7script}
     ;;
     chapter08)
       if [ "$Chapter" = update ]; then
         scriptName=${LFS}/${updateScript}
       else
         scriptName=${LFS}/${ch8script}
       fi
     ;;
     chapter10)
       if [ "$Chapter" = update ]; then
         if $installKernel; then
           scriptName="${LFS}/${updateScript/\.sh/}-kernel.sh"
         fi
       else
         scriptName=${LFS}/${ch10script}
       fi
     ;;
  esac
  msg "scriptName is $scriptName"
  Output=$scriptName # global variable
  if [[ ("$Chapter" = chapter10 || "$Chapter" = update) && "$installKernel" = true ]]; then
    msg "MAKE_KERNEL is yes so the kernel will be installed for $Chapter"
  fi
  Header # set the header values
  if $single_package; then
    listPackages=$singlePackage
  else # all packages in currentChapter
# if chapter is not update then remove linux-headers from chapter08
    testForLinuxHeaders="${DumpedCommands}/${currentChapter}/071-linux-headers"
    if [ "$Chapter" != update ]; then
      if [ -e $testForLinuxHeaders ]; then rm -v $testForLinuxHeaders; fi
    fi
msg "haveCommands is $haveCommands"
    if $haveCommands; then # use the lfs commands on the target machine
      listPackages=$( ls -l ${DumpedCommands}/${currentChapter} | tail -n+2 | awk '{print $NF}' | sed 's/^[^-]*-//g')
    elif [ -d "${REPODIR}/lfs/${currentChapter}" ]; then # use the book xml files to get pkgnames
      listPackages=$( awk -F\" '/href/ && !/<!--/ {gsub(/\.xml/,"");print $(NF -1)}' ${REPODIR}/lfs/${currentChapter}/${currentChapter}.xml )
    else
      echo "No book found in ${REPODIR}/lfs/${currentChapter}"
      echo "and no commands in ${DumpedCommands}/${currentChapter}"
      echo "Aborting"
      exit 1
    fi
  fi
  if ! $single_package; then # check if linux-headers is needed
    if [ "$Chapter" = update ]; then # is linux-headers in listPackages
      if ! $installKernel; then
        nl='
'
        containsElement "linux-headers" listPackages[@]
        retval=$?
        if [ $retval -ne 0 ]; then listPackages="linux-headers""${nl}"$listPackages; fi
      else # install the kernel
        listPackages[0]="kernel"
      fi
    fi
  fi
echo "listPackages is ${listPackages[@]}"
  for Name in $listPackages; do
# ignore systemd and dbus if using sysv
    if [[ "$isSystemdBook" = false && ("$Name" == systemd || "$Name" == dbus) ]]; then # not installed in this book version
      :
    else
      if [[ "$SYSTEMD" = yes && "$Name" = eudev ]]; then # ignore this - replaced by systemd
        :
      else
        FuncName=$( echo $Name | sed -e s/-//g ) # no - allowed in bash names
        PkgName=$( echo $Name | sed -e s/pass.$// -e s/-$// )
        SrcName=$PkgName-
        CmdName=$Name
        if [ "$PkgName" = Python ]; then # use python3 for Python-3*
          FuncName=python3
          PkgName=python3
        fi
        case $currentChapter in  # deal with the 3 files in chapter07
           chapter07) # creates 3 files
             case $FuncName in
	         changingowner)
                   Output=${LFS}/${ch7asroot}
		 ;;
	         chroot)
                   Output=${LFS}/${ch7chroot}
# if you log out or reboot you need to mount the kernelfs again
# so include some conditionals to look after this
                   cat ${LFS}/${ch7asroot} \
                    | awk '/mount -v/ { printf "if [ \"$(grep -q \""$NF"\" /proc/mounts;echo $?)\" != \"0\" ]; then\n  "$0"\nfi\n"}' \
                    >> $Output
		 ;;
	         *)
                   Output=${LFS}/${ch7script}
		 ;;
             esac
          ;;
        esac
        case $PkgName in # call Function
           createfiles)
              if [ "$Chapter" != update ]; then
                Function
# Now have a base file structure so add pkguser
                if ! $as_root; then
                  pkguser
                else
                  copypkguserbin # add listpkg and necessary files
                fi
              fi
           ;;
           creatingdirs)
              if [ "$Chapter" != update ]; then
                Function
              else
                cleanPkgDir
                update_pkguser # add some files to the tools dir
                if $useDESTDIR; then createPkgFile; fi
              fi
           ;;
           expect)
              SrcName=expect5
              Function
           ;;
           fstab) # cannot deal with this here - created in chapter10
              :
           ;;
           gcc-libstdc++) # name in chapter05 - remove the gcc-
              PkgName=gcc
              SrcName=gcc-
              if [ "$FuncName" = "gcclibstdc++" ]; then
                CmdName="gcc-libstdc++"
              fi
#              if [ "$FuncName" = "gcclibstdc++pass1" ]; then
#                CmdName="gcc-libstdc++-pass1"
#              fi
              Function
           ;;
           gettext) 
              Function
              if [[ "$SYSTEMD" = yes && "$isSystemdBook" = false && "$currentChapter" = chapter06 ]]; then # add systemd
                for sysFile in systemd; do
                  FuncName=$sysFile
                  PkgName=$sysFile
                  SrcName=$sysFile-
                  Function
                done
              fi
           ;;
           introduction|toolchaintechnotes|generalinstructions|pkgmgt|aboutdebug)
              : # do not need any of these
           ;;
           jinja2)
              SrcName=Jinja2-
              Function
           ;;
           kernfs)
              if [ "$currentChapter" = chapter07 ]; then
                Output=${LFS}/${ch7asroot}
                Function
              fi
           ;;
           libelf)
              SrcName=elfutils-
              Function
           ;;
           libstdc++)
              PkgName=gcc
              SrcName=gcc-
	      if [ "$FuncName" = "libstdc++pass2" ]; then
		CmdName="gcc-libstdc++-pass2"
	      else
	        CmdName="gcc-libstdc++-pass1"
	      fi
              Function
 	   ;;    
           linux-headers|kernel)
              SrcName=linux-
              Function
           ;;
           markupsafe)
              SrcName=MarkupSafe-
              Function
           ;;
           patch) 
              Function
              if [[ "$SYSTEMD" = yes && "$isSystemdBook" = false && "$currentChapter" = chapter06 ]]; then
# add dbus after patch
                for sysFile in dbus; do
                  FuncName=$sysFile
                  PkgName=$sysFile
                  SrcName=$sysFile-
                  Function
                done
              fi
           ;;
           pkgconfig)
              PkgName=pkg-config
              CmdName=pkg-config
              SrcName=pkg-config-
              Function
           ;;
           procps)
              FuncName=procpsng
              PkgName=procps-ng
              CmdName=procps-ng
              SrcName=procps-ng-
              Function
           ;;
           cleanup)
               if [ "$currentChapter" = chapter08 ]; then
                Function
              fi
           ;;
           tcl)
                SrcName=tcl8.
                Function
           ;;
           xml-parser)
                SrcName=XML-Parser-
                Function
           ;;
           *)
              if [[ "$currentChapter" == chapter10 && "$PkgName" == grub ]]; then # want the grub in chapter08 but not the one in chapter10
                :
              else
                Function
              fi
           ;;
        esac
      fi
    fi
  done # end of Name in $listPackages
  if [[ "$single_package" = true || ("$currentChapter" != chapter07 && "$currentChapter" != chapter08) ]]; then
# create the function name to run - use this if not using arrangeOrder, i.e. chapters 5, 6, 10 and single_package
    awk '/_[[:space:]]\(\)[[:space:]]\{/ {print $1}' $Output >> $Output
  else # 7, 8 and update
    arrangeOrder $scriptName $currentChapter
  fi
  chmod 700 $Output # make it executable and if chapter07, asroot and chroot as well
  if [ "$currentChapter" = chapter07 ]; then
    chmod 700 ${LFS}/${currentChapter}{-asroot.sh,-chroot.sh}
  fi
done # end of currentChapter in $reqChaps
if [ "$BOOK_VERSION" = trunk ]; then
  if [[ ! -z "$linuxcomvers" && ! -z "$kernLatestVers" ]]; then
    if [[ "$linuxcomvers" != "$kernLatestVers" ]]; then
      sed -e "s/$linuxcomvers/$kernLatestVers/g" -i $Output
    fi
  fi
  if [[ ! -z "$linuxvers" ]]; then
    if [[ "$linuxvers" != "$kernLatestVers" ]]; then
      sed -e "s/$linuxvers/$kernLatestVers/g" -i $Output
    fi
  fi
fi
#
# remove tests if not requested
if [ "$TESTS" = no ]; then
  echo "TESTS is set to no"
  case $WHICH_CHAPTER in
     chapter10) # no tests in 10
       :
     ;;
     *)
       removeTests $scriptName
     ;;
  esac
fi
#
if [[ "$WHICH_CHAPTER" = chapter05 || "$WHICH_CHAPTER" = chapter06 ]]; then
# make sure the build dir exists for chapter05/06.sh and set owner to lfs if installing as root
  if [ ! -d $buildDir ]; then
    mkdir -pv $buildDir
    if $as_root; then chown lfs $buildDir; fi
  else
    if $as_root; then chown lfs $buildDir; fi
  fi
fi
if [[ "$useDESTDIR" = true && "$currentChapter" = chapter08 ]]; then # use DESTDIR
  sed -e 's/make install/make DESTDIR="$CUR_DIR" install/' \
      -e 's/make prefix=\/usr install/make prefix="${CUR_DIR}"\/usr install/' \
      -e 's/-i \/usr\/bin\/ldd/-i "${CUR_DIR}"\/usr\/bin\/ldd/' \
      -i $Output
fi
IFS=$IFSOLD # put it back the way it was
} # end Start
#
getMd5sumInfo () {
# returns information from the md5sums file
# if $1 is "pkgVers", returns the package version
# if $1 is "patchName", returns the patch name
# $2 is the array of package names and patch names from the md5sums file
# $3 is the search string to find the required package name or patch name
local srcFile patchName
local searchStr=$3
if [ -z "$3" ]; then return $RETURN_PARAM; fi
# check if the array of package and patch names is given
if [ ! -z "$2" ]; then
  local SrcName=$2[@]
  local srcname=("${!SrcName}")
  if [ "$1" = pkgVers ]; then
    for srcFile in ${srcname[@]}; do
      case $srcFile in
         $searchStr)
           rtrvers=""
           GetPkgVersion "" $srcFile ".tar"
           if [ "$?" = 0 ]; then
             echo $rtrvers
             break
           else
             echo "return value from GetPkgVersion is $?"
             echo "Investigate why this didn't work"
             exit 1
           fi
           break
         ;;
      esac
    done
  elif [ "$1" = patchName ]; then
    for srcFile in ${srcname[@]}; do # need the name of the patch
      case $srcFile in
         $searchStr)
           patchName=$srcFile
           echo "$patchName"
           break
         ;;
      esac
    done
  else # $1 not either pkgVers or patchName, abort
    return $RETURN_PARAM
  fi
else
  return $RETURN_PARAM
fi
} # end getMd5sumInfo
#
getPatchName () {
# if the patch is to be downloaded at install time, then need the patch name
# this is obtained from the md5sums file
# $1 is the source name array
# $2 is the search string for the patch file e.g. bzip2-*.patch
# if present $3 is the location of the dir containing the source files and patches
local SrcName=$1[@]
local srcname=("${!SrcName}")
local searchName=$2
local sourceDir=${3:-""}
local patchName=""
if [ ! -z "$sourceDir" ]; then # use the source directory
  rtrvers=""
  GetPkgVersion $sourceDir $searchName "" patch returnName
  patchName=$rtrvers
  echo "$patchName"
else # use the srcname array
  for srcFile in ${srcname[@]}; do # need the name of the patch
    case $srcFile in
       $searchName)
         patchName=$srcFile
         echo "$patchName"
         break
       ;;
    esac
  done
fi
if [ -z "$patchName" ]; then # didn't find the patch name - return error
  return $RETURN_PARAM
else # patch file found
  return 0
fi
} # end getPatchName
#
getLatestKernel () {
# get the latest kernel from the website
local URLtoUse="https://www.kernel.org"
declare -a klines=($(python3 BShref.py $URLtoUse))
if [ "$?" != 0 ]; then return $RETURN_PARAM; fi
#
local kernelURL=${klines[0]}
kernSrcFile=${kernelURL##*/} # global
rtrvers=""
kernLatestVers=""
GetPkgVersion "" $kernSrcFile ".tar"
if [ "$?" = 0 ]; then
  if [ ! -z "$rtrvers" ]; then
    kernLatestVers=$rtrvers # global
    return 0
  else
    msg "rtrvers is NULL. Can't get the kernel version"
    msg "Investigate why this failed"
  fi
else
   msg "return value for kernel vers from GetPkgVersion is $? It should be zero"
   msg "Investigate why this didn't work"
fi
return $RETURN_OTHER_ERR
} # end getLatestKernel
#
#**********************************************************************************
#
# main program
#
#**********************************************************************************
# check if the user lfs exists on the target machine
if [ -e ${LFS}/etc/passwd ]; then
  chklfs=$(grep -c '^lfs:' ${LFS}/etc/passwd)
  if [ $chklfs -eq 1 ]; then
# get the uid
    useThisUID=$(grep '^lfs:' ${LFS}/etc/passwd | awk -F\: '{print $3}')
  else
    useThisUID="lfs" 
  fi
fi
configEdit # option to change the config file
source $cfg # maybe config edited - update the values
# useproxy
useProxy=false
if [ "$USEPROXY" = yes ]; then useProxy=true; fi
#
single_package=false
if [ "$SINGLE_PACKAGE" != no ]; then single_package=true; fi
#
# check DESTDIR and MAKE_KERNEL
if $single_package; then
  if [[ "$SINGLE_PACKAGE" == kernel && "$MAKE_KERNEL" == no ]]; then
    echo "SINGLE_PACKAGE is set to kernel and MAKE_KERNEL is no"
    echo "This will do nothing"
    echo "Set MAKE_KERNEL=yes and make sure the .config file has been"
    echo "copied to $SOURCEDIR"
    exit 1
  fi
fi
# check SOURCES and UPDATESRCFILES
if [[ "$SOURCES" = atinstall && "$UPDATESRCFILES" = yes ]]; then
  echo "You've set SOURCES = atinstall. The sources will be downloaded using the"
  echo "md5sums file from the book. These are the latest versions"
  echo "UPDATESRCFILES will be set to no"
  UPDATESRCFILES=no
fi
#
installKernel=false
if [ "$MAKE_KERNEL" = yes ]; then # check the .config file is in place
  if [ ! -e ${SOURCEDIR}/.config ]; then
    echo "MAKE_KERNEL is yes but the Kernel .config file is not in $SOURCEDIR"
    echo "Place it there to continue or set MAKE_KERNEL=no"
    exit 1
  else
    installKernel=true
    if [ "$WHICH_CHAPTER" = chapter10 ]; then
      echo "The .config file is in $SOURCEDIR so the kernel will be installed"
    elif [ "$WHICH_CHAPTER" = update ]; then
      echo "The .config file is in $SOURCEDIR so the kernel will be updated"
    else
      echo "MAKE_KERNEL is set to yes so WHICH_CHAPTER should be either"
      echo "chapter10 or update, but it is $WHICH_CHAPTER"
      echo "Use chapter10 if this is a fresh install"
      echo "Use update if a kernel is installed and you are updating it"
      echo "Either change WHICH_CHAPTER or set MAKE_KERNEL to no"
      echo "if you actually want $WHICH_CHAPTER."
      echo "Aborting"
      exit 1
    fi
  fi
fi
if $single_package; then
  if [ "$DESTDIR" = no ]; then
    echo "The SINGLE_PACKAGE option is meant to be used with DESTDIR"
    echo "in order to create a binary package tarfile for $SINGLE_PACKAGE"
    echo "Will set DESTDIR=yes and continue"
    DESTDIR="yes"
  fi
fi
useDESTDIR=false
if [ "$DESTDIR" = yes ]; then useDESTDIR=true; fi
#
# check for install from DESTDIR
installDEST=false
if [ "$INSTALLDEST" = yes ]; then # DESTDIR must be yes
  if ! $useDESTDIR; then
    echo "You have requested to install from files created by DESTDIR but DESTDIR=no"
    echo "DESTDIR will be set to yes for this to work. INSTALLDEST takes precedence"
    DESTDIR=yes
    useDESTDIR=true
  fi
  installDEST=true
fi
# check CLEAN_SRC_DIR and SINGLE_PACKAGE
if [[ "$CLEAN_SRC_DIR" == no ]]; then
  if [[ "$single_package" == true && "$useDESTDIR" == true ]]; then # will clean the src dir
    echo "You've chosen to create a package binary from $SINGLE_PACKAGE"
    echo "but CLEAN_SRC_DIR is set to no. This must be set to yes to continue"
    CLEAN_SRC_DIR=yes
  fi
fi
echo "CLEAN_SRC_DIR is $CLEAN_SRC_DIR"
#
as_root=false
if [ "$AS_ROOT" = yes ]; then # make sure lfs can write to BuildLog if not updating
  as_root=true
  if [ "$WHICH_CHAPTER" != update ]; then chown lfs ${LFS}/${BuildLog}; fi
else # root is owner of BuildLog when installing as a pkguser
  chown root:install ${LFS}/${BuildLog}
  chmod 664 ${LFS}/${BuildLog}
fi
wgetlist=$WGETLISTNAME # the name of the wget-list file
#
# set up the script filenames
# first initialize them to null
ch5script=""
ch6script=""
ch7asroot=""
ch7chroot=""
ch7script=""
ch8script=""
ch10script=""
updateScript=""
# set the scipt names
ch5script="chapter05.sh"
ch6script="chapter06.sh"
ch7asroot="chapter07-asroot.sh"
ch7chroot="chapter07-chroot.sh"
ch7script="chapter07.sh"
ch8script="chapter08.sh"
ch10script="chapter10.sh"
updateScript="update.sh"
WHICH_CHAPTER=$(echo ${WHICH_CHAPTER,,*}) # make sure it's lower case
# check the chapter name
case $WHICH_CHAPTER in
   chapter05|chapter06|chapter07|chapter08|chapter10|update)
     : # continue
   ;;
   *)
     echo "Invalid value for WHICH_CHAPTER. $WHICH_CHAPTER not allowed"
     echo "Should be one of chapter05, chapter06, chapter07, chapter08, chapter10, or update"
     echo "Exiting now"
     exit 1
   ;;
esac
# check untested combinations
if [[ "$AS_ROOT" = yes && "$SOURCES" = atinstall ]]; then
  echo "*** WARNING ***"
  echo "You've chosen to install as root and to download the sources at install time"
  echo "This combination is untested and is likely not to work"
  echo "Do you wish to continue [y/N]?"
    read REPLY
    case $REPLY in
       [yY]|[yY][Ee][Ss])
          echo "Okay, continuing"
       ;;
       [nN]|[nN][Oo])
          echo "Okay, aborting"
          exit 1
       ;;
       *)
          echo "Okay, aborting"
          exit 1
       ;;
    esac
fi
#
# get the requested book
#
haveCommands=false
bookDir=$LFS_BOOK_GIT_LOC_DIR
version=$BOOK_VERSION
# set version properly
case $version in
   */)
     version=${version%?} # remove trailing / if present
   ;;
   SYSTEMD|Systemd|systemd) # not okay - abort
     echo "The book version should not be systemd."
     echo "To use systemd, set BOOK_VERSION=trunk and SYSTEMD=yes in the menu."
     exit 1
   ;;
   Current_Development|trunk)
     version="trunk"
   ;;
esac
if [ ! -d $bookDir ]; then mkdir -pv $bookDir; fi
if [ "$BOOK_ORIGIN" = git ]; then # download the book regardless of whether one exists
  if [ -d "${bookDir}/${trunkDIR}" ]; then rm -rf -v ${bookDir}/${trunkDIR}; fi
# download the book - check if git is installed on the host
    if [ -e "/usr/bin/git" ]; then
      git clone "${GIT_URL}/lfs.git" "${bookDir}/${trunkDIR}/lfs"
      echo "need to make the requested version current"
    else
      echo "you will have to install git on the host"
      echo "Abort"
      exit 1
    fi
elif [ "$BOOK_ORIGIN" = local ]; then # check if the commands are in place
  whichChapter=$WHICH_CHAPTER
  if [ "$whichChapter" = update ]; then # need to test chapter08
    whichChapter="chapter08"
  fi
  if [ -d "${DumpedCommands}/${whichChapter}" ]; then # lfs-commands dir exists, check if empty
    if [ "$(ls -A ${DumpedCommands}/${whichChapter})" ]; then
      haveCommands=true
    else
      msg "The directory ${DumpedCommands}/${whichChapter} is empty"
      msg "Did you download the book?"
      msg "Aborting"
      exit 1
    fi
  elif [ -d "${bookDir}/${trunkDIR}/lfs" ]; then # book present
    echo "local book found at ${bookDir}/${trunkDIR}/lfs"
    if [ "$version" != blank ]; then
      echo "will make sure the requested version $version is current"
    else # blank
      echo "choose which book version to use"
    fi
  else
    echo "No commands found for $whichChapter"
    echo "You need to download the book commands"
    echo "Aborting"
    exit 1
  fi
else
  echo "BOOK_ORIGIN should be git or local, but it is $BOOK_ORIGIN"
  echo "Aborting"
  exit 1
fi
# if got here then a book is in place and/or commands exist in lfs-commands on the target machine
if ! $haveCommands; then # need to dump the commands from the book
# need to make the requested version current
  foundVersion=false
  if [ "$version" != blank ]; then
# is the requested branch already available?
    pushd "${bookDir}/${trunkDIR}/lfs" > /dev/null
      branches=$(git branch)
      echo "branches is $branches"
      for branch in $branches; do
        case $branch in
           *$version) # make sure it is set
             git checkout $version
             foundVersion=true
             break
           ;;
        esac
      done
    popd > /dev/null
    if ! $foundVersion; then
      pushd "${bookDir}/${trunkDIR}/lfs" > /dev/null
        git fetch --all # get access to all the remore branches
        branches=$(git branch -a)
        echo "book branches found are $branches"
        echo "version requested is $version"
# compare existing branches with requested book version
        for branch in $branches; do
          case $branch in
             *$version) # make sure it is set
               git checkout $version
               foundVersion=true
               break
             ;;
          esac
        done
        if ! $foundVersion; then
          echo "didn't find $version in remote branches - investigate"
          echo "Abort"
          exit 1
        fi
      popd > /dev/null
    fi
  else # version is blank - ask which version wanted
    WhichLFSBook
    echo "book version requested is $BOOK_VERSION"
    case $BOOK_VERSION in
       Current_Development)
         BOOK_VERSION="trunk"
       ;;
       *)
         if [[ "$BOOK_VERSION" == [0-9]* ]]; then # should be 10.0 or higher
           testIntFloatChar $BOOK_VERSION
           retval=$?
           if [ $retval -eq 89 -o $retval -eq 93 ]; then
             echo "BOOK_VERSION should be a floating point number >= 10.0"
             exit 1
           elif [ $retval -eq 91 ]; then # compare two floats
             if awk "BEGIN {exit !($BOOK_VERSION >= 10.0)}"; then
               echo "Book version $BOOK_VERSION requested" # check if trunk is in place
               if [ -f "${LFS_BOOK_GIT_LOC_DIR}/${trunkDIR}/lfs/.git" ]; then # ok
                 echo "found lfs trunk in ${LFS_BOOK_GIT_LOC_DIR}/${trunkDIR}/lfs - can continue"
                 echo "will git checkout version $BOOK_VERSION"
                 pushd ${LFS_BOOK_GIT_LOC_DIR}/${trunkDIR}/lfs > /dev/null
       	           git checkout $BOOK_VERSION
                 popd > /dev/null
               else
                 echo "didn't find downloaded book in ${LFS_BOOK_GIT_LOC_DIR}/${trunkDIR}/lfs"
                 echo "you need to download the trunk version of the book first"
                 echo "Aborting"
                 exit 1
               fi
             else
               echo "Book version is $BOOK_VERSION, should be 10.0 or higher"
               echo "Aborting"
               exit 1
             fi
           fi
         fi
       ;;
    esac
  fi
# check that lfs: is in the book Makefile
  destin="${LFS_BOOK_GIT_LOC_DIR}/${trunkDIR}/lfs"
  if grep -q "lfs:" "${destin}/Makefile"; then
    echo "the string \"lfs\" is in ${destin}/Makefile"
  else
    sed -i '/book:/i lfs: book wget-list\n' "${destin}/Makefile"
  fi
# and remove the # from commented-out dump-commands
  lineStart=$(grep -nr "#dump-commands" "${destin}/Makefile" | cut -d : -f1)
  if [ ! -z "$lineStart" ]; then
    lineEnd=$((lineStart+14))
#    echo "lineStart is $lineStart"
#    echo "lineEnd is $lineEnd"
    sed -i "${lineStart},${lineEnd} s/^#//" "${destin}/Makefile"
  fi
#
  DumpCommands $REPO $bookDir "trunk" #parse the LFS xml
#
fi # test haveCommands is false
# if chapter06 and installing as pkguser, add additional commands for openssl and wget
retVal=1
if [[ "$WHICH_CHAPTER" = chapter06 && "$as_root" = false ]]; then
  declare -a opensslComs
  opensslComs[0]="./config --prefix=/usr         \\"
  opensslComs[1]="         --openssldir=/etc/ssl \\"
  opensslComs[2]="         --libdir=lib          \\"
  opensslComs[3]="         shared"
  opensslComs[4]="sed -i '/install_docs:/s/install_man_docs install_html_docs//' Makefile"
  opensslComs[5]="make"
  opensslComs[6]="sed -i '/INSTALL_LIBS/s/libcrypto.a libssl.a//' Makefile"
  opensslComs[7]="make DESTDIR=\$LFS MANSUFFIX=ssl install"
  addCommands "openssl" "058" "chapter06" opensslComs[@]
  retVal=$?
  if [ $retVal -eq $RETURN_PARAM ]; then
    echo "didn't find $LFS/lfs-commands/chapter06"
    echo "did you download the book?"
    echo "*** failed to add the commands for openssl"
    echo "Investigate why this failed"
  else
    echo "Commands for openssl are in ${LFS}/lfs-commands/chapter06"
  fi
  declare -a wgetComs
  wgetComs[0]="PKG_CONFIG_PATH=\$LFS/usr/lib/pkgconfig    \\"
  wgetComs[1]="./configure --prefix=/usr                 \\"
  wgetComs[2]="            --sysconfdir=/etc             \\"
  wgetComs[3]="            --with-ssl=openssl            \\"
  wgetComs[4]="            --without-libpsl              \\"
  wgetComs[5]="            --without-zlib                \\"
  wgetComs[6]="            --disable-iri                 \\"
  wgetComs[7]="            --disable-pcre                \\"
  wgetComs[8]="            --disable-pcre2               \\"
  wgetComs[9]="            --host=\$LFS_TGT               \\"
  wgetComs[10]="            --build=\$(build-aux/config.guess)"
  wgetComs[11]="make"
  wgetComs[12]="make DESTDIR=\$LFS install"
  addCommands "wget" "059" "chapter06" wgetComs[@]
  retVal=$?
  if [ $retVal -eq $RETURN_PARAM ]; then
    echo "didn't find $LFS/lfs-commands/chapter06"
    echo "did you download the book?"
    echo "*** failed to add the commands for wget"
    echo "Investigate why this failed"
  else
    echo "Commands for wget are in ${LFS}/lfs-commands/chapter06"
  fi
elif [[ "$WHICH_CHAPTER" = update ]]; then
  if [[ "$SINGLE_PACKAGE" = "linux-headers" ]]; then
# add commands to chapter08 for linux-headers (installed in chapter05)
    declare -a comsToAdd
    comsToAdd[0]="make mrproper"
    comsToAdd[1]="make headers"
    comsToAdd[2]="find usr/include -name '.*' -delete"
    comsToAdd[3]="rm usr/include/Makefile"
    comsToAdd[4]="cp -rv usr/include /usr"
    addCommands "linux-headers" "071" "chapter08" comsToAdd[@]
    retVal=$?
    if [ $retVal -eq $RETURN_PARAM ]; then
      echo "didn't find $LFS/lfs-commands/chapter08"
      echo "did you download the book?"
      echo "*** failed to add the commands for linux-headers ***"
      echo "Investigate why this failed"
    elif [[ $retVal -eq 0 ]]; then
      echo "Commands for linux-headers are in ${LFS}/lfs-commands/chapter08"
    fi
  fi
fi
# set isSystemdBook
isSystemdBook=false # use sysv
VersToCompare=10.0 # first book that will work here
if [ "$SYSTEMD" = yes ]; then
  if [ "$version" = trunk ]; then
    isSystemdBook=true
  else
    compare_versions $VersToCompare $version "."
    ret_val=$?
    if [ $ret_val -eq 0 ]; then
      isSystemdBook=true
    else
      echo "version is set to $version"
      echo "This version will not work with these scripts."
      echo "Abort"
      exit 1
    fi
  fi
fi
echo "isSystemdBook is $isSystemdBook"
# install the pkguser files
pkgFileName="${PKGUSERFILE%.tar*}" # the name of the unpacked package file dir
# check if the ${LFS}/tools/${pkgFileName} dir exists
PKGFILENAME="${LFS}/tools/${pkgFileName}"
if [ ! -d "$PKGFILENAME" ]; then # doesn't exist so try and build it
# is there a tar package file present?
  if [ -e ${LFS}${sourcedir}/${PKGUSERFILE} ]; then # unpack it
    unpackPkguser $PKGUSERFILE
    if [ $? -eq $RETURN_PARAM ]; then # pkguser file failed to unpack
      echo "Package user file $PKGUSERFILE in ${LFS}${sourcedir}"
      echo "failed to unpack. Is it a tarfile?"
      echo "Exiting now"
      exit 1
    fi
  else
    echo "The tarfile $PKGUSERFILE should be in ${LFS}/${sourcedir}"
    echo "Please place it there in order to continue"
    echo "Exiting now"
    exit 1
  fi
else # the dir $PKGFILENAME exists - test if the tafile is present
  if [ -e ${LFS}${sourcedir}/${PKGUSERFILE} ]; then # ask if want to replace the build files
    echo "**Warning** - $PKGUSERFILE present and $PKGFILENAME exists."
    echo "Replace $PKGFILENAME with the contents of $PKGUSERFILE? [Y/n]"
    read reply
      case $reply in
         [nN]|[nN][Oo])
            echo "okay - continuing with existing $PKGFILENAME"
         ;;
         *)
            echo "okay replacing $PKGFILENAME"
            echo "will rm PKGFILENAME and remake it"
            rm -rf $PKGFILENAME
            mkdir -pv $PKGFILENAME
            unpackPkguser $PKGUSERFILE
         ;;
      esac
  else # PKGFILENAME exists
    echo "pkguser dir $PKGFILENAME exists"
  fi
fi
#
# get the sources
#
wgetopts=""
ncc="--no-check-certificate"
# is a proxy server being used?
if $useProxy; then
# test if squid is present
  if [ -e /usr/bin/squid ]; then
# first set the proxy values - assumes port 3128
#
    ipaddr=$( /sbin/ip addr | grep "192.168" | awk '{print $2}' | awk -F\/ '{print $1}' )
    proxyset=http://${ipaddr}:3128/
    http_proxy=$proxyset
    ftp_proxy=$proxyset
    https_proxy=$proxyset
    wgetopts="-e http_proxy=$http_proxy -e ftp_proxy=$ftp_proxy -e https_proxy=$https_proxy"
  else # squid not installed
    useProxy=false
  fi
fi # end test useProxy
# declare a global array to hold any missing src file names
declare -a filesNotPresent
#
version=${version%/} # remove any trailing /
SourceDir=${SOURCEDIR}/${version}
sourceloc=${sourcedir}/${version} # location wrt lfs system
WgetList=${SourceDir}/${wgetlist}
if [ ! -e $WgetList ]; then
  echo "wget-list file $WgetList doesn't exist"
  echo "will get it from the book" 
fi
#
# if SINGLE_PACKAGE requested, check if the package src file is in the wget-list file
# if it isn't, try and download it
#
if $single_package; then
  case $SINGLE_PACKAGE in
     linux-headers)
       filesNotPresent[0]=linux
     ;;
     kernel)
       filesNotPresent[0]=linux
     ;;
     xml-parser)
       filesNotPresent[0]=XML-Parser
     ;;
     *)
       filesNotPresent[0]=$SINGLE_PACKAGE
     ;;
  esac 
  rtrnName=""
  if [ ! -e $WgetList ]; then
    echo "$WgetList file doesn't exist"
    echo "You need to download the source for $SINGLE_PACKAGE and place in $SourceDir"
  else # wget-list in place so check single package exists
    if [ "$SOURCES" != atinstall ]; then
#      echo "filesNotPresent is ${filesNotPresent[@]}"
      ChkPkgExists $WgetList filesNotPresent[@]
      retval=$?
      if [ $retval -eq $RETURN_PARAM ]; then # wget-list file doesn't exist
        echo "No $WgetList file present"
        echo "Will download the source for ${filesNotPresent[0]}"
      elif [ $retval -eq $RETURN_FNF ]; then
        echo "${filesNotPresent[0]} not found in $WgetList"
        echo "Check the package name"
        exit 1
      else
        filesNotPresent[0]=$rtrnName
      fi
    fi
  fi
# check if source(s) already downloaded
  if [ "$SOURCES" = download ]; then
#    echo "single package is ${filesNotPresent[0]}"
    if [ ! -d $SourceDir ]; then install -v -m0755 -d $SourceDir; fi
    if [ "$CLEAN_SRC_DIR" = yes ]; then CleanSourceDir $SourceDir $WgetList; fi
    if [ -e $WgetList ]; then
      ChkSrcPresent $SourceDir $WgetList filesNotPresent[@]
      ret_val=$?
      if [ $ret_val -eq 0 ]; then
        echo "Package ${filesNotPresent[0]} present in $SourceDir"
        echo "Continuing without downloading ${filesNotPresent[0]}"
      else
        echo "Package file ${filesNotPresent[0]} not present in $SourceDir"
        echo "Will download it using $WgetList file"
        if hash wget 2>/dev/null; then
           GetSource $version $SourceDir $WgetList $bookDir filesNotPresent[@] # download LFS sources
        else
           echo "The host does not have wget installed."
           echo "Please install it in order to download the source(s)."
           echo "Exiting now."
           exit 1
        fi
      fi
    else # no wget-list present so need to get it
      if hash wget 2>/dev/null; then
        GetSource $version $SourceDir $WgetList $bookDir filesNotPresent[@] # download LFS sources
      else
         echo "The host does not have wget installed."
         echo "Please install it in order to download the source(s)."
         echo "Exiting now."
         exit 1
      fi
    fi
  elif [ "$SOURCES" != atinstall ]; then # source is local - check it's there
    echo "Checking if source file is in $SourceDir"
    if [ ! -d $SourceDir ]; then
      echo "You have said that the source is local but"
      echo "directory $SourceDir does not exist"
      echo "Change the config file to make SOURCES = 'download'"
      echo "or download it yourself and place in $SourceDir"
      echo "Will continue to write the requested script."
    fi
    if [ ! -e $WgetList ]; then
      echo "No $WgetList file present in $SourceDir"
      echo "Won't be able to check if the source file exists"
    else
      ChkSrcPresent $SourceDir $WgetList filesNotPresent[@] # check for src file present
      ret_val=$?
      if [ $ret_val -eq $RETURN_PARAM ]; then
        echo "Requested file ${filesNotPresent[0]} has not been downloaded"
        echo "Can download it and place in $SourceDir"
        echo "Do you wish to continue? (Y/n)"
        read reply
        case $reply in
          [nN]|[nN][Oo])
            echo "Exiting now"
            exit 1
          ;;
          *)
            echo "okay will download the source file"
# TODO download the single_package file here
          ;;
        esac
      else
        echo "Source file ${filesNotPresent[0]} present in $SourceDir"
      fi
    fi
  else
    msg "SOURCES=atinstall Will check that the wget-list and md5sums files are present"
#    msg "filesNotPresent is ${filesNotPresent[0]}"
    if [ ! -d $SourceDir ]; then install -v -m0755 -d $SourceDir; fi
    if [ ! -e $WgetList ]; then
      msg "the wget-list file $WgetList doesn't exist. Download it from the book"
    else
      msg "wget-list file $WgetList is in place"
    fi
    md5sums=${SourceDir}/md5sums
    if [ ! -e $md5sums ]; then
      msg "the md5sums file $md5sums doesn't exist. Download it from the book"
    else
      msg "md5sums file $md5sums is in place"
    fi
  fi
  # check if the file is empty
  if [ "$SOURCES" != atinstall ]; then
    ChkEmptySrcFiles $SourceDir ${filesNotPresent[0]} #check for failed downloads
    return_val=$?
    if [ "$return_val" -eq $RETURN_FNF ]; then
      echo "Source file ${filesNotPresent[0]} not found in $SourceDir"
      echo "Check why it's not there"
      exit 1
    elif [ "$return_val" -eq $RETURN_PARAM ]; then
      echo "Source file ${filesNotPresent[0]} is empty."
      echo "You need to download this file and place it in $SourceDir"
      echo "before running the script"
    fi
  fi
else # all sources requested
  downloadSrc=false
  if [ ! -d $SourceDir ]; then install -v -m0755 -d $SourceDir; fi
  if [ "$SOURCES" = atinstall ]; then # need the wget-list file and the md5sums
    if [ ! -e $WgetList ]; then # wget-list doesn't exist, get it from the book
      REPODIR="${bookDir}/${trunkDIR}/lfs"
      make -j1 -f ${REPODIR}/Makefile -C $REPODIR BASEDIR=$SourceDir REV="systemd" $WgetList ${SourceDir}/md5sums
      md5sums=${SourceDir}/md5sums
    else
      echo "$WgetList file exists"
# make sure the md5sums file is present too
      if [ ! -e  ${SourceDir}/md5sums ]; then # get it from $LFS/lfs-html
	echo "the md5sums file isn't present in $SourceDir"
	echo "will copy it from $LFS/lfs-html"
	cp -v $LFS/lfs-html/md5sums ${SourceDir}/md5sums
	md5sums=${SourceDir}/md5sums
      else
        echo "md5sums file found in $SourceDir"
	md5sums=${SourceDir}/md5sums
      fi
    fi
  elif [ "$SOURCES" = download ]; then
    downloadSrc=true 
    if [ "$CLEAN_SRC_DIR" = yes ]; then CleanSourceDir $SourceDir $WgetList; fi
# check if src dir is not empty and the wgetlist file is already in place
#    if [[ "$(ls -A $SourceDir)" && -e $WgetList ]]; then
    if [ -e $WgetList ]; then
      ChkSrcPresent $SourceDir $WgetList filesNotPresent[@] # check for src files present
      ret_val=$?
      if [ $ret_val -eq 0 ]; then # all files are present
        echo "You requested 'download' for the sources"
        echo "but they are already present in $SourceDir"
        if [ "$UPDATESRCFILES" = yes ]; then
          echo "Will download any more-recent source files and update $WgetList."
        else
          echo "Continuing without updating any source files."
        fi
        downloadSrc=false
      else
        echo "Will download the following files:"
        for (( i=0; i<${#filesNotPresent[@]}; i++ )); do
          echo ${filesNotPresent[i]}
        done
      fi
    fi
    if [ "$UPDATESRCFILES" = yes ]; then
      if [ -e ${WgetList} ]; then
        GetLatestVers $WgetList "lfs-systemd" true false # download latest source files and update wget-list
      else
        echo "You've requested an update of the source files but there is no existing file $WgetList"
        echo "Cannot update source versions without this file"
      fi
    fi
    if $downloadSrc; then
      echo "Will use wget to download the sources"
      if hash wget 2>/dev/null; then
         GetSource $version $SourceDir $WgetList $bookDir filesNotPresent[@] # download LFS sources
# now search for any older versions of the downloaded files and offer to delete them
         for chkFiles in ${filesNotPresent[@]}; do
#echo "downloaded file is $chkFiles"
           pkgnmOnly=$(GetPkgName $chkFiles) 
           GetPkgVersion $SourceDir $pkgnmOnly- .tar
           generalfname=${pkgnmOnly}*.tar.*z* # NOTE amend for fname without tar
           olderVers=( $(ls -l ${SourceDir}/${generalfname} | awk -F\/ '{print $NF}') )
           numoldvers=${#olderVers[@]}
           if [ $numoldvers -eq 1 ]; then # only one version present - good, do nothing
             :
           elif [ $numoldvers -gt 1 ]; then
             echo "There is more than one version of package $pkgnmOnly in $SourceDir"
             for (( ik=0; ik < $numoldvers; ik++ )); do
               if [ "${olderVers[ik]}" != "$chkFiles" ]; then # delete it?
                 echo "Do you want to delete ${olderVers[ik]} (Default is Y)"
                 read reply
                 case $reply in
                    [yY]|[yY][Ee][Ss])
                        rm -v ${SourceDir}/${olderVers[ik]}
                    ;;
                    [nN]|[nN][Oo])
                        echo "okay, ${SourceDir}/${olderVers[ik]} left in place"
                    ;;
                    *)
                        rm -v ${SourceDir}/${olderVers[ik]}
                    ;;
                 esac
               fi
             done
           elif [ $numoldvers -eq 0 ]; then # HELP something's gone wrong
             echo "ERROR - numoldvers=0 . This should never happen. ABORT"
             exit 1
           fi
         done
      else
         echo "The host does not have wget installed."
         echo "Please install it in order to download the sources."
         echo "Exiting now."
         exit 1
      fi
    fi
    ChkEmptySrcFiles $SourceDir # check for failed downloads
    return_val=$?
    if [ "$return_val" -eq $RETURN_FNF ]; then
      echo "Source file ${filesNotPresent[0]} not found in $SourceDir"
      echo "Check why it's not there"
      exit 1
    elif [ "$return_val" -eq $RETURN_PARAM ]; then
      echo "Empty source files found in $SourceDir"
      echo "You need to download these and place them in $SourceDir"
      echo "before running the scripts"
    fi
  else # sources are local - check if update of source files is requested
    echo "Checking if sources are in $SourceDir"
    if [ ! -d $SourceDir ]; then
      echo "You have said that the sources are local but"
      echo "directory $SourceDir does not exist"
      echo "Change the config file to make SOURCES=download"
      echo "or download them yourself and place in $SourceDir"
      echo "Will continue to write the requested script(s)."
    fi 
    if [ ! -e $WgetList ]; then
      echo "No $WgetList file present in $SourceDir"
      echo "Won't be able to check if LFS sources exist"
      if [ "$UPDATESRCFILES" = yes ]; then
        echo "Won't be able to update the sources files"
      fi
    else # wget-list file exists
      if [ "$UPDATESRCFILES" = yes ]; then
        GetLatestVers $WgetList "lfs-systemd" true false # download latest source files and update wget-list
      fi
      ChkSrcPresent $SourceDir $WgetList filesNotPresent[@] # check for src files present
      ret_val=$?
      if [ $ret_val -eq $RETURN_PARAM ]; then 
        echo "Not all requested files in $WgetList have been downloaded"
        echo "You will have to download those that are missing and place them in $SourceDir"
        echo "Do you wish to continue? (Y/n)"
        read reply
        case $reply in
          [yY]|[yY][Ee][Ss])
            echo "okay continue"
          ;;        
          [nN]|[nN][Oo])
            echo "Exiting now"
            exit 1
          ;;        
          *)   
            echo "okay continue"
          ;;        
        esac
      fi
    fi
# check if $SourceDir exists and has files in it
    if [ -d $SourceDir ]; then
      if [ "$(ls -A $SourceDir)" ]; then # has files
        ChkEmptySrcFiles $SourceDir # check for failed downloads
        return_val=$?
        if [ "$return_val" -eq $RETURN_FNF ]; then
          echo "Source file ${filesNotPresent[0]} not found in $SourceDir"
          echo "Check why it's not there"
          exit 1
        elif [ "$return_val" -eq $RETURN_PARAM ]; then
          echo "Empty source files found in $SourceDir"
          echo "You need to download these and place them in $SourceDir"
          echo "before running the scripts"
        fi
      fi
    else
      echo "Source Dir $SourceDir doesn't exist. Will create it"
      mkdir -pv $SourceDir
    fi
  fi
fi
if [ -d $SourceDir -a "$(ls -A $SourceDir)" ]; then # source dir exists and has files in it
  if $single_package; then
    listPkgs=($SINGLE_PACKAGE)
  else # get src versions for all the following plus any patch file names
    listPkgs=(binutils bzip2 coreutils dbus gcc glibc gmp kbd kernel mpc mpfr perl python3 shadow
	    systemd util-linux xz zstd)
  fi
  if [ ! -f $WgetList ]; then
    echo "The required wget-list file does not exist"
    echo "You need the file $WgetList in order to continue"
    echo "Aborting"
    exit 1
  fi
# read the contents of the wget-list file into a variable for the src downloads
  sourceURL="$(<"$WgetList")"
#  echo "sourceURL is ${sourceURL[@]}"
  if [[ "$SOURCES" = atinstall ]]; then
    if [ ! -f $md5sums ]; then
      echo "The required md5sums file does not exist"
      echo "You need the file $md5sums in order to continue"
      echo "Aborting"
      exit 1
    fi
# read the contents of the md5sums file into a variable to get pkg versions
    srcFileName="$(<"$md5sums")"
#    echo "srcFileName is ${srcFileName[@]}"
    echo "Requested source files downloaded at install time."
    echo "The src package versions will come from the md5sums file,"
    echo "not from the actual src tarfiles."
  fi
# get the required package versions and patch filenames
  for (( i=0; i<${#listPkgs[@]}; i++ )); do
#msg "listPkgs is ${listPkgs[i]}"
    case ${listPkgs[i]} in
       binutils)
         patchSearch='*binutils*.patch*'
         if [ "$SOURCES" = atinstall ]; then # use md5sums
           binutilsPatch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
         else # use the src dir
            binutilsPatch=$(getPatchName "" $patchSearch $SourceDir)
            binutilsPatch=${binutilsPatch##*/} # just the filename
         fi
         ret_val=$?
         if [ $ret_val -eq $RETURN_PARAM ]; then
           echo "failed to get binutils patch name"
           echo "*** Investigate ***"
         else
           echo "binutils patch is $binutilsPatch"
         fi
       ;;
       bzip2)
         patchSearch='*bzip2*.patch*'
         if [ "$SOURCES" = atinstall ]; then # use md5sums
           bzip2Patch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
         else # use the src dir
           bzip2Patch=$(getPatchName "" $patchSearch $SourceDir)
           bzip2Patch=${bzip2Patch##*/} # just the filename
         fi
         ret_val=$?
         if [ $ret_val -eq $RETURN_PARAM ]; then
           echo "failed to get bzip2 patch name"
           echo "*** Investigate ***"
         else
           echo "bzip2 patch is $bzip2Patch"
         fi
         searchStr="*bzip2-*"
         bzip2vers=""
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           bzip2vers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
           if [ ! -z "$bzip2vers" ]; then
             echo "bzip2 version is $bzip2vers"
           else
             echo "return value for bzip2 is $?"
             echo "Investigate why this didn't work"
             exit 1
           fi
         else
           rtrvers=""
           GetPkgVersion $SourceDir bzip2- .tar
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "*** Directory $SourceDir doesn't exist ***"
           elif [ $retval -eq $RETURN_FNF ]; then
             echo "*** No file found containing the name bzip2- and tar found ***"
           elif [ $retval -eq $RETURN_MTOV ]; then
             echo "*** More than one version of bzip2- found in $SourceDir ***"
           elif [ $retval -eq 0 ]; then
             bzip2vers=$rtrvers
             if [ ! -z "$bzip2vers" ]; then echo "bzip2 version is $bzip2vers"; fi
           fi
         fi
       ;;
       coreutils) # there is 1 patch for coreutils
         patchSearch1='*coreutils*i18n*.patch*'
         if [ "$SOURCES" = atinstall ]; then # use md5sums
           coreutilsPatch1=$(getMd5sumInfo "patchName" srcFileName $patchSearch1)
         else # use the src dir
           coreutilsPatch1=$(getPatchName "" $patchSearch1 $SourceDir)
           coreutilsPatch1=${coreutilsPatch1##*/} # just the filename
         fi
         ret_val=$?
         if [ $ret_val -eq $RETURN_PARAM ]; then
           echo "failed to get coreutils patch name"
           echo "*** Investigate ***"
         else
           echo "coreutils patch is $coreutilsPatch1"
         fi
#         patchSearch2='*coreutils*chmod*.patch*' # no longer needed 05/2022
#         if [ "$SOURCES" = atinstall ]; then # use md5sums
#           coreutilsPatch2=$(getMd5sumInfo "patchName" srcFileName $patchSearch2)
#         else # use the src dir
#           coreutilsPatch2=$(getPatchName "" $patchSearch2 $SourceDir)
#           coreutilsPatch2=${coreutilsPatch2##*/} # just the filename
#         fi
#         ret_val=$?
#         if [ $ret_val -eq $RETURN_PARAM ]; then
#           echo "failed to get coreutils patch name"
#           echo "*** Investigate ***"
#         else
#           echo "coreutils patch is $coreutilsPatch2"
#         fi
       ;;
       dbus)
         searchStr="*dbus-*"
         dbusvers=""
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           dbusvers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
           if [ ! -z "$dbusvers" ]; then
             echo "dbus version is $dbusvers"
           else
             echo "return value for dbus is $?"
             echo "Investigate why this didn't work"
             exit 1
           fi
         elif [ "$SYSTEMD" = yes ]; then # use the src files in $SourceDir
           rtrvers=""
           for srcFile in ${srcFileName[@]}; do
             case $srcFile in
                $searchStr)
                  rtrvers=""
                  dbusvers=""
                  GetPkgVersion "" $srcFile ".tar"
                  if [ "$?" = 0 ]; then
                    dbusvers=$rtrvers
                    if [ ! -z "$dbusvers" ]; then echo "dbus version is $dbusvers"; fi
                  else
                    echo "return value for dbus is $?"
                    echo "Investigate why this didn't work"
                  fi
                  break
                 ;;
             esac
           done
           dbusvers=""
           GetPkgVersion $SourceDir dbus- .tar
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "*** Directory $SourceDir doesn't exist ***"
           elif [ $retval -eq $RETURN_FNF ]; then
             echo "*** No file found containing the name dbus- and tar found ***"
           elif [ $retval -eq $RETURN_MTOV ]; then
             echo "*** More than one version of dbus- found in $SourceDir ***"
           elif [ $retval -eq 0 ]; then
             dbusvers=$rtrvers
             if [ ! -z "$dbusvers" ]; then echo "dbus version is $dbusvers"; fi
           fi
         fi
       ;;
       gcc)
         searchStr="*gcc-*"
         gccvers=""
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           gccvers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
           if [ ! -z "$gccvers" ]; then
             echo "gcc version is $gccvers"
           else
             echo "return value for gcc is $?"
             echo "Investigate why this didn't work"
             exit 1
           fi
         else
           rtrvers=""
           GetPkgVersion $SourceDir gcc- .tar
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "*** Directory $SourceDir doesn't exist ***"
           elif [ $retval -eq $RETURN_FNF ]; then
             echo "*** No file found containing the name gcc- and tar found ***"
           elif [ $retval -eq $RETURN_MTOV ]; then
             echo "*** More than one version of gcc- found in $SourceDir ***"
           elif [ $retval -eq 0 ]; then
             gccvers=$rtrvers
             if [ ! -z "$gccvers" ]; then echo "gcc version is $gccvers"; fi
           fi
         fi
       ;;
       glibc)
         patchSearch='*glibc*.patch*'
         if [ "$SOURCES" = atinstall ]; then # use md5sums
           glibcPatch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
           ret_val=$?
           if [ $ret_val -eq $RETURN_PARAM ]; then
             echo "failed to get glibc patch name"
             echo "*** Investigate ***"
           else
             echo "glibc patch is $glibcPatch"
           fi
# get the glibc pkg version
           searchStr="*glibc-*"
           glibcvers=""
           glibcvers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
           if [ ! -z "$glibcvers" ]; then
             echo "glibc version is $glibcvers"
           else
             echo "return value for glibc is $?"
             echo "Investigate why this didn't work"
             exit 1
           fi
         else # use the source dir to get the pkg version and patch name
           glibcPatch=$(getPatchName "" $patchSearch $SourceDir)
           glibcPatch=${glibcPatch##*/} # just the filename
           ret_val=$?
           if [ $ret_val -eq $RETURN_PARAM ]; then
             echo "failed to get glibc patch name"
             echo "*** Investigate ***"
           else
             echo "glibc patch is $glibcPatch"
           fi
           rtrvers=""
           glibcvers=""
           GetPkgVersion $SourceDir glibc- .tar
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "*** Directory $SourceDir doesn't exist ***"
           elif [ $retval -eq $RETURN_FNF ]; then
             echo "*** No file found containing the name glibc- and tar found ***"
           elif [ $retval -eq $RETURN_MTOV ]; then
             echo "*** More than one version of glibc- found in $SourceDir ***"
           elif [ $retval -eq 0 ]; then
             glibcvers=$rtrvers
             if [ ! -z "$glibcvers" ]; then
               echo "glibc version is $glibcvers"
             else
               echo "Failed to get glibc version"
               echo "You'll need to rectify this or manually edit the script."
             fi
           fi
         fi
# need to know the name of the tzdata file from the commands
         tzdataFile=$(GetLinuxCommandVersion "${LFS}/${lfscommands}/chapter08" "glibc" "tzdata")
         echo "tzdata file is $tzdataFile"
       ;;
       gmp) # need the version if downloading at install time
         searchStr="*gmp-*"
         gmpvers=""
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           gmpvers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
           if [ ! -z "$gmpvers" ]; then
             echo "gmp version is $gmpvers"
           else
             echo "return value for gmp is $?"
             echo "Investigate why this didn't work"
             exit 1
           fi
         else # use source dir
           rtrvers=""
           GetPkgVersion $SourceDir gmp- .tar
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "*** Directory $SourceDir doesn't exist ***"
           elif [ $retval -eq $RETURN_FNF ]; then
             echo "*** No file found containing the name gmp- and tar found ***"
           elif [ $retval -eq $RETURN_MTOV ]; then
             echo "*** More than one version of gmp- found in $SourceDir ***"
           elif [ $retval -eq 0 ]; then
             gmpvers=$rtrvers
             if [ ! -z "$gmpvers" ]; then echo "gmp version is $gmpvers"; fi
           fi
         fi
       ;;
       kbd)
         patchSearch='*kbd*.patch*'
         if [ "$SOURCES" = atinstall ]; then # use md5sums
           kbdPatch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
         else # use the src dir
           kbdPatch=$(getPatchName "" $patchSearch $SourceDir)
           kbdPatch=${kbdPatch##*/} # just the filename
         fi
         ret_val=$?
         if [ $ret_val -eq $RETURN_PARAM ]; then
           echo "failed to get kbd patch name"
           echo "*** Investigate ***"
         else
           echo "kbd patch is $kbdPatch"
         fi
       ;;
       kernel|linux-headers)
         searchStr="*linux-*"
         linuxvers=""
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           linuxvers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
           if [ ! -z "$linuxvers" ]; then
             echo "kernel version from md5sum is $linuxvers"
           else
             echo "return value for kernel is $?"
             echo "Investigate why this didn't work"
             exit 1
           fi
         else
           GetLinuxVersion $SourceDir
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "Unable to get Linux source version."
             echo "No source file found in $SourceDir"
             echo "**Warning** - value of kernel Src version is not set"
           else
             echo "kernel version from the src file is $linuxvers"
           fi
         fi
# get the linux version from the book commands in chapter10
         linuxcomfnd=$(GetLinuxCommandVersion ${LFS}/${lfscommands}/chapter10 "kernel" "vmlinuz")
         retval=$?
         if [ $retval -eq $RETURN_PARAM ]; then
           echo "vmlinuz command not found in ${LFS}/${lfscommands}/chapter10"
           echo "Cannot get the kernel version in the book."
           echo "Will not be able to compare the source version and the book version"
         else
           linuxcomExt="${linuxcomfnd#*-}"
           linuxcomvers="${linuxcomExt%-lfs*}"
           echo "kernel version from the commands is $linuxcomvers"
         fi
         if [ "$linuxvers" != "$linuxcomvers" ]; then
           msg "*** WARNING *** Linux version from the srcfile is different from the book"
         fi
       ;;
       mpc) # need the version if downloading at install time
         searchStr="*mpc-*"
         mpcvers=""
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           mpcvers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
           if [ ! -z "$mpcvers" ]; then
             echo "mpc version is $mpcvers"
           else
             echo "return value for mpc is $?"
             echo "Investigate why this didn't work"
             exit 1
           fi
         else # use source dir
           rtrvers=""
           GetPkgVersion $SourceDir mpc- .tar
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "*** Directory $SourceDir doesn't exist ***"
           elif [ $retval -eq $RETURN_FNF ]; then
             echo "*** No file found containing the name mpc- and tar found ***"
           elif [ $retval -eq $RETURN_MTOV ]; then
             echo "*** More than one version of mpc- found in $SourceDir ***"
           elif [ $retval -eq 0 ]; then
             mpcvers=$rtrvers
             if [ ! -z "$mpcvers" ]; then echo "mpc version is $mpcvers"; fi
           fi
         fi
       ;;
       mpfr) # need the version if downloading at install time
         searchStr="*mpfr-*"
         mpfrvers=""
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           mpfrvers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
           if [ ! -z "$mpfrvers" ]; then
             echo "mpfr version is $mpfrvers"
           else
             echo "return value for mpfr is $?"
             echo "Investigate why this didn't work"
             exit 1
           fi
         else # use source dir
           rtrvers=""
           GetPkgVersion $SourceDir mpfr- .tar
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "*** Directory $SourceDir doesn't exist ***"
           elif [ $retval -eq $RETURN_FNF ]; then
             echo "*** No file found containing the name mpfr- and tar found ***"
           elif [ $retval -eq $RETURN_MTOV ]; then
             echo "*** More than one version of mpfr- found in $SourceDir ***"
           elif [ $retval -eq 0 ]; then
             mpfrvers=$rtrvers
             if [ ! -z "$mpfrvers" ]; then echo "mpfr version is $mpfrvers"; fi
           fi
         fi
       ;;
       perl) # no patch currently (03/2022)
         patchSearch='*perl*.patch*'
         if [ "$SOURCES" = atinstall ]; then # use md5sums
#           perlPatch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
#           ret_val=$?
#           if [ $ret_val -eq $RETURN_PARAM ]; then
#             echo "failed to get perl patch name"
#             echo "*** Investigate ***"
#           else
#             echo "perl patch is $perlPatch"
#           fi
# get the pkg version
           searchStr="*perl-*"
           perlvers=""
           perlvers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
           if [ ! -z "$perlvers" ]; then
             echo "perl version is $perlvers"
             GetSeriesNum $perlvers
             perlseries=$rtrseries
             echo "perl series is $perlseries"
           else
             echo "return value for perl is $?"
             echo "Investigate why this didn't work"
             exit 1
           fi
         else # use the source dir to get the patch name
#           perlPatch=$(getPatchName "" $patchSearch $SourceDir)
#           perlPatch=${perlPatch##*/} # just the filename
#           ret_val=$?
#           if [ $ret_val -eq $RETURN_PARAM ]; then
#             echo "failed to get perl patch name"
#             echo "*** Investigate ***"
#           else
#             echo "perl patch is $perlPatch"
#           fi
           rtrvers=""
           GetPkgVersion $SourceDir perl- .tar
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "*** Directory $SourceDir doesn't exist ***"
           elif [ $retval -eq $RETURN_FNF ]; then
             echo "*** No file found containing the name perl- and tar found ***"
           elif [ $retval -eq $RETURN_MTOV ]; then
             echo "*** More than one version of perl- found in $SourceDir ***"
           elif [ $retval -eq 0 ]; then
             perlvers=$rtrvers
             if [ ! -z "$perlvers" ]; then
               echo "perl version is $perlvers"
               GetSeriesNum $perlvers
               perlseries=$rtrseries
               echo "perl series is $perlseries"
             else # try a different source loc
               if [ -d $LFS/sources/${trunkDIR} ]; then
                 GetPkgVersion $LFS/sources/${trunkDIR} perl- tar
                 perlvers=$rtrvers
                 if [ ! -z "$perlvers" ]; then
                   echo "perl version is $perlvers"
                   GetSeriesNum $perlvers
                   perlseries=$rtrseries
                   echo "perl series is $perlseries"
                 fi
               fi
             fi
           fi
         fi
       ;;
       python3)
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           for srcFile in ${srcFileName[@]}; do
             case $srcFile in
                *Python-*)
                  rtrvers=""
                  pythonvers=""
                  GetPkgVersion "" $srcFile ".tar"
                  if [ "$?" = 0 ]; then
                    pythonvers=$rtrvers
                    if [ ! -z "$pythonvers" ]; then echo "python3 version is $pythonvers"; fi
		    GetSeriesNum $pythonvers
                    pythonseries=$rtrseries
                    echo "python3 series is $pythonseries"
                  else
                    echo "return value from GetPkgVersion for python3 is $?"
                    echo "Investigate why this didn't work"
                  fi
                  break
                 ;;
             esac
           done
         else
           rtrvers=""
           GetPkgVersion $SourceDir Python- .tar
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "*** Directory $SourceDir doesn't exist ***"
           elif [ $retval -eq $RETURN_FNF ]; then
             echo "*** No file found containing the name python- and tar found ***"
           elif [ $retval -eq $RETURN_MTOV ]; then
             echo "*** More than one version of python- found in $SourceDir ***"
           elif [ $retval -eq 0 ]; then
             pythonvers=$rtrvers
             if [ ! -z "$pythonvers" ]; then
               echo "python3 version is $pythonvers"
               GetSeriesNum $pythonvers
               pythonseries=$rtrseries
               echo "python3 series is $pythonseries"
             else # try a different source loc
               if [ -d $LFS/sources/${trunkDIR} ]; then
                 GetPkgVersion $LFS/sources/${trunkDIR} Python- tar
                 pythonvers=$rtrvers
                 if [ ! -z "$pythonvers" ]; then echo "python version is $pythonvers"; fi
                 GetSeriesNum $pythonvers
                 pythonseries=$rtrseries
                 echo "python3 series is $pythonseries"
               else
                 echo "*** Warning - unable to get python version. No source found."
               fi
             fi
           fi
	 fi
       ;;
#       shadow) # get the patch
#         patchSearch='*shadow*.patch*'
#         if [ "$SOURCES" = atinstall ]; then # use md5sums
#           shadowPatch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
#         else # use the src dir
#           shadowPatch=$(getPatchName "" $patchSearch $SourceDir)
#           shadowPatch=${shadowPatch##*/} # just the filename
#         fi
#         ret_val=$?
#         if [ $ret_val -eq $RETURN_PARAM ]; then
#           echo "failed to get shadow patch name"
#           echo "*** Investigate ***"
#         else
#           echo "shadow patch is $shadowPatch"
#         fi
#       ;;
       systemd) # need the man-pages
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           for srcFile in ${srcFileName[@]}; do
             case $srcFile in
                *systemd-[0-9]*z*)
                  rtrvers=""
                  systemdvers=""
                  GetPkgVersion "" $srcFile ".tar"
                  if [ "$?" = 0 ]; then
                    systemdvers=$rtrvers
                    if [ ! -z "$systemdvers" ]; then echo "systemd version is $systemdvers"; fi
                  else
                    echo "return value from GetPkgVersion for systemd is $?"
                    echo "Investigate why this didn't work"
                  fi
                ;;
                *systemd-man-pages-*) # need the name of the man-pages file
                  systemdManPages=$srcFile
                  echo "systemd man-pages file is $systemdManPages"
                ;;
             esac
           done
         else
           rtrvers=""
           GetPkgVersion $SourceDir "systemd-[0-9]" .tar
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "*** Directory $SourceDir doesn't exist ***"
           elif [ $retval -eq $RETURN_FNF ]; then
             echo "*** No file found containing the name systemd- and tar found ***"
           elif [ $retval -eq $RETURN_MTOV ]; then
             echo "*** More than one version of systemd- found in $SourceDir ***"
           elif [ $retval -eq 0 ]; then
             systemdvers=$rtrvers
             if [ ! -z "$systemdvers" ]; then echo "systemd version is $systemdvers"; fi
           fi
           rtrvers="" # get the systemd man-pages version from the source directory
           GetPkgVersion $SourceDir "systemd-man-pages-" .tar
           systemdManPages=$rtrvers
           echo "systemd man-pages is $systemdManPages"
	 fi
       ;;
       util-linux)
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           for srcFile in ${srcFileName[@]}; do
             case $srcFile in
                *util-linux-*)
                  rtrvers=""
                  utillinuxvers=""
                  GetPkgVersion "" $srcFile ".tar"
                  if [ "$?" = 0 ]; then
                    utillinuxvers=$rtrvers
                    if [ ! -z "$utillinuxvers" ]; then echo "util-linux version is $utillinuxvers"; fi
                  else
                    echo "return value from GetPkgVersion for util-linux is $?"
                    echo "Investigate why this didn't work"
                  fi
                  break
                 ;;
             esac
           done
         else
           rtrvers=""
           GetPkgVersion $SourceDir util-linux- .tar
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "*** Directory $SourceDir doesn't exist ***"
           elif [ $retval -eq $RETURN_FNF ]; then
             echo "*** No file found containing the name util-linux- and tar found ***"
           elif [ $retval -eq $RETURN_MTOV ]; then
             echo "*** More than one version of $util-linux found in $SourceDir ***"
           elif [ $retval -eq 0 ]; then
             utillinuxvers=$rtrvers
             if [ ! -z "$utillinuxvers" ]; then echo "util-linux version is $utillinuxvers"; fi
           fi
	 fi
       ;;
       xz)
         patchSearch='*xz*.patch*'
         if [ "$SOURCES" = atinstall ]; then # use md5sums
           xzPatch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
         else # use the src dir
           xzPatch=$(getPatchName "" $patchSearch $SourceDir)
           xzPatch=${zstdPatch##*/} # just the filename
         fi
         ret_val=$?
         if [ $ret_val -eq $RETURN_PARAM ]; then
           echo "failed to get xz patch name"
           echo "*** Investigate ***"
         else
           echo "xz patch is $xzPatch"
         fi
       ;;
       zstd)
         patchSearch='*zstd*.patch*'
         if [ "$SOURCES" = atinstall ]; then # use md5sums
           zstdPatch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
         else # use the src dir
           zstdPatch=$(getPatchName "" $patchSearch $SourceDir)
           zstdPatch=${zstdPatch##*/} # just the filename
         fi
         ret_val=$?
         if [ $ret_val -eq $RETURN_PARAM ]; then
           echo "failed to get zstd patch name"
           echo "*** Investigate ***"
         else
           echo "zstd patch is $zstdPatch"
         fi
       ;;
    esac
  done
elif [ ! -d $SourceDir ]; then
  echo "The source dir $SourceDir doesn't exist. Can't get package versions"
else
  echo "The source dir $SourceDir exists but is empty. Can't get package versions"
fi
# get the latest kernel from the website
getLatestKernel
retval=$?
if [ $retval -eq $RETURN_PARAM ]; then
  msg "return from getLatestKernel is $retval"
  msg "Is python beautifulsoup4 installed on the host?"
  msg "Aborting"
  exit 1
elif [ $retval -eq $RETURN_OTHER_ERR ]; then
  msg "error return from getLatestKernel"
  msg "Investigate"
elif [ $retval -eq 0 ]; then
  msg "the latest kernel src file from kernel.org is $kernSrcFile"
  msg "Will use latest kernel version which is $kernLatestVers"
fi
#
Start $bookDir $version $SINGLE_PACKAGE # build the scripts
# if installing as root and chapter 5 and 6, set script owner to lfs
if $as_root; then
  case $Chapter in
     chapter05)
       chown lfs ${LFS}/${ch5script}
       chown lfs ${LFS}/${BuildLog}
     ;;
     chapter06)
       chown lfs ${LFS}/${ch6script}
       chown lfs ${LFS}/${BuildLog}
     ;;
  esac
fi
