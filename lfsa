#!/bin/bash
#
if [ $UID -ne 0 ]; then echo Please run this script as root; exit 1; fi
LFS=$LFS
echo "LFS is set to $LFS"
if [ "$LFS" = "" ]; then
  echo "The LFS variable is not set"
  echo "do: export LFS=/mnt/lfs to install LFS on a target machine"
  echo "    export LFS=local to install LFS on this (local) machine"
  echo  
  exit 1
fi
# repository will be for LFS
REPO="LFS"
#
if [ "$LFS" = /mnt/lfs ]; then # check for the directory
  if [ ! -d $LFS ]; then
    echo "Directory $LFS doesn't exist"
    echo "Create it to continue"
    exit 1
  fi
elif [ "$LFS" = local ]; then
  LFS="/" # local machine
else
  echo "Don't recognise env variable LFS as $LFS. Edit this script to respond to $LFS."
  echo "Or else do: export LFS=/mnt/lfs"
  exit 1
fi
#
if [ -e $LFS/tools ]; then
  if [ ! -d $LFS/tools ]; then
    echo "$LFS/tools is not a directory"
    mv -v $LFS/tools $LFS/tools.backup
    echo "file $LFS/tools moved to $LFS/tools.backup"
    echo "create directory $LFS/tools"
    install -vdm755 $LFS/tools
    if [ "$LFS/tools" != "$( ls -l /tools | awk '{print $NF}' )" ]; then
      echo "/tools is not a symlink to $LFS/tools"
      echo ""
      echo "as root, do:"
      echo ""
      echo " ln -s $LFS/tools /tools"
      exit 1
    fi
  else
    echo "tools dir ${LFS}/tools exists"
  fi
else
  install -vdm755 ${LFS}/tools
fi
#
#display_menu=true # by default, edit the config file
# set up default config filename
if [ "$LFS" = /mnt/lfs -o "$LFS" = "/" ]; then
  lfs="lfs"
  lfsUC=${lfs^^} # uppercase version of $lfs
  cfg=~/${lfsUC}.conf
else
  echo "*** Don't recognise $LFS. Make sure this script will work with that. ***"
fi
# this following bit allows you to give a config filename as $1 and use it unedited
#if [ ! -z "$1" ]; then # config filename given - use it unedited
#  cfg=$1 # full name of the config file
# check it exists
#  if [ ! -e $cfg ]; then # doesn't exist - exit
#    echo "If you give the config filename it must exist"
#    echo "Exiting now"
#    exit 1
#  else
#    display_menu=false # do not change the config file
#  fi
#fi
# output the env var LFS in a file in /home/lfs so can source it in chapter05
if [ -d /home/lfs ]; then # make sure .bash_profile and .bashrc exist
  if [ -e /home/lfs/.bashrc  ]; then
    if [ -e /home/lfs/defineLFS ]; then rm -v /home/lfs/defineLFS; fi
# remove LFS env variable in .bashrc in case LFS=local
    sed -e '/LFS=\/mnt\/lfs/d' \
        -e 's/LFS LC_ALL/LC_ALL/' \
        -i /home/lfs/.bashrc
    cat > /home/lfs/defineLFS << "EOF"
# this is sourced by .bashrc when su - lfs is done in chapter05
EOF
    echo export LFS=\"$LFS\" >> /home/lfs/defineLFS
#    chown lfs:lfs /home/lfs/defineLFS
# does the .bashrc file contain the source defineLFS line?
    sourcePres=$(grep -E -w 'source|defineLFS' /home/lfs/.bashrc)
    if [ "$sourcePres" != "source /home/lfs/defineLFS" ]; then
      sed -i '/export/a source \/home\/lfs\/defineLFS' /home/lfs/.bashrc
    fi
  else # .bashrc doesn't exist so create it
    cat > /home/lfs/.bashrc << "EOF"
set +h
umask 022
LC_ALL=POSIX
LFS_TGT=$(uname -m)-lfs-linux-gnu
PATH=/usr/bin
if [ ! -L /bin ]; then PATH=/bin:$PATH; fi
PATH=$LFS/tools/bin:$PATH
CONFIG_SITE=$LFS/usr/share/config.site
export LC_ALL LFS_TGT PATH CONFIG_SITE
EOF
    if [ -e /home/lfs/defineLFS ]; then rm -v /home/lfs/defineLFS; fi # in case it exists
    cat > /home/lfs/defineLFS << "EOF"
# this is sourced by .bashrc when su - lfs is done in chapter05
EOF
    echo export LFS=\"$LFS\" >> /home/lfs/defineLFS
# now source defineLFS
    sed -i '/export/a source \/home\/lfs\/defineLFS' /home/lfs/.bashrc
# does /home/lfs/.bash_profile exist
    if [ ! -e "/home/lfs/.bash_profile" ]; then # create it
      cat > /home/lfs/.bash_profile << "EOF"
exec env -i HOME=$HOME TERM=$TERM PS1='\u:\w\$ ' /bin/bash
EOF
    fi
  fi
else
  echo "user lfs doesn't exist - will create the group and user lfs"
  groupadd lfs
  useradd -s /bin/bash -g lfs -m -k /dev/null lfs
  chown -v lfs ${LFS}/tools
  if [ ! -d ${LFS}/sources ]; then mkdir -v ${LFS}/sources; fi
  chown -v lfs $LFS/sources
  cat > /home/lfs/.bash_profile << "EOF"
exec env -i HOME=$HOME TERM=$TERM PS1='\u:\w\$ ' /bin/bash
EOF
cat > /home/lfs/.bashrc << "EOF"
set +h
umask 022
LC_ALL=POSIX
LFS_TGT=$(uname -m)-lfs-linux-gnu
PATH=/usr/bin
if [ ! -L /bin ]; then PATH=/bin:$PATH; fi
PATH=$LFS/tools/bin:$PATH
CONFIG_SITE=$LFS/usr/share/config.site
export LC_ALL LFS_TGT PATH CONFIG_SITE
EOF
  cat > /home/lfs/defineLFS << "EOF"
# this is sourced by .bashrc when su - lfs is done in chapter05
EOF
  echo export LFS=\"$LFS\" >> /home/lfs/defineLFS
#  chown lfs:lfs /home/lfs/{.bash_profile,.bashrc,defineLFS}
  echo "*** NOTE - You need to set a password for user lfs ***"
fi
lfscommands=${lfs}-commands # the dir containing the lfs-commands
lfshtml=${lfs}-html # the dir containing the lfs html
DumpedCommands=${LFS}/${lfscommands}
Dumpedhtml=${LFS}/${lfshtml}
if [ "$LFS" = "/" ]; then # need to remove the // to get the Makefile to work
  DumpedCommands="/${lfscommands}"
  Dumpedhtml="/${lfshtml}"
fi
wgetopts="" # Options for wget, e.g. proxy settings etc
RETURN_OTHER_ERR=237 # used when more than one error found in a function
RETURN_GT=239 # used in test of which version is later. returned if $1 > $2
RETURN_EQ=241 # used in compare_versions - returned if versions are equal
RETURN_FNF=243 # file not found
RETURN_MTOV=245 # more than one version of file present
RETURN_NO_CMNDS=247 # no commands found for specified package
RETURN_FNF=249 # return file not found
RETURN_PARAM=251  # from a function on error
#
isInt=89 # test if a string is int, float or just a string
isFloat=91
isChar=93
#
# these are relative to newly installed lfs ( i.e. without $LFS prefix )
sourcedir=/sources # as given in the book
PKGUSERDIR=/usr/src
PkgUserDir=${PKGUSERDIR}/core # most package src files sit under here. Make sure blfsa is consistent with this.
preChrootBuild=/build # chapter05 and 06 build directory
#
buildDir=${LFS}/build # chapter05 and 06 build directory
BuildLog=${lfsUC}-build.log # keep a record of packages and times
echo "BuildLog set to $BuildLog"
if [ ! -e ${LFS}/${BuildLog} ]; then
  if [ -d /home/lfs ]; then # user lfs exists
    echo "Directory /home/lfs exists"
    touch ${LFS}/${BuildLog}
  else
    echo "user lfs doesn't exist. You should create it now - section 4.3 in the book"
    exit 1
  fi
fi
SOURCEDIR=${LFS}${sourcedir}
if [ ! -d "$SOURCEDIR" ]; then install -vdm755 $SOURCEDIR; fi
allChaps="chapter05 chapter06 chapter07 chapter08 chapter10"
build="build" # name of the build file for each package
ncc="--no-check-certificate" # options for wget
#initialize the config variables
TZ=$TZ
PAPER_SIZE=$PAPER_SIZE
LFS_BOOK_GIT_LOC_DIR=$HOME/LFS_GIT/$REPO # def local dir for the downloaded (git) book xml
GIT_URL="git://git.linuxfromscratch.org" # git url
trunkDIR=trunk # the dir below LFS_BOOK_GIT_LOC_DIR
BOOK_VERSION=$BOOK_VERSION
SOURCES=$SOURCES
CLEAN_SRC_DIR=$CLEAN_SRC_DIR
WGETLISTNAME=$WGETLISTNAME
UPDATESRCFILES=$UPDATESRCFILES
BOOK_ORIGIN=$BOOK_ORIGIN
WHICH_CHAPTER=$WHICH_CHAPTER
PKGUSERFILE=$PKGUSERFILE
TESTS=$TESTS
MAKE_KERNEL=$MAKE_KERNEL # "no" -  stop at make mrproper, "yes" - use a .config and make
AS_ROOT=$AS_ROOT # 'no' install as package user, 'yes' install as root
SYSTEMD=$SYSTEMD # 'yes' use systemd, 'no' use sysvinit for control
DESTDIR=$DESTDIR
INSTALLDEST=$INSTALLDEST
USEPROXY=$USEPROXY
SINGLE_PACKAGE=$SINGLE_PACKAGE
PRINTIT=$PRINTIT
echo "config file is $cfg"
if [ -e $cfg ]; then
  source $cfg # exists so source it
else
  touch $cfg #cfg is new
  if [ -z "$TZ" ]; then #null
    TZ="Europe/London"
  fi
  if [ -z "$PAPER_SIZE" ]; then #null
    PAPER_SIZE="A4"
  fi
  if [ -z "$BOOK_ORIGIN" ]; then
    BOOK_ORIGIN="git"
  fi
  if [ -z "$BOOK_VERSION" ]; then
    BOOK_VERSION="trunk"
  fi
  if [ -z "$SOURCES" ]; then
    SOURCES="atinstall"
  fi
  if [ -z "$CLEAN_SRC_DIR" ]; then
    CLEAN_SRC_DIR="no"
  fi
  if [ -z "$WGETLISTNAME" ]; then
    WGETLISTNAME="wget-list"
  fi
  if [ -z "$UPDATESRCFILES" ]; then
    UPDATESRCFILES="no"
  fi
  if [ -z "$WHICH_CHAPTER" ]; then
    WHICH_CHAPTER="chapter05"
  fi
  if [ -z "$PKGUSERFILE" ]; then
    PKGUSERFILE="pkguser.tar.xz"
  fi
  if [ -z "$TESTS" ]; then #null
    TESTS="no"
  fi
  if [ -z "$MAKE_KERNEL" ]; then #null
    MAKE_KERNEL="no"
  fi
  if [ -z "$AS_ROOT" ]; then #null
    AS_ROOT="no"
  fi
  if [ -z "$SYSTEMD" ]; then #null
    SYSTEMD="yes"
  fi
  if [ -z "$DESTDIR" ]; then
    DESTDIR="no"
  fi
  if [ -z "$INSTALLDEST" ]; then
    INSTALLDEST="no"
  fi
  if [ -z "$USEPROXY" ]; then
    USEPROXY="no"
  fi
  if [ -z "$SINGLE_PACKAGE" ]; then
    SINGLE_PACKAGE="no"
  fi
  if [ -z "$PRINTIT" ]; then
    PRINTIT="false"
  fi
# store the values in the new config file
  echo "TZ=$TZ" | tee $cfg 
  echo "PAPER_SIZE=$PAPER_SIZE" | tee -a $cfg
  echo "LFS_BOOK_GIT_LOC_DIR=$HOME/LFS_GIT/$REPO" | tee -a $cfg
  echo "GIT_URL=$GIT_URL" | tee -a $cfg
  echo "BOOK_VERSION=$BOOK_VERSION" | tee -a $cfg
  echo "SOURCES=$SOURCES" | tee -a $cfg
  echo "CLEAN_SRC_DIR=$CLEAN_SRC_DIR" | tee -a $cfg
  echo "WGETLISTNAME=$WGETLISTNAME" | tee -a $cfg
  echo "UPDATESRCFILES=$UPDATESRCFILES" | tee -a $cfg
  echo "BOOK_ORIGIN=$BOOK_ORIGIN" | tee -a $cfg
  echo "WHICH_CHAPTER=$WHICH_CHAPTER" | tee -a $cfg
  echo "PKGUSERFILE=$PKGUSERFILE" | tee -a $cfg
  echo "TESTS=$TESTS" | tee -a $cfg
  echo "MAKE_KERNEL=$MAKE_KERNEL" | tee -a $cfg
  echo "AS_ROOT=$AS_ROOT" | tee -a $cfg
  echo "SYSTEMD=$SYSTEMD" | tee -a $cfg
  echo "DESTDIR=$DESTDIR" | tee -a $cfg
  echo "INSTALLDEST=$INSTALLDEST" | tee -a $cfg
  echo "USEPROXY=$USEPROXY" | tee -a $cfg
  echo "SINGLE_PACKAGE=$SINGLE_PACKAGE" | tee -a $cfg
  echo "PRINTIT=$PRINTIT" | tee -a $cfg
fi
# functions
#
msg () {
  echo >&2 -e "${1-}"
}
#
die() {
  local msg=$1
  local code=${2-1} # default exit status 1
  msg "$msg"
  exit "$code"
}
#
configEdit () {
local DIALOG_OK=0
local DIALOG_CANCEL=1
local DIALOG_HELP=2
local DIALOG_EXTRA=3
local DIALOG_ITEM_HELP=4
local DIALOG_ESC=255
local HEIGHT=0
local WIDTH=0

display_configFile () {
  dialog --textbox "$1" $HEIGHT $WIDTH
}
#
_edit () {
local value
local newval
local exit_status
local tochange
local display
#
itemMenu=$(awk -F\= '{print $1,$2}' $cfg)
exec 3>&1
tochange=$(dialog --menu "Select item to edit" 0 0 0 $itemMenu 2>&1 1>&3)
exit_status=$?
exec 3>&-
case $exit_status in
  $DIALOG_CANCEL)
    return 0
  ;;
  $DIALOG_ESC)
    echo "Program aborted." >&2
    exit 1
  ;;
  $DIALOG_OK)
    case $tochange in
       TZ)
         display="Enter your local time zone. (If not known, run tzselect)"
       ;;
       PAPER_SIZE)
         display="Probably either letter or A4"
       ;;
       LFS_BOOK_GIT_LOC_DIR)
         display="If the book source is GIT, enter the local directory to store the LFS Book"
       ;;
       GIT_URL)
         display="Enter the git url of the LFS book"
       ;;
       BOOK_VERSION)
         display="LFS book version you want. Type trunk to get the development version. To use systemd, set SYSTEMD=yes in the menu. Type blank to choose from a list."
       ;;
       BOOK_ORIGIN)
         display="Enter git to download the book or local if it's already downloaded. If local the book must be in $LFS_BOOK_GIT_LOC_DIR"
       ;;
       WHICH_CHAPTER)
         display="Enter chapter05, 06, 07, 08 or 10. Enter update to update the core lfs packages in chapter08. To do this set MAKE_KERNEL to no. If MAKE_KERNEL is yes, only the kernel will be updated"
       ;;
       SOURCES)
	       display="atinstall, download or local. atinstall means download to the install dir at install time (default). (if local, source files must be in ${SOURCEDIR}/<book_version>)"
       ;;
       CLEAN_SRC_DIR)
         display="If yes, all files in the $WgetList file in ${SOURCEDIR}/<book_version> will be deleted. Default is no. Note, if using the SINGLE_PACKAGE option with DESTDIR, the source directory will be cleaned first."
       ;;
       WGETLISTNAME)
         display="The name of the wget-list file. Default is wget-list"
       ;;
       UPDATESRCFILES)
           display="If yes, the source files are updated from the lfs sources page in the book.
The wget-list file is made consistent with these updates. Default is no"
       ;;
       PKGUSERFILE)
         display="tar file containing the package user build files. Default is pkguser.tar.xz. Place the file in $LFS/sources"
       ;;
       TESTS)
         display="Chapter 6 tests? Type eithe yes or no"
       ;;
       MAKE_KERNEL)
         display="If WHICH_CHAPTER is chapter10, input no will stop the kernel at makeproper. If yes, the kernel will be compiled and installed. If WHICH_CHAPTER is update, input no will update all the packages in chapter08, but not the kernel. If yes, the latest kernel will be compiled and installed; but nothing else. Remember, if this option is yes, the .config file must be in \$LFS/sources for the kernel to be installed"
       ;;
       AS_ROOT)
         display="If yes, install packages as root. If no, install as package user"
       ;;
       SYSTEMD)
         display="If yes, systemd will control start-up, running and shutdown of the system. If no, will use sysvinit."
       ;;
       DESTDIR)
           display="Set to yes to install the files to a specified directory and create a binary package tarfile from those files. Default is set to no."
       ;;
       INSTALLDEST)
           display="If yes and DESTDIR=yes then the files created by DESTDIR are installed and no binary tarfile is created. If DESTDIR=no then any existing binary tarfiles are installed for the specified chapter. Default is no"
       ;;
       USEPROXY)
           display="Set to yes if a proxy server is running on the host. Default is no."
       ;;
       SINGLE_PACKAGE)
         display="Install a single package. Use with DESTDIR to create a binary package file. The package name must be in the wget-list file (linux-headers and kernel are okay names). To turn off, type no"
       ;;
       PRINTIT)
           display="Set it to true to get more information when debugging the code."
       ;;
    esac
    value=$(awk -F\= -v x=$tochange '$1==x {print $2}' $cfg)
  ;;
esac
exec 3>&1
newval=$(dialog --clear --title "Change value" --inputbox "$display" 0 0 $value 2>&1 1>&3)
case ${newval+x$newval} in
  (x)
     dialog --infobox "Value can't be empty" 0 0
     sleep 2
     exit_status=1
  ;;
  ("")
     dialog --infobox "Value can't be unset" 0 0
     sleep 2
     exit_status=1
  ;;
  (x*[![:blank:]]*)
     exit_status=$? # non blank
  ;;
  (*)
     dialog --infobox "Value can't be blank" 0 0
     sleep 2
     exit_status=1
  ;;
esac
exec 3>&-
case $exit_status in
  $DIALOG_CANCEL)
    return 0
  ;;
  $DIALOG_ESC)
    echo "Program aborted." >&2
    exit 1
  ;;
  $DIALOG_OK)
    dialog --title "Confirmation"  --yesno "Commit ?" 0 0
    exit_status=$?
    case $exit_status in
       1)
          dialog --infobox "Value not changed" 0 0
          sleep 1
       ;;
       0)
          awk -v x=$tochange -v n=$newval '
               BEGIN {FS=OFS="="}$1==x {$2=n} {print}
               ' $cfg > $cfg.tmp
          mv $cfg.tmp $cfg
       ;;
    esac
  ;;
esac
return 0
} # end _edit
#
_main () {
while true; do
  exec 3>&1
  selection=$(dialog \
    --backtitle "LFS config file editor" \
    --title "Menu" \
    --clear \
    --cancel-label "Cancel" \
    --menu "Please choose an option:" $HEIGHT $WIDTH 4 \
            1 "View the config file" \
            2 "Edit config file" \
            3 "Exit from this menu" 2>&1 1>&3)
  exit_status=$?
  exec 3>&-
  case $exit_status in
    $DIALOG_CANCEL)
      echo "Cancel pressed. Exit program"
      exit 1
    ;;
    $DIALOG_ESC)
      echo "Program aborted."
      exit 1
    ;;
    $DIALOG_OK)
      case $selection in
        1)
           display_configFile $cfg
        ;;
        2)
           _edit
           display_configFile $cfg
        ;;
        3)
          echo "Exit and process config file"
          return
        ;;
      esac
  esac
done
#
} # end _main
_main
} #end configEdit
#
ChkLocalBook () {
# $1 is the dir of the book
# $2 is the book version
local localbookdir=$1
local version=$2
if [ "$version" = trunk ]; then # check if dir exists
  if [ -d ${localbookdir}/${version}/lfs ]; then # local book dir exists
    if [ -e ${localbookdir}/${version}/lfs/.git ]; then # a book exists, check the version
      ChkLocalBookDetails $localbookdir $version
      retval=$?
      if [ $retval -eq 0 ]; then
        return 0 # download the book
      else
        return 1 # requested book alreaded downloaded
      fi
    else # no .git file found, check if dir is empty
      if [ $(ls -al ${localbookdir}/${version} | wc -l) -eq 3 ]; then
        echo "dir ${localbookdir}/${version} is empty"
      fi
      return 0 # download the book
    fi
  else
    return $RETURN_PARAM # book dir doesn't exist
  fi
else # book is a release version so do nothing
  echo "Requested book is present locally so will use it."
  echo "It is a release version so no update necessary."
  return $RETURN_PARAM
fi
} # end ChkLocalBook
#
ChkLocalBookDetails () {
local bookdir=$1
local book_version=$2
#
# check the last commit hash
pushd ${bookdir}/${version}/lfs > /dev/null
  local last_commit_local=$(git rev-parse HEAD)
popd > /dev/null
# get the last commit hash from the online book
local last_commit_online=$(git ls-remote  git://git.linuxfromscratch.org/lfs.git  HEAD | cut -f1)
#echo "last_commit_local is $last_commit_local"
#echo "last_commit_online is $last_commit_online"
if [ "$last_commit_local" = "$last_commit_online" ]; then # latest commit already downloaded
  return 1 # don't download
else
  return 0 # download latest version of the book
fi
} # end ChkLocalBookDetails
#
CleanLocalREPO () { # delete any files in the local directory
local bookdir=$1
local book_version=$2
if [ -d ${bookdir}/${book_version} ]; then # local dir exists
  if [ "$(ls -A ${bookdir}/${book_version})" ]; then # dir contains files
    rm -rf ${bookdir}/${book_version}* # delete contents of local book dir
  fi
else  # create it
  install -v -m0755 -d ${bookdir}/${book_version}
fi
} # end CleanLocalREPO
#
WhichLFSBook () {
# BOOK_VERSION is global
local f lfsVers lfsBooks
# get a list of branches from the website
local lfsVers=$(git ls-remote ${GIT_URL}/lfs.git | awk -F\/ '{print $NF}')
# limit the books to just a decimal number and nothing else
for f in $lfsVers; do
  if [[ $f =~ ^[-+]?([0-9]*\.[0-9]+|[0-9]+\.[0-9]*)$ ]]; then
    lfsBooks="$lfsBooks $f"$'\n'
  fi
done
PS3="Please select the book version : "
select TAG in 'Current Development' $lfsBooks
do
  case $TAG in
    '') echo >&2 "Please select a numbered option"
    ;;
    Current*)
      type=trunk
      version=trunk
      BOOK_VERSION=trunk
    ;;
    ?*)
      type=tags
      version=$TAG
      BOOK_VERSION=$TAG
    ;;
  esac
  echo >&2 "You have selected '$TAG'"
  echo >&2 "$GIT_URL"
  PS3="Is this correct? : "
  select confirm in Yes No
  do
    case $confirm in
      '') echo >&2 "Please enter 1 for Yes or 2 for No"
      ;;
      ?*) break
      ;;
    esac
  done
  case $confirm in
    No) PS3="Please select the book version : "
    ;;
# update the config file with the book version
    Yes) awk -v x=BOOK_VERSION -v n=$BOOK_VERSION '
             BEGIN {FS=OFS="="}$1==x {$2=n} {print}
             ' $cfg > $cfg.tmp
             mv $cfg.tmp $cfg
	 break
    ;;
  esac
done
} #end WhichLFSBook
#
git-info () {
# a close equivalent to svn info

function check_git_dir {
  local IS_GIT_DIR=$(git rev-parse --is-inside-work-tree)
  if [ ! "$IS_GIT_DIR" == "true" ]; then
    exit 1
  fi
}
#
function get_last_modified {
  echo -e -n "$(git show --format="%ci %cr" $1 | head -n 1 | cut -d ' ' -f4-6)"
}
#
check_git_dir

REMOTE=$1
if [ "$REMOTE" == "" ]; then
  REMOTE=origin
fi

if [ "$(git remote | grep $REMOTE)" == "" ]; then
  echo "remote '$REMOTE' does not exist"
  exit 1
fi

git remote update $REMOTE > /dev/null 2>&1

REMOTE_URL=$(git config --get remote.$REMOTE.url)
BRANCH=$(git rev-parse --abbrev-ref HEAD)

LAST_REMOTE_COMMIT=""
REMOTE_LAST_MODIFIED=""
REMOTE_BRANCH_EXISTS=false
if [ ! "$(git branch -r  | grep $GROUP/$BRANCH)" == "" ]; then
  REMOTE_BRANCH_EXISTS=true
  LAST_REMOTE_COMMIT=$(git rev-parse $REMOTE/$BRANCH)
  REMOTE_LAST_MODIFIED=$(get_last_modified $REMOTE/$BRANCH)
fi
LAST_LOCAL_COMMIT=$(git --no-pager log --max-count=1 | head -n1 | cut -d ' ' -f2)
LOCAL_LAST_MODIFIED=$(get_last_modified $BRANCH)
SHORT_COMMIT_HASH=$(git rev-parse --short=9 $BRANCH)

INSYNC=false
if [ "$LAST_LOCAL_COMMIT" == "$LAST_REMOTE_COMMIT" ]; then
  INSYNC=true
fi

cd $(readlink -f .)
while [ ! -d .git ] && [ ! `pwd` = "/" ]; do cd ..; done
WORKING_COPY_ROOT_PATH=$(pwd)

echo "Working Copy Root Path: $WORKING_COPY_ROOT_PATH|Remote: $REMOTE|Remote URL: $REMOTE_URL|Branch: $BRANCH|Last Local Commit: $LAST_LOCAL_COMMIT ($LOCAL_LAST_MODIFIED)|Last Remote Commit: $LAST_REMOTE_COMMIT ($REMOTE_LAST_MODIFIED)|Synchronized: $INSYNC|Revision: $SHORT_COMMIT_HASH|"
#echo "                Remote: $REMOTE"
#echo "            Remote URL: $REMOTE_URL"
#echo "                Branch: $BRANCH"
#echo "     Last Local Commit: $LAST_LOCAL_COMMIT ($LOCAL_LAST_MODIFIED)"
#if [ "$REMOTE_BRANCH_EXISTS" == "true" ]; then
#  echo "    Last Remote Commit: $LAST_REMOTE_COMMIT ($REMOTE_LAST_MODIFIED)"
#  echo "          Synchronized: $INSYNC"
#else
#  echo "    Last Remote Commit: -- no remote branch --"
#  echo "          Synchronized: -- no remote branch --"
#fi
#
} # end git-info
#
CheckoutGIT () {
local gitUrl=$1
local bookdir=$2
local book_version=$3
local reType='^[0-9]+([.][0-9]+)?$' # deal decimal book versions
local source="${gitUrl}/lfs.git"
local destin="${bookdir}/${book_version}/lfs"
# download the book
git clone $source $destin
# add lfs: to the Makefile
sed -i '/book:/i lfs: book wget-list\n' "${destin}/Makefile"
# deal with a released book
if [[ $book_version =~ $reType ]] ; then
  echo "will do git checkout $book_version"
  pushd "${bookdir}/${book_version}/lfs" > /dev/null
    git checkout -b $book_version "origin/${book_version}"
  popd > /dev/null
fi
#
} # end CheckoutGIT
#
DumpCommands () {
# $1 is the Repository - LFS in this case
# $2 is the dir containing the book
# $3 is the book version
local bookdir=$2
local book_version=$3
local rev="systemd" # default
if [ "$SYSTEMD" = no ]; then rev="sysv"; fi
#
local target=$( echo $1 | awk '{print tolower($1)}')
REPODIR=${bookdir}/${book_version}/${target}
pushd $REPODIR > /dev/null
GITINFO=$(git-info)
popd > /dev/null
GITrevision=$( echo $GITINFO | awk 'BEGIN{ RS = "|" };/Revision/ {print $0}' )
if [ ! -d $DumpedCommands ]; then install -vdm755 $DumpedCommands; fi
if [ ! -d $Dumpedhtml ]; then install -vdm755 $Dumpedhtml; fi
if [ ! -e ${DumpedCommands}/.revision ]; then touch ${DumpedCommands}/.revision; fi # suppress a 'No such file' warning
commandRevision=$( cat $DumpedCommands/.revision | awk '/Revision/ {print $0}')
if [ "$commandRevision" != "$GITrevision" ]; then # dump the new commands
  rm -rf $DumpedCommands
  rm -rf $Dumpedhtml
  install -vdm755 $DumpedCommands
  install -vdm755 $Dumpedhtml
  pushd $REPODIR > /dev/null
    make -j1 DUMPDIR=$DumpedCommands BASEDIR=$Dumpedhtml REV=$rev $target "dump-commands"
    for dir in $DumpedCommands $Dumpedhtml; do
      echo $GITINFO | awk 'BEGIN{ RS = "|" }; {print $0}' > ${dir}/.revision
    done
  popd > /dev/null
  mkdir -pv ${SOURCEDIR}/${book_version}
  if [ ! -e ${SOURCEDIR}/${book_version}/wget-list ]; then # try and mv it from Dumpedhtml
    if [ -e ${Dumpedhtml}/wget-list ]; then
      mv ${Dumpedhtml}/wget-list ${SOURCEDIR}/${book_version}/
      mv ${Dumpedhtml}/md5sums ${SOURCEDIR}/${book_version}/
    else
      echo "There is no wget-list file in $Dumpedhtml"
      echo "You need to make sure that docbook-xml and docbook-xsl"
      echo "are installed on the host"
      echo "Abort"
      exit 1
    fi
  fi
fi
} # end of DumpCommands
#
CleanSourceDir () {
local srcdir=$1
local wgetlistFile=$2
if [ -d $srcdir ]; then
# delete any file in $srcdir that is in $wgetlistFile
  if [ -e $wgetlistFile ]; then
    while read FUrl; do
      if [[ ${FUrl:0:1} != '#' ]]; then # ignore file if it has a hash at the start
        fileinlist=$( echo $FUrl | awk -F\/ '{print $NF}' )
        [ -e ${srcdir}/${fileinlist} ] && rm -rf ${srcdir}/${fileinlist}
      fi
    done < $wgetlistFile
  fi
else
  rm -rf $srcdir # remove any file called $srcdir - it needs to be a dir
  install -v -m0755 -d $srcdir
fi
} #end CleanSourceDir
#
ChkPkgExists () {
# Used with the SINGLE_PACKAGE option.
# checks that the requested package is in the wgetlist file
local wgetlistFile=$1
local packageName=("${!2}")
local pkgURL
local fileinURL=""
#
echo "in ChkPkgExists"
echo "packageName is ${packageName[@]}"
if [ -e $wgetlistFile ]; then
  while read pkgURL; do
    fileinURL=$( echo $pkgURL | awk -F\/ '{print $NF}' )
    if [[ "$fileinURL" == ${packageName[0]}*.tar.?z* ]]; then
      fileinURL=$( echo $fileinURL | awk -F\/ '{print $NF}' )
      rtrnName=($fileinURL)
      return 0
    fi
  done < $wgetlistFile
return $RETURN_FNF
else
  return $RETURN_PARAM
fi
} # end ChkPkgExists
#
GetPkgName () {
# given a source file name, returns the package name for LFS packages
# $1 is the name of the src file
local pkgvers
local srcfile=$1
local pkgnm=$(echo $srcfile | awk -F\- '{print $1}')- # assumes the separator is -
case $srcfile in
   expect*|tcl8*) # separator is .
        pkgnm=$(echo $srcfile | awk -F\. '{print $1}')
        pkgnm=${pkgnm%?} # remove trailing numeric
   ;;
   iana-etc*|man-db*|man-pages*|pkg-config*|procps-ng*|util-linux*|XML-Parser*) # need $1 and $2 from awk
        pkgnm=$(echo $srcfile | awk -F\- '{print $1"-"$2}')-
   ;;
   tzdata*)
        pkgnm=$(echo $srcfile | awk -F\. '{print $1}') # separator is .
        pkgvers="${pkgnm#*tzdata}"
        pkgnm="${pkgnm%${pkgvers}*}"
   ;;
esac
echo $pkgnm
return 0
} # end GetPkgName
#
uniqueArray () {
# $1 is the array to sort
local unsorted_array=("${!1}")
local ip
local IFS=$'\n'
local sorted_array=( $(printf "%s\n" "${unsorted_array[@]}" | sort -u) )
rtrnSorted=(${sorted_array[@]})
} # end uniqueArray
#
get_crtime() {
# get the creation time (crtime) of a file
# $1 is the filename
# $2 is the file location - no final /
# NOTE need the -P option for grep implemented (if necessary recompile grep with pcre support)
#
local target=${2}/${1}
local inode=$(stat -c %i "${target}")
local fs=$(df "${target}"  | tail -1 | awk '{print $1}')
local crtime=$(sudo debugfs -R 'stat <'"${inode}"'>' "${fs}" 2>/dev/null | grep -oP 'crtime.*--\s*\K.*')
echo $crtime
}
#
detExtType () {
# determine the extension type of a tar file
# the hierarchy is xz, bz2, gz, tgz and zip
local sortedVers=("${!1}")
local isXZ=false
local isLZMA=false
local isBZ2=false
local isGZ=false
local isGZ2=false
local ispatchGZ=false
local isTGZ=false
local isZIP=false
local isTAR=false
local extType
#
for ((in=0; in<${#sortedVers[@]}; in++)); do # decide which files to test, .xz, .bz2, .gz, .tgz or zip
  case ${sortedVers[in]} in
     *tar.xz*)
        isXZ=true # if .xz file present, don't need to continue searching
        break
     ;;
     *.tar.lzma*) # e.g. curl
        isLZMA=true
     ;;
     *tar.bz2*)
        isBZ2=true
     ;;
     *tar.gz*)
        isGZ=true
     ;;
     *.patch.gz*) # for a gz patch file
        ispatchGZ=true
        break
     ;;
     *[0-9].gz*) # if no tar in name
        isGZ2=true
        trimto=".gz"
     ;;
     *.tgz*)
        isTGZ=true
     ;;
     *.zip*)
        isZIP=true
     ;;
     *-signed.tar) # for any signed file
        isTAR=true
        break
     ;;
  esac
done
# Set extension type to use, based on the hierarchy of tar files
if $isXZ; then
  extType="xz"
elif $isLZMA; then
  extType="lzma"
elif $isBZ2; then
  extType="bz2"
elif $isGZ; then
  extType="gz"
elif $ispatchGZ; then
  extType="patch.gz"
elif $isGZ2; then
  extType="gz2"
elif $isTGZ; then
  extType="tgz"
elif $isZIP; then
  extType="zip"
elif $isTAR; then
  extType="tar"
else
  return $RETURN_PARAM
fi
echo $extType
return 0
} # end detExtType
#
compare_versions () {
#
# compares two version numbers
# returns $RETURN_GT if $1 > $2 
# return $RETURN_EQ if $1 = $2
# otherwise returns 0
# $3 is the separator to parse the version number, usually .
#
local IFS="$3"
local a1=( $1 )
local a2=( $2 )
# some versions have a - in them, e.g. ImageMagick
local b1=$(IFS='-'; echo "${a1[*]}") # string b1 is now - delimited
local b2=$(IFS='-'; echo "${a2[*]}")
IFS='-' read -ra a1 <<< "$b1" # put delimited string back into array
IFS='-' read -ra a2 <<< "$b2"
#echo "a1 is ${a1[@]}"
#echo "a2 is ${a2[@]}"
local num_a1=${#a1[@]}
local num_a2=${#a2[@]}
#echo "numa1, numa2 are $num_a1 $num_a2"
local max=$(( $num_a1 > $num_a2 ? $num_a1 : $num_a2 ))
local im
for (( im=0; im<$max; im++ )); do
# deal with invalid octal. usbutils uses 00 type versioning.
  if [ "${a1[im]}" = "08" -o "${a1[im]}" = "09" ]; then a1[im]=${a1[im]#?}; fi
  if [ "${a2[im]}" = "08" -o "${a2[im]}" = "09" ]; then a2[im]=${a2[im]#?}; fi
  if [ "${a1[im]}" = "008" -o "${a1[im]}" = "009" ]; then a1[im]=${a1[im]#??}; fi
  if [ "${a2[im]}" = "008" -o "${a2[im]}" = "009" ]; then a2[im]=${a2[im]#??}; fi
#echo "a1 is ${a1[im]}"
#echo "a2 is ${a2[im]}"
  if [ "${a1[im]}" -eq "${a1[im]}" ] 2>/dev/null; then # is integer
    if [ "${a2[im]}" -eq "${a2[im]}" ] 2>/dev/null; then # can compare
      (("${a1[im]}" > "${a2[im]}")) && return $RETURN_GT
      (("${a2[im]}" > "${a1[im]}")) && return 0
    else
         return $RETURN_GT # a2 missing so a1 greater
    fi
  else
         return 0 # a2 greater
  fi
done
# if got here then a1 and a2 are equal
return $RETURN_EQ
} # end compare_versions
#
# test if integer, float or just a string
testIntFloatChar () {
# $1 is the string to test
local testString=$1
if [[ $testString =~ ^[+-]?[0-9]+$ ]]; then return $isInt; fi
if [[ $testString =~ ^[+-]?[0-9]+\.?[0-9]*$ ]]; then return $isFloat; fi
if [[ $testString =~ ^[+-]?[0-9]+\.$ ]]; then return $isChar; fi
return $isChar
}
#
updateSorted () {
# $1 is the array holding the list of "Click to enter 'version' strings"
# $2 is the url
# $3 is the package name, no version num but include the - after the name
# $4 is the file extension, .tar.xz, .tar.bz2, .tar.gz, .tgz or .zip
# $5 is the index number in ClickToDnld containing the filename
local ClickToEnter=("${!1}")
#echo "in updateSorted"
local ClickToDnld # array containing list of "Click to download 'filename' strings"
local latestVer=${ClickToEnter[1]} # assumes the first one is the latest - note [0] is empty
latestVer=${latestVer#"Click to enter "} # version number
local url="${2}${latestVer}/" # new url for page to search
local pattern
case $3 in
   boost_)
     latestVer="${latestVer//./_}" # version is _
     pattern="${3}${latestVer}${4}"
   ;;
   cracklib-words-)
     latestVer=${latestVer//-/}
     pattern="${3}${latestVer}${4}"
   ;;
   faad2-)
     pattern="${latestVer}/${latestVer}${4}"
   ;;
   libusb-)
     pattern="${latestVer}${4}"
   ;;
   sqlite-*)
     pattern=$3
     url=${url/e 3/e%203} # fix the space in the version number
   ;;
   tcl8.)
     pattern="${3}${latestVer}-src.tar.gz"
   ;;
   tk8.)
     pattern="${fnameonly}${latestVer}-src.tar.gz"
   ;;
   *)
     pattern="${3}${latestVer}${4}"
   ;;
esac
#echo "url is $url"
#echo "pattern is $pattern"
local foundPat=$(/usr/bin/php srcFileVers.php -- $pattern $url $3)
if [ "$foundPat" = "" ]; then
  return $RETURN_PARAM
fi
# page found so update array
readarray -t ClickToDnld <<< "$foundPat"
#echo "ClickToDnld is ${ClickToDnld[@]}"
local indexnum=$5
local filename=${ClickToDnld[indexnum]} #  [0] is empty
#echo "filename is $filename"
filename=${filename#*"Click to download "}
#echo "filename is $filename"
rtrnFname=$filename
#echo "exit updateSorted"
return 0
} # end updateSorted
#
findMaxVers () {
# $1 is the array holding the filenames
# $2 is the extension of the file - xz, bz2, gz, patch.gz, tgz or zip
# $3 is the pattern to trim to
# $4 is the current version in the wget-list file
# $5 is the package tar filename
# $6 - only used for grub and is $trimfname
local filesArray=("${!1}")
local extType=$2
local trimto=$3
local extension
local CurrentMaxVers=$4
local fname=$5
local instor=0 # the index of the max version file in the filesArray array
local foundit=false # true if $maxVers found in filesArray
local maxVers=$CurrentMaxVers # this will change if there is a later version
local trimfname=$6
#
case $extType in
   xz)
     extension="tar.xz"
   ;;
   bz2)
     extension="tar.bz2"
   ;;
   gz)
     extension="tar.gz"
   ;;
   gz2)
     extension=".gz"
   ;;
   patch.gz)
     extension="patch.gz"
   ;;
   tgz)
     extension=".tgz"
   ;;
   zip)
     extension=".zip"
   ;;
   tar)
     extension=".tar"
   ;;
   lzma)
    extension="tar.lzma"
   ;;
esac
for ((in=0; in<${#filesArray[@]}; in++)); do
  case ${filesArray[in]} in
     *$extension) # parse the version number of all files of type $extension
             namePlusVer="${filesArray[in]%${trimto}*}" # name plus version
#echo "namePlusVer is $namePlusVer"
             case $namePlusVer in
                expect*) # use . as the separator
                  justVers=$(echo $namePlusVer | awk -F\. '{print $NF}')
                ;;
                grub-*)
                  justVers=${namePlusVer#*${trimfname}} # the numeric after beta
                ;;
                tcl8.*)
                  justVers=${namePlusVer#"tcl8."}
                ;;
                *)
                  justVers=$(echo $namePlusVer | awk -F\- '{print $NF}')
                ;;
              esac
              case $justVers in
                 *rc*|*RC*|*c1*) # release candidate - ignore.
                   ret_val=0
                 ;;
                 *)
#echo "justVers is $justVers"
#echo "maxVers is $maxVers"
                  compare_versions $justVers $maxVers "."
                  ret_val=$?
                ;;
             esac
        if [ $ret_val -eq $RETURN_GT ]; then # justVers is >
          maxVers=$justVers
          foundit=true
          instor=$in # store the index of current max version
        elif [ $ret_val -eq $RETURN_EQ ]; then
          foundit=true
          instor=$in # versions are the same so store the index
        fi
     ;;
  esac
done
if [ "$maxVers" = "$CurrentMaxVers" ]; then # CurrentmaxVers unchanged
  if ! $foundit; then
    return $RETURN_PARAM
  else
    echo $instor # array index of the max version
    return $RETURN_EQ
  fi
else
  echo $instor # return the array index of the max version
  return 0
fi
} # end findMaxVers
#

GetLatestVers () {
# $1 is the wget-list file
# $2 is the book version, either lfs-sysv or lfs-systemd. Default is the latter.
# if present, $3 is runit, set to false to see result of a dummy run. Default is true.
# if present, $4 is printit. Set to true to see printout of variables' values. Default is false.
local wgetlist=$1
local bookvers
if [ ! -z "$2" ]; then
  if [ "$2" = "lfs-sysv" ]; then
    bookvers="development"
    echo "Using the sysv version of the book"
  elif [ "$2" = "lfs-systemd" ]; then
    bookvers="systemd"
    echo "Using the systemd version of the book"
  else
    echo "Didn't recognise $2. It should either be lfs-sysv or lfs-systemd."
    exit 1
  fi
else
  echo "Using the systemd version of the book"
  bookvers="systemd"
fi
local runit=${3:-true}
local printit=${4:-false}
#use a tmp file to store the latest urls for each source package
local latest_tmpfile=$(date +%d%B%Y_%H:%M:%S)tmp.file
local SrcURLtoUse="http://www.linuxfromscratch.org/lfs/view/${bookvers}/chapter03/packages.html"
local PatchURLtoUse="http://www.linuxfromscratch.org/lfs/view/${bookvers}/chapter03/patches.html"
# scrape the LFS website for the latest sources
local -a lines=($(python3 BShref.py $SrcURLtoUse))
if [ "$?" != 0 ]; then
  echo "Failed in BShref.py"
  echo "Is python-beautifulsoup4 installed on the host?"
  echo "Abort"
  exit 1
fi
local newURL=""
local i k
local src latestvers trimto
local fileExists useThisOne
local numFiles reply
local latestSrc
# remove the existing wget-list file so can be updated
if $runit; then rm -rf $wgetlist; fi # remove the old wgetlist file
for ((i=0; i<${#lines[@]}; i++)); do # get the src tarfile name
#  echo "from lfs website: ${lines[i]}"
# assumes all files in LFS have extensions .xz, .bz2 or .gz
  src=$(echo ${lines[i]} | awk -F\/ '{print $NF}' | grep -E ".tar.xz|.tar.bz2|.tar.gz")
  if $printit; then echo "src is $src"; fi
  if [ ! -z "$src" ]; then
# is this file already in $SourceDir
    if [ ! -e ${SourceDir}/${src} ]; then
      case $src in
          lfs-bootscripts*)
              echo "Don't need $src"
          ;;
          *)
              if ! $runit; then
                echo "Could download $src and place in $sourceLoc if runit were true"
              else
                echo "Will download $src and place in $SourceDir"
                trimto=".tar"
                case $src in
                   "tcl8."*) # trimto is -src
                     trimto="-src"
                   ;;
                   "python-"*"-docs-html.tar"*)
                     trimto="-docs"
                     tailbit="-docs-html" # might need this to find existing files
                   ;;
                esac
                pkgnm=$(GetPkgName $src)
                rtrvers=""
                GetVersionNum "" $src $trimto
                pkgvers=$rtrvers
                fileExists=($(find $SourceDir -type f -name "$pkgnm*"))
                numFiles=${#fileExists[@]}
                if [ $numFiles -gt 1 ]; then # probably src and patch file found for this package
                  echo "Files:"
                  for (( k=0; k<$numFiles; k++ )); do
                    echo "${fileExists[k]}"
                    case ${fileExists[k]} in
                       *tar.?z*) # use the tar file
                           useThisOne=${fileExists[k]}
                       ;;
                    esac
                  done
                  echo "found for package $pkgnm"
                elif [ $numFiles -eq 1 ]; then
                  useThisOne=${fileExists[0]}
                else # numFiles is zero, no package with this name found
                  echo "No package with name $pkgnm found in $sourceLoc"
                  echo "No source file to delete - continue with download"
                  useThisOne=$src
                fi
                if $printit; then echo "useThisOne is $useThisOne"; fi
                if [ "$useThisOne" = "$src" ]; then # only one file, download it
                  wget -O ${sourceLoc}/${src} ${lines[i]}
                  chown john:john ${sourceLoc}/${src}
                elif [ ! -z "$useThisOne" ]; then # a file with this pkgnm is present - compare versions
                  latestvers=$pkgvers # version of file to download
                  if $printit; then echo "latestvers is $latestvers"; fi
                  latestSrc=$(echo $useThisOne | awk -F\/ '{print $NF}') # remove SourceDir
                  if $printit; then echo "latestSrc is $latestSrc"; fi
                  pkgnm=$(GetPkgName $latestSrc)
                  rtrvers=""
                  GetVersionNum $SourceDir $pkgnm $trimto
                  retval=$?
                  if [ $retval -ne 0 ]; then
                    echo "Return from GetVersionNum is $retval"
                    echo "It should be 0. Investigate!"
                    exit 1
                  else
                    pkgvers=$rtrvers
                  fi
                  if [ "$pkgvers" = "$latestvers" ]; then
                    echo "Same version already downloaded but different extension"
                  else
                    for (( k=0; k<$numFiles; k++ )); do
                      echo "delete ${fileExists[k]} (Y/n)"
                      read replyDel
                      case $replyDel in
                        [yY]|[yY][Ee][Ss])
                          rm -v ${fileExists[k]}
                        ;;
                        [nN]|[nN][Oo])
                          echo "file ${fileExists[k]} not deleted"
                          storFname=${fileExists[k]}
                        ;;
                        *)
                          rm -v ${fileExists[k]}
                        ;;
                      esac
                    done
                    echo "Download $src (Y/n)"
                    read reply_Dwnld
                    case $reply_Dwnld in
                       [yY]|[yY][Ee][Ss])
                         wget -O ${SourceDir}/${src} ${lines[i]}
                         chown john:john ${SourceDir}/${src}
                       ;;
                       [nN]|[nN][Oo])
                         echo "File not downloaded"
                         reply_Dwnld=$(echo ${reply_Dwnld,,*}) # make sure it's lower case
                         if [ "$replyDel" = n -o "$replyDel" = no ]; then
                           echo "File $storFname not deleted and"
                           echo "File $src not downloaded"
                           tarfname=$(echo ${lines[i]} |  awk -F\/ '{print $NF}')
                           laterFname=$(echo $storFname |  awk -F\/ '{print $NF}')
                           echo "Will place $laterFname in the wget-list file"
                           url_bit="${lines[i]%${tarfname}}"
                           newURL=${url_bit}${laterFname}
                         fi
                       ;;
                       *)
                         wget -O ${SourceDir}/${src} ${lines[i]}
#                         chown lfs:root ${SourceDir}/${src}
                       ;;
                    esac
                  fi
                else
                  echo "The variable useThisOne is null. Investigate why"
                fi
              fi # end runit
          ;;
      esac
    else
      echo "file $src already downloaded"
    fi
  else
    echo "variable \$src is null"
    echo "Didn't find a tar.xz, tar.bz2 or tar.gz file"
    echo "Need to investigate why not"
    exit 1
  fi
  if [ -z "$newURL" ]; then
# echo "write ${lines[i]} to $wgetlist"
    echo "${lines[i]}" >> $wgetlist
  else
# echo "write $newURL to $wgetlist"
    echo "$newURL" >> $wgetlist
    newURL=""
  fi
done
# update any patches
local -a patches=($(python3 BShref.py $PatchURLtoUse))
if [ "$?" != 0 ]; then
  echo "Failed in BShref.py"
  echo "Is python-beautifulsoup4 installed on the host?"
  echo "Abort"
  exit 1
fi
local patchExists
for ((i=0; i<${#patches[@]}; i++)); do
  local ptch=$(echo ${patches[i]} | awk -F\/ '{print $NF}' | grep -E ".patch")
  if [ ! -e ${SourceDir}/${ptch} ]; then
    echo "Will download the patch $ptch and place in $SourceDir"
    pkgnm=$(GetPkgName $ptch)
    rtrvers=""
    GetVersionNum $SourceDir $pkgnm ".patch" "patch"
    retval=$?
    if [ $retval -ne 0 ]; then
      echo "parsing a patch file."
      echo "return value is $retval. It should be 0"
      exit 1
    else
      pkgvers=$rtrvers
    fi
    patchExists=$(find $SourceDir -type f -name "$pkgnm*.patch")
    if [ ! -z "$patchExists" ]; then
      if $runit; then
        echo "delete $patchExists (Y/n)"
        read replyDel
        case $replyDel in
          [yY]|[yY][Ee][Ss])
            rm -v $patchExists
          ;;
          [nN]|[nN][Oo])
            echo "file $patchExists not deleted"
          ;;
          *)
            rm -v $patchExists
          ;;
        esac
      else
        echo "Could delete $patchExists if runit were true"
      fi
    fi
    if $runit; then
      wget -O ${SourceDir}/${ptch} ${patches[i]}
#      chown lfs:root ${SourceDir}/${ptch}
    fi
  else
    echo "patch $ptch already downloaded"
  fi
# echo "write ${patches[i]} to $wgetlist"
  if $runit; then echo "${patches[i]}" >> $wgetlist; fi
done
} # end GetLatestVers
#
GetSource () {
local bookvers=$1
local srcdir=$2
local wgetlistFile=$3
local bookdir=$4
local fnameUnknown=false
# RequiredFiles contains an array of the required files. If RequiredFiles[0]=no, all files are requested.
local RequiredFiles=("${!5}")
#
# echo "RequiredFiles is ${RequiredFiles[@]}"
if [ "$bookvers" = trunk ]; then # get sources from the urls in $wgetlist
  if [ ! -d $srcdir ]; then install -v -d $srcdir; fi
    if [ ! -e ${srcdir}/${wgetlistFile} ]; then # wget-list doesn't exist, get it from the book
      REPODIR=${bookdir}/${bookvers}
      make -j1 -f ${REPODIR}/Makefile -C $REPODIR BASEDIR=$srcdir REV="systemd" ${srcdir}/${wgetlistFile} ${srcdir}/md5sums
      md5sums=${srcdir}/md5sums
    fi
    if [ "${RequiredFiles[0]}" = no ]; then # all source files requested
      pushd $srcdir > /dev/null
        RequiredFiles=$( md5sum --quiet -c $md5sums 2> /dev/null | awk -F\: '!/OK/{printf "%s ",$1}' )
      popd > /dev/null
    else
      fnameUnknown=true # might not know the precise filename, only the package name
    fi
    for File in ${RequiredFiles[@]}; do
      Url=$( grep $File $wgetlistFile )
      case $File in
         lfs-bootscripts*)
             if [ ! -e ${srcdir}/${File} ]; then
              wget $wgetopts -c $Url -O ${srcdir}/${File}
             fi
         ;;
         ?*)
             if $fnameUnknown; then
               wget $wgetopts -c $Url -P ${srcdir}/
             else
               wget $wgetopts -c $Url -O ${srcdir}/${File}
             fi
         ;;
      esac
    done
else # use anduin to get the source tarball for the released book version
# ****** NOTE ******
# anduin no longer is up-to-date. The LFS editors appear to have abandoned it
#
  bookvers=${bookvers%/} # remove the trailing /
#  File="lfs-packages-${bookvers}.tar"
#  sourceURL="http://anduin.linuxfromscratch.org/sources/LFS/lfs-packages/${File}"
#  wget $wgetopts -c $sourceURL -O ${SOURCEDIR}/${File}
#  tar xvf ${SOURCEDIR}/${File} -C $SOURCEDIR
#  rm -v ${SOURCEDIR}/${File} # untared so remove it
  wget --input-file=$LFS/sources/${bookvers}/wget-list --continue --directory-prefix=$LFS/sources/${bookvers}
fi
#set all the sources to owner lfs, if it exists
if getent passwd lfs > /dev/null 2>&1; then
  echo "User lfs exists"
#  chown -R -h lfs:root $srcdir # because chapter05.sh and chapter06.sh are run as lfs
else
  echo "user lfs doesn't exist. Sources owned by root instead."
  chown -R -h root:root $srcdir
fi
chmod 755 $srcdir
chmod 644 ${srcdir}/*
#
} #end GetSource
#
GetSystemdSources () {
local srcdir=$1
local wgetlistFile=$2
while read -r FileUrl; do
  fileNam=$( echo $FileUrl | awk -F\/ '{print $NF}' )
  wget $wgetopts -c $FileUrl -O ${srcdir}/${fileNam}
done < $wgetlistFile
#if getent passwd lfs > /dev/null 2>&1; then
#  chown -R -h lfs:root $srcdir
#else
  chown -R -h root:root $srcdir
#fi
chmod 644 ${srcdir}/*
#
} # end GetSystemdSources
# 
ChkSrcPresent () { 
# $1 is the directory to check
# $2 is the $wgetlist of files
# $3 is the array to hold any missing src file names
# if a single package, $3 contains the package name in array element 0
local dirtochk=$1
local wgetlistFile=$2
filesNotPresent=("${!3}") # global array
local filetofind
#
if $single_package; then # single package requested
  if [ -e ${dirtochk}/${filesNotPresent[0]} ]; then
    return 0
  else
    return $RETURN_PARAM
  fi
else # check sources in wget-list file are present in dirtochk
  echo "Checking all sources in $wgetlistFile have been downloaded"
  im=0
  while read FileUrl; do
    if [[ ${FileUrl:0:1} != '#' ]]; then # ignore file if it has a hash at the start
      filetofind=$( echo $FileUrl | awk -F\/ '{print $NF}' )
      if [ ! -e ${dirtochk}/${filetofind} ]; then
	if [[ "$filetofind" == "lfs-bootscripts"* && "$SYSTEMD" == yes ]]; then
          echo "don't need lfs-bootscripts with systemd"
        elif [[ "$filetofind" == "sysvinit-"* && "$SYSTEMD" == yes ]]; then
          echo "don't need sysvinit with systemd"
	else
          echo "'$filetofind' not present in $dirtochk"
	  filesNotPresent[im]=$filetofind
          ((im++))
        fi
      fi   
    fi
  done < $wgetlistFile
  if [ $im -gt 0 ]; then # files are missing
    return $RETURN_PARAM
  else
    return 0
  fi
fi
} # end ChkSrcPresent
#
ChkEmptySrcFiles () {
local srcdir=$1
# if checking a single package download, $2 will be the package filename
local pkgnm="${2:-}"
local zeroLenFiles
#
if [ ! -z "$pkgnm" ]; then # single package requested
# chk pkgnm exists
  if [ ! -e "${srcdir}/${pkgnm}" ]; then
# file not found
    return $RETURN_FNF
  else
    zeroLenFiles=$(find $srcdir -type f -name "$pkgnm" -empty)
  fi
else
  zeroLenFiles=$(find $srcdir -type f -empty)
fi
local numzero=${#zeroLenFiles}
if [ $numzero -eq 0 ]; then
  return 0
else
  echo -e "These files are empty:\n$zeroLenFiles"
  return $RETURN_PARAM
fi
} # end ChkEmptySrcFiles
#
GetSeriesNum () {
# $1 is the version number
local versnumber=$1
rtrseries=""
local IFS='.' # parse using a .
digitarray=($versnumber)
rtrseries="${digitarray[0]}.${digitarray[1]}"
} # GetSeriesNum
#
getPatchVers () {
# assumes the standard form of a patch, viz. pkgnm-version-descriptor-1.patch
# $1 is the name of the patch file
# $2 is the pkg name
local patchFile=$1
local pkgnm=$2
local versionPlus="${patchFile#${pkgnm}*}"
pkgvers=$(echo $versionPlus | awk -F\- '{print $1}')
echo $pkgvers
} # end getPatchVers
#
GetPkgVersion () {
# $1 is the dir containing the src package
# $2 is the name of the src package
# $3 is the name to trim against - usually .tar
# $4 is the separator between name and version, usually "-"
# $5 is used with a patch file and is set to patch
# $6 is used with a patch and if set to returnName, will return the name of the patch file only

local pkgloc=${1:-"nowhere"}
local srcname=$2
local trimto=${3:-".tar"}
local separator=${4:-"-"}
local patch=${5:-""}
local rtrnName=${6:-""}
rtrvers=""
# if pkgloc is given, check it exists
if [ "$pkgloc" != nowhere ]; then
  if [ ! -d "$pkgloc" ]; then return $RETURN_FNF; fi
fi
# check if just requested the name of a patch file
if [ "$rtrnName" = returnName ]; then
  if [ -d "$pkgloc" ]; then
    local patchFile="${srcname}*.patch"
    local -a found=($(find $pkgloc -name $patchFile))
    local num=${#found[@]}
    if [ $num -eq 1 ]; then # return the name
      rtrvers=$found[0]
    elif [ $num -gt 1 ]; then
      return $RETURN_MTOV # more than one version present
    elif [ $num -eq 0 ]; then # file not found
      return $RETURN_FNF
    fi
  else # pkgloc not a directory
    return $RETURN_FNF
  fi
else
  GetVersionNum $pkgloc $srcname $trimto $separator $patch $rtrnName
  retval=$?
  if [ $retval -eq $RETURN_PARAM ]; then
    return $RETURN_PARAM
  elif [ $retval -eq $RETURN_FNF ]; then
    return $RETURN_FNF
  elif [ $retval -eq $RETURN_MTOV ]; then
    return $RETURN_MTOV
  else
    return 0
  fi
fi
} # GetPkgVersion
#
GetVersionNum () {
# $1 is the dir containing the src package.
# If it doesn't exist, return the version of $2, if possible
# $2 is the name of the package
# $3 is the name to trim against - usually ".tar"
# $4 is the separator between srcname and the version number, usually "-"
# $5 if present, is "patch" to indicate a patch file
# $6 if present, is returnName to return the name of the patch file only
#
local pkgloc=$1
local srcfile=$2
local trimto=$3
local separator=${4:-"-"}
local patch=${5:-""}
local rtrnName=${6:-""}
local -a found=""
local fname fileExt pkgPlusVers pkgnm
local num=0
local i
local pkgvers=""
#msg "in GetVersionNum"
#msg "pkgloc is $pkgloc"
#msg "srcfile is $srcfile"
#msg "trimto is $trimto"
#msg "patch is $patch"
#
if [ -d "$pkgloc" ]; then
  found=($(find $pkgloc -maxdepth 1 -type f -name "${srcfile}"))
#msg "found is ${found[@]}"
  num=${#found[@]}
#msg "num is $num"
  if [ $num -gt 1 ]; then return $RETURN_MTOV; fi # more than one version present
  if [ $num -eq 1 ]; then
    fname=${found[0]##*/} # filename only
#msg "fname is $fname"
    pkgPlusVers="${fname%${trimto}*}"
#msg "pkgPlusVers is $pkgPlusVers"
# TODO  doesn't work if separator not -
    pkgvers=$(echo $pkgPlusVers | awk -F\- '{print $NF}')
    rtrvers=($pkgvers)
    return 0
  else # num=0 - might be a patch file
    if [ "$trimto" = ".patch" ]; then
      found=$(find $pkgloc -name "${srcfile}[0-9].*${trimto}" | awk -F\/ '{print $NF}')
      num=${#found[@]}
      if [ $num -eq 1 ]; then # a patch file so get the version
        pkgvers=$(getPatchVers $found $srcfile)
        rtrvers=($pkgvers)
        return 0
      else
        return $RETURN_FNF # file not found
      fi
    else # not a patch file, see if can return version of srcfile
      local pkgPlusVers="${srcfile%${trimto}*}"
      if [[ "$pkgPlusVers" = "tzdata"* ]]; then
        pkgnm="tzdata"
      else
        pkgvers=$(echo $pkgPlusVers | awk -F\- '{print $NF}')
        if [[ -z "$pkgvers" || "$pkgvers" != [0-9]* ]]; then # file not found
          pkgnm=""
          return $RETURN_FNF
        else
# trim to the version number
          pkgnm="${pkgPlusVers%${pkgvers}}"
#          echo "pkgvers is $pkgvers"
#          echo "pkgnm is $pkgnm"
           rtrvers=$pkgvers
           return 0
        fi
      fi
    fi
  fi
else # no pkg location given - return the version of $2, if possible
  pkgPlusVers="${srcfile%${trimto}*}"
  if [ "$patch" = patch ]; then
    pkgnm=$(echo $pkgPlusVers | awk -F\- '{print $1}') # search for pkgnm*.patch
  else
    if [[ "$pkgPlusVers" = "tzdata"* ]]; then
      pkgnm="tzdata"
    else
#msg "separator is $separator"
      if [ "$separator" = "." ]; then # expect5 and tcl8
        pkgvers=$(echo $pkgPlusVers | awk -F\. '{print $2"."$3}')
      elif [ "$separator" = "-" ]; then # everything else
        pkgvers=$(echo $pkgPlusVers | awk -F\- '{print $NF}')
      fi
      if [ -z "$pkgvers" ]; then
        pkgnm=""
        return $RETURN_FNF
      else
# trim to the version number
        pkgnm="${pkgPlusVers%${pkgvers}}"
      fi
    fi
  fi
  rtrvers=$pkgvers
  return 0
fi
} # end GetVersionNum
#
GetLinuxVersion () {
local srcdir=$1
local linuxfnd
local linuxExt
#
linuxfnd=$(find $srcdir -name "linux-[0-9]*.tar.?z*" | awk -F\/ '{print $NF}')
if [ -z "$linuxfnd" ]; then # linux src not found in wget-list file - return
  return $RETURN_PARAM
else
  linuxExt="${linuxfnd#*-}"
  linuxvers="${linuxExt%.tar*}"
fi
return 0
} # end GetLinuxVersion
#
GetLinuxCommandVersion () {
# find the version of a package in the lfs commands
# $1 is the location of the lfs commands, include $LFS
# $2 is the package name in the command directory
# $3 is the pattern to find in the pkgname commands
local commandloc=$1
local pkgname=$2
local pattern=$3
if [ -e "$commandloc" ]; then
  local cmdLine
  local linuxcomfnd=""
#
  while read cmdLine; do
    if [[ ${cmdLine:0:1} != '#' ]]; then # ignore line if it has a hash at the start
      linuxcomfnd=$( echo $cmdLine | awk -F\/ '{print $NF}' | grep $pattern )
      if [ ! -z "$linuxcomfnd" ]; then
        break # found the pattern in the command line
      fi
    fi
  done < ${commandloc}/*-${pkgname}
  if [ ! -z "$linuxcomfnd" ]; then # found required pattern in the commands - echo it
    echo $linuxcomfnd
    return 0
  else
    return $RETURN_PARAM
  fi
#    linuxcomExt="${linuxcomfnd#*-}"
#    linuxcomvers="${linuxcomExt%-lfs*}"
else
  return $RETURN_PARAM
fi
} # end GetLinuxCommandVersion
#
combineScripts () {
declare -a commands=("${!1}")
declare -a buildWrap=("${!2}")
local combine=""
local numc=${#commands[@]}
local numb=${#buildWrap[@]}
countc=0 # counter for the combine array
countbl=0 # counter for build lines written
inc=false # switch for whether a configure, make and install section is present
cont=0 # number of continuation lines
ifDoc=false # true if an if block containing a doc
#
for (( i=0; i<$numb; i++ )); do
  case "${buildWrap[i]}" in
    configure_commands*)
      combine[countc++]=${buildWrap[countbl++]}
      combine[countc++]=${buildWrap[countbl++]} # the {: line
      for (( jk=$countg; jk<$numc; jk++ )); do
        case ${commands[jk]} in
           make*) # assume either a make command or make install
              countg=$jk
              break
           ;;
           *"make -c"*) # ncurses has a pushd with make commands
              if $foundPushd; then # keep writing until popd found
                combine[countc++]="  ${commands[jk]}"
              else
                countg=$jk
                break
              fi
           ;;
           *popd*)
	     if $foundPushd; then # write it out and set foundPushd to false
                combine[countc++]="  ${commands[jk]}"
		foundPushd=false
             else
		echo "popd found but no pushd found before it"
		echo "Something is wrong. You need to investigate"
		exit 1
	     fi
	   ;;
           *"install_man_docs install_html_docs"*) # openssl in chapter06
              countg=$jk
              break
           ;;
           *"LANG=en_US.UTF-8 ninja"*) # systemd using ninja
              countg=$jk
              break
           ;;
           *'LIBRARY_PATH=/tools/lib make'*) # the eudev make command
              countg=$jk
              break
           ;;
           "cp services protocols"*) # iana-etc copy
              countg=$jk
              break
           ;;
           *ninja*)
              countg=$jk
              break
           ;;
           "pip3 wheel"*) # meson markupsafe
              countg=$jk
              break
           ;;
           "python3 -m build -n") # wheel using destdir
              countg=$jk
              break
           ;;
           *install*) # test to see if part of a continuation squence
              case ${commands[jk]} in
                 *\\) # a continuation line
                    if [ $cont -gt 0 ]; then # part of configure sequence so store it
                      storit[cont++]="${commands[jk]}"
                    else # assume an install cont line
                      countg=$jk
                      break
                    fi
                 ;;
                 './configure'*) # might be a configure with install in it
                    combine[countc++]="  ${commands[jk]}"
                    inc=true
                 ;;
                 *)
                    countg=$jk
                    break
                 ;;
              esac
           ;;
           *)
              case "${commands[jk]}" in
                 *\\)
                    storit[cont++]="${commands[jk]}"
                 ;;
                 *)
                    # write with any continuation lines
                    if [ $cont -gt 0 ]; then
                      for (( l=0; l<$cont; l++ )); do
                        combine[countc++]="  ${storit[l]}"
                      done
                      combine[countc++]="  ${commands[jk]}"
                      cont=0
                      inc=true
                    else
                      combine[countc++]="  ${commands[jk]}" # configure command
                      inc=true # found at least one configure command
                    fi
                    if [ $[jk+1] -eq $numc ]; then countg=$jk; fi
                 ;;
              esac
           ;;
        esac
      done
      if [ $cont -gt 0 ]; then
        for (( l=0; l<$cont; l++ )); do
          combine[countc++]="  ${storit[l]}"
        done
        combine[countc++]="  ${commands[countg++]}"
        inc=true
        cont=0
      fi
      if ! $inc; then
        combine[countc++]='  echo "no configure script for this package"'
      fi
    ;;
    make_commands*)
      inc=false
      combine[countc++]=${buildWrap[countbl++]}
      combine[countc++]=${buildWrap[countbl++]} # the {: command
      for (( jl=$countg; jl<$numc; jl++ )); do
        case ${commands[jl]} in
           *"install_man_docs install_html_docs"*) # openssl chapter06, write this
              combine[countc++]="  ${commands[jl]}"
              cont=0
              inc=true
           ;;
           *install*) # assume an install command
              countg=$jl
              break
           ;;
           'cp -v src/{msgfmt'*) # gettext ch5
              countg=$jl
              break
           ;;
           'cp -v src/{fstab-decode'*) # sysvinit (systemd) ch6
              countg=$jl
              break
           ;;
           'cp -v perl cpan'*) # perl ch5
              countg=$jl
              break
           ;;
           "cp services protocols"*) # iana-etc copy
              countg=$jl
              break
           ;; 
           *)
              case "${commands[jl]}" in
                 *\\)
                     storit[cont++]="${commands[jl]}"
                 ;;
                 *)
                     if [ $cont -gt 0 ]; then # write the continuation lines
                       for (( l=0; l<$cont; l++ )); do
                         combine[countc++]="  ${storit[l]}"
                       done
                       combine[countc++]="  ${commands[jl]}"
                       cont=0
                       inc=true
                     else
                       combine[countc++]="  ${commands[jl]}" # make commands
                       inc=true #at least one make command found
                     fi
                     if [ $[jl+1] -eq $numc ]; then # no more commands
                       countg=$jl
                       if [[ "${commands[$countg]}" != *make* ]]; then
                         ((countc--))
                       fi
                     fi
                 ;;
              esac
           ;;
        esac
      done
       if ! $inc; then
         combine[countc++]='  echo "no make script for this package"'
       fi
    ;;
    install_commands*)
      inc=false
      foundDoc=false
      tarCom=false
      combine[countc++]=${buildWrap[countbl++]}
      combine[countc++]=${buildWrap[countbl++]} # the {: command
      for (( jm=$countg; jm<$numc; jm++ )); do
        case ${commands[jm]} in
          *install*)
             case "${commands[jm]}" in
               *\\) # cont line so store it
                  case "${commands[jm]}" in
                    *'/usr/share/doc'*) # cont line contains a doc
                        foundDoc=true
                        storit[cont++]="${commands[jm]}"
                    ;;
                    *) # no doc in this cont line
                        storit[cont++]="${commands[jm]}"
                    ;;
                  esac
               ;;
               'make'*'=/usr/share/doc'*|*'DOCDIR=/usr/share/doc'*) # genuine install command
                    if [ $cont -gt 0 ]; then # first write out cont lines
                      for (( l=0; l<$cont; l++ )); do
                        combine[countc++]="  ${storit[l]}"
                      done
                    fi
                    combine[countc++]="  ${commands[jm]}"
                    inc=true
               ;;
               *'/usr/share/doc'*) # don't write a doc install
                    :
               ;;
               *) # install line so write it out
                    if [ $cont -gt 0 ]; then # first write out cont lines
                      for (( l=0; l<$cont; l++ )); do
                        combine[countc++]="  ${storit[l]}"
                      done
                    fi
                    combine[countc++]="  ${commands[jm]}"
                    inc=true
                    cont=0
                    countg=$((jm+1))
               ;;
             esac
          ;;
          "tar "*) # a tar command, so break
             countg=$jm
             cont=0
             inc=true
             tarCom=true # set to true in case continuation lines have a /usr/share/doc in them
             break
          ;;
          '#'*) # comment line so ignore it
              if [ $[jm+1] -eq $numc ]; then countg=$[jm+1]; fi
          ;;
          if*) # starts with if so if a doc, will need to delete the closing fi
                   case ${commands[jm]} in
                   *'/usr/share/doc'*)
                       ifDoc=true
                       case ${commands[j]} in
                          *\\) # a continuation line so store it
                                storit[cont++]="${commands[jm]}"
                          ;;
                       esac
                   ;;
                   *\\) # a continuation line
                       storit[cont++]="${commands[jm]}"
                   ;;
                   *) # if block but not a doc or a cont line
                       echo ${commands[jm]}
                   ;;
                esac
          ;;
          *'mv -v /usr/share/doc/openssl'*) # add version to the openssl doc dir
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          *'/usr/share/doc'*) # would have got here because we have a cont line
             cont=0 # doc so don't write it out
             countg=$((jm+1)) # update countg in case this is the last line
          ;;
          "for "*) # begining of a for loop so break
             countg=$jm
             cont=0
             inc=true
             break
          ;;
          'cp -v src/{fstab-decode'*|'cp -v src/last'*|'cp -v man/{last'*|'cp -v man/{fstab-decode'*) # sysvinit (systemd) ch6
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'cp -v perl cpan/podlators'*|'mkdir -pv /tools/lib/perl5'*|'cp -Rv lib/* /tools/lib/perl5'*) # perl ch5
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'make -C ld clean'*|'make -C ld LIB_PATH=/usr/lib:/lib'*|'cp -v ld/ld-new /tools/bin'*) # binutils pass 2
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'cp -v gettext-tools/src/{msgfmt'*) # gettext chapter07
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'cp -rv usr/include $LFS/usr'*) # linux-headers copy
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'cp -rv usr/include /usr'*) # linux-headers copy when updating
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'cp -rv dest/* /'*) # meson copy from destdir
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'cp services protocols /etc'*) # iana-etc copy
	    combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;; 
          *)
             case "${commands[jm]}" in
               *\\) # if a cont line, then store it
                     storit[cont++]="${commands[jm]}"
               ;;
               'cp -v src/msgfmt'*)
                     combine[countc++]="  ${commands[jm]}"
                     countg=$((jm+1))
                     cont=0
                     inc=true
               ;;
               *)
                     if ! $foundDoc; then # write out any cont lines
                       if [ $cont -gt 0 ]; then
                         for (( l=0; l<$cont; l++ )); do
                           combine[countc++]="  ${storit[l]}"
                         done
                         combine[countc++]="  ${commands[jm]}"
                         cont=0
                         inc=true
                         countg=$((jm+1))
                       else # not part of install commands so break
                         countg=$jm
                         cont=0
                         inc=true
                         break
                       fi
                     else # continuation of a doc line so ignore it
                       cont=0
                     fi
               ;;
             esac
          ;;
        esac
      done
      if ! $inc; then
        combine[countc++]='  echo "no install script for this package"'
      fi
    ;;
    *)
      if [ $i -lt $countbl ]; then
        :
      else
        combine[countc++]=${buildWrap[i]}
        ((countbl++)) # increment because have written another build command
      fi
    ;;
  esac
done
# got to the final test_pipe
# write the script to Output
for t in "${combine[@]}"; do
  echo $t
done
# deal with any remaining lines
} # end combineScripts
#
getBuild () {
# $1 is the pkguser directory in /tools, pkguser by default
local pkguser=${1:-pkguser}
local abuild=""
buildfile=${LFS}/tools/${pkguser}/build
if [ ! -e $buildfile ]; then
  return $RETURN_PARAM
else
IFS='
'
abuild=( $( < $buildfile ) )
rtrnBuild=(${abuild[@]})
return 0
fi
} # end getBuild
#
getComms () {
# $1 is the chapter containing the commands
# if present, $2 is the package name. This can be used to modify the commands
# Note - DumpedCommands and CmdName are global variables
local acom=""
local bcom=""
local chapreq=$1
local pkgname=${2:-""}
if [ -e ${DumpedCommands}/${chapreq}/*-${CmdName} ]; then
  curfile=${DumpedCommands}/${chapreq}/*-${CmdName}
else
  if $printit; then msg "in function getComms - did not find commands"; fi
  if $printit; then msg "DumpedCommands is $DumpedCommands"; fi
  if $printit; then msg "chapreq is $chapreq"; fi
  if $printit; then msg "CmdName is $CmdName"; fi
  curfile=${DumpedCommands}/${chapreq}/*-${CmdName}
  if $printit; then msg "curfile is ${curfile[@]}"; fi
  return $RETURN_PARAM
fi
local IFS='
'
acom=( $( < $curfile ) )
#
# use pkgname to adjust the commands here if required
#
if [ ! -z "$pkgname" ]; then
  case $pkgname in
     kernel)
       ic=0
       foundmakeprop=false
       for tline in ${acom[@]}; do
         case $tline in
            *"make mrproper"*) # write it
              foundmakeprop=true
              bcom[ic++]=$tline
            ;;
            *)
              if $foundmakeprop; then
                bcom[ic++]="echo \"no install commands for this package\""
                break
              fi
            ;;
         esac
       done
       rtrnCom=(${bcom[@]})
       return 0
     ;;
  esac
else # return everything untouched
  rtrnCom=(${acom[@]}) # rtrnCom is global
  return 0
fi
} # end getComms
#
GetCommands () {
#get access to the arrays
rtrnBuild=""
getBuild
return_val=$?
if [ "$return_val" -eq $RETURN_PARAM ]; then # no build file present in /tools
  return $RETURN_PARAM
else
buildScripts=(${rtrnBuild[@]})
rtrnCom=""
if [ "$PkgName" = kernel ]; then # if not making the kernel, edit the commands
  if ! $make_kernel; then
    getComms $currentChapter $PkgName
  else # don't edit the commands
    getComms $currentChapter
  fi
else
  getComms $currentChapter
fi
ret_val=$?
if [ "$ret_val" -eq $RETURN_PARAM ]; then # no commands found
  echo 'echo "No commands found for package '"$PkgName"' in '"$lfscommands"'"
echo "Check you have the correct book written to '"$lfscommands"'"
echo "and that '"$PkgName"' is supposed to be installed in '"$currentChapter"'"
echo "This script will fail."
echo "Aborting"
exit 1' >> $Output
  return $RETURN_NO_CMNDS
else
  commandScripts=(${rtrnCom[@]})
  numclines=${#commandScripts[@]} # # of commands
#
# place commands in output until first configure found
  countg=0
  contline=0
  foundCase=false # keep track of a case statement
  foundPushd=false # used to find the corresponding popd
#
  for line in "${commandScripts[@]}"; do
    if [ "$PkgName" = changingowner -o "$PkgName" = kernfs ]; then # write the line
      echo "$line"
      ((countg++))
    else
      case "$line" in
         sed*)
           echo "$line"
           ((countg++))
         ;;
         *pushd*) # ncurses has this in chapter06
	   foundPushd=true
	   countg=$(expr $countg - $contline)
	   break
	 ;;
         *"case \$(uname -m) in"*)
           if [ "$PkgName" = gcc -o "$PkgName" = glibc ]; then # write it
             foundCase=true # expect to find an esac
             echo "$line"
             ((countg++))
           else # case statement in findutils
             countg=$(expr $countg - $contline)
             break
           fi
         ;;
         *"case \"\$online"*) # stripping
           if [ "$PkgName" = stripping ]; then # write it
             foundCase=true # expect to find an esac
             echo "$line"
             ((countg++))
           fi
         ;;
         *esac*) # check that foundCase is true
           if $foundCase; then # write it
             echo "$line"
             ((countg++))
             foundCase=false
           else # something wrong
             echo "found an esac but not the case statement"
             echo "PkgName is $PkgName"
             echo "INVESTIGATE"
             exit 1
           fi
         ;;
         *configure*|*Configure*) #Perl has Configure!
           countg=$(expr $countg - $contline)
           break
         ;;
         *"config --prefix="*) # openssl
           countg=$(expr $countg - $contline)
           break
         ;;
         *"cp services protocols"*) # iana-etc copy
           break
         ;;
         *"LANG=en_US.UTF-8"*) # systemd has this at start of configure
           countg=$(expr $countg - $contline)
           break
         ;;
         "meson --prefix="*)
           countg=$(expr $countg - $contline)
           break
         ;;
         "perl Makefile"*) # xml-parser is a perl module
           countg=$(expr $countg - $contline)
           break
         ;;
         "pip3 install"*)
           countg=$(expr $countg - $contline)
           break
         ;;
         "pip3 wheel -w dist "*) # for meson
           countg=$(expr $countg - $contline)
           break
         ;;
         "python3 -m pip install "*) # for installer
           countg=$(expr $countg - $contline)
           break
         ;;
         make*) #begins with make
           break
         ;;
         "PKG_CONFIG_PATH=/usr/lib/pkgconfig"*) # added for systemd using meson
           break
         ;;
         *)
# if a continuation line, store in cache
           case "$line" in
              *\\)
               cacheit[contline++]="$line"
               ((countg++))
              ;;
              *)
               if [ $contline -gt 0 ]; then # continuation line found
                 for (( l=0; l<$contline; l++ )); do
                   echo "${cacheit[l]}"
                 done
                 echo "$line"
                 contline=0
                 ((countg++)) # count # of commands written to output
                 if [ $countg -eq $numclines ]; then
                   return 0
                 fi
               else
                 echo "$line"
                 ((countg++)) # count # of commands written to output
                 if [ $countg -eq $numclines ]; then 
                   return 0 
                 fi
               fi
              ;;
            esac
         ;;
      esac
    fi
  done
  if [[ $countg -lt $numclines ]]; then # output more commands
    rtr=""
    combineScripts commandScripts[@] buildScripts[@]
  fi
#
  if [[ $countg -lt $numclines ]]; then # output remaining commands
    contin=false # switch for a continuation line
    contline=0   # # of continuation lines found
    ifsharedoc=false # test for an if block with a /usr/share/doc in it
    for (( k=$countg; k<$((numclines)); k++ )); do
#msg "command is ${commandScripts[k]}"
      case ${commandScripts[k]} in
         install*)
                case ${commandScripts[k]} in
                   *'/usr/share/doc'*) # if a cont line then store it, otherwise ignore it
                       case ${commandScripts[k]} in
                          *\\) # a continuation line
                             cacheit[contline++]=${commandScripts[k]}
                             contin=true
                          ;;
                       esac
                   ;;
                   *\\) # a continuation line
                       cacheit[contline++]=${commandScripts[k]}
                       contin=true
                   ;;
                   *) # install but not a doc or a cont line
                       echo ${commandScripts[k]}
                   ;;
                esac
         ;;
         if*) # starts with if so if a doc, will need to delete the closing fi
                case ${commandScripts[k]} in
                   *'/usr/share/doc'*)
                       ifsharedoc=true
                       case ${commandScripts[k]} in
                          *\\) # a continuation line
                             cacheit[contline++]=${commandScripts[k]}
                             contin=true
                          ;;
                       esac
                   ;;
                   *\\) # a continuation line
                       cacheit[contline++]=${commandScripts[k]}
                       contin=true
                   ;;
                   *) # if test but not a doc or a cont line
                       echo ${commandScripts[k]}
                   ;;
                esac
         ;;
         ln*) # a symlink so write it - e.g. vim74
                echo ${commandScripts[k]}
         ;;
         *'/usr/share/doc'*)
                case ${commandScripts[k]} in
                    *\\) # a continuation line
                       if $tarCom; then # part of a tar command so write it to the cache
                         cacheit[contline++]=${commandScripts[k]}
                       fi
                       contin=true
                    ;;
                    *)
                       if $contin; then # is a doc, so don't write
                         contin=false
                         contline=0
                       fi
                    ;;
                esac
         ;;
         "fi"*)
                if $ifsharedoc; then # end of a doc if test - don't write it
# *** if you want the docs, then write out cacheit plus the current line here ***
                  ifsharedoc=false
                else
                  echo ${commandScripts[k]} # if block is not a doc
                fi
         ;;
         *)
                if ! $ifsharedoc; then # commands not within a doc if block
                  case ${commandScripts[k]} in
                      *\\) # continuation line, store it
                           cacheit[contline++]=${commandScripts[k]}
                           contin=true
                      ;;
                      *)
                           if [ $contline -gt 0 ]; then # write out continuation lines
                             for (( l=0; l<$contline; l++ )); do
                               echo "${cacheit[l]}"
                             done
                             contin=false
                             tarCom=false
                             contline=0
                           fi
                           echo ${commandScripts[k]}
                      ;;
                  esac
                else # ifsharedoc is true - this shouldn't happen
                  echo "ifsharedoc is true - *** INVESTIGATE ***"
                  exit 1
                fi
         ;;
      esac
    done
  fi
fi
return 0
fi
} # end GetCommands
#
bzip2DestdirComms () {
local bzip2destcom
bzip2destcom[0]="patch -Np1 -i ../bzip2-1.0.8-install_docs-1.patch"
bzip2destcom[1]="sed -i 's@\(ln -s -f \)\$(PREFIX)/bin/@\1@' Makefile"
bzip2destcom[2]='sed -i "s@(PREFIX)/man@(PREFIX)/share/man@g" Makefile'
bzip2destcom[3]="make -f Makefile-libbz2_so"
bzip2destcom[4]="make clean"
bzip2destcom[5]="make"
bzip2destcom[6]="install -dm755 \"\$CUR_DIR\"/usr/{bin,lib,include,share/man/man1}"
bzip2destcom[7]="install -m755 bzip2-shared \"\$CUR_DIR\"/usr/bin/bzip2"
bzip2destcom[8]="install -m755 bzip2recover bzdiff bzgrep bzmore \"\$CUR_DIR\"/usr/bin"
bzip2destcom[9]="ln -sf bzip2 \"\$CUR_DIR\"/usr/bin/bunzip2"
bzip2destcom[10]="ln -sf bzip2 \"\$CUR_DIR\"/usr/bin/bzcat"
bzip2destcom[11]="cp -a libbz2.so* \"\$CUR_DIR\"/usr/lib"
bzip2destcom[12]="ln -s libbz2.so.\$bzip2Vers \"\$CUR_DIR\"/usr/lib/libbz2.so"
bzip2destcom[13]="ln -s libbz2.so.\$bzip2Vers \"\$CUR_DIR\"/usr/lib/libbz2.so.1"
bzip2destcom[14]="install -m644 bzlib.h \"\$CUR_DIR\"/usr/include/"
bzip2destcom[15]="install -m644 bzip2.1 \"\$CUR_DIR\"/usr/share/man/man1/"
bzip2destcom[16]="ln -sf bzip2.1 \"\$CUR_DIR\"/usr/share/man/man1/bunzip2.1"
bzip2destcom[17]="ln -sf bzip2.1 \"\$CUR_DIR\"/usr/share/man/man1/bzcat.1"
bzip2destcom[18]="ln -sf bzip2.1 \"\$CUR_DIR\"/usr/share/man/man1/bzip2recover.1"
rtrncommands=(${bzip2destcom[@]})
} # end bzip2DestdirComms
#
dbusComms () {
local dbuscom=""
dbuscom[0]="./configure --prefix=/usr \\"
dbuscom[1]="            --sysconfdir=/etc \\"
dbuscom[2]="            --localstatedir=/var \\"
dbuscom[3]="            --libexecdir=/usr/lib/dbus-1.0 \\"
dbuscom[4]="            --docdir=/usr/share/doc/dbus-${dbusvers} \\"
dbuscom[5]="            --with-system-pid-file=/run/dbus/pid \\"
dbuscom[6]="            --with-system-socket=/run/dbus/system_bus_socket \\"
dbuscom[7]="            --disable-static \\"
dbuscom[8]="            --enable-systemd \\"
dbuscom[9]="            --with-console-auth-dir=/run/console/ \\"
dbuscom[10]="            --with-systemdsystemunitdir=/usr/lib/systemd/system"
dbuscom[11]="make"
dbuscom[12]="make install"
dbuscom[13]="ln -s /etc/machine-id /var/lib/dbus"
rtrncommands=(${dbuscom[@]})
} # end dbusComms
#
gccComms () {
local gcccom=""
gcccom[0]='case $(uname -m) in'
gcccom[1]="  x86_64)"
gcccom[2]="    sed -i.orig '/m64=/s/lib64/lib/' gcc/config/i386/t-linux64"
gcccom[3]="  ;;"
gcccom[4]="esac"
gcccom[5]="mkdir build"
gcccom[6]="cd build"
gcccom[7]="../configure --prefix=/usr      \\"
gcccom[8]="             --disable-multilib \\"
gcccom[9]="             --with-system-zlib \\"
gcccom[10]="             --enable-languages=c,c++,fortran"
gcccom[11]="make"
gcccom[12]="make install"
gcccom[13]="mkdir -pv /usr/share/gdb/auto-load/usr/lib"
gcccom[14]="mv -v /usr/lib/*gdb.py /usr/share/gdb/auto-load/usr/lib"
gcccom[15]="ln -v -sf ../usr/bin/cpp /lib"
gcccom[16]="ln -v -sf gcc /usr/bin/cc"
gcccom[17]="install -v -dm755 /usr/lib/bfd-plugins"
gcccom[18]='ln -sfv ../../libexec/gcc/$(gcc -dumpmachine)/${gccVers}/liblto_plugin.so /usr/lib/bfd-plugins/'
rtrncommands=(${gcccom[@]})
} # end gccComms
#
gccDestdirComms () {
local gccdestcom=""
gccdestcom[0]='case $(uname -m) in'
gccdestcom[1]="  x86_64)"
gccdestcom[2]="    sed -i.orig '/m64=/s/lib64/lib/' gcc/config/i386/t-linux64"
gccdestcom[3]="  ;;"
gccdestcom[4]="esac"
gccdestcom[5]="mkdir build"
gccdestcom[6]="cd build"
gccdestcom[7]="../configure --prefix=/usr      \\"
gccdestcom[8]="             --disable-multilib \\"
gccdestcom[9]="             --with-system-zlib \\"
gccdestcom[10]="             --enable-languages=c,c++,fortran"
gccdestcom[11]="make"
gccdestcom[12]="make DESTDIR=\"\$CUR_DIR\" install"
gccdestcom[13]="mkdir -pv \"\$CUR_DIR\"/usr/share/gdb/auto-load/usr/lib"
gccdestcom[14]="mv -v \"\$CUR_DIR\"/usr/lib/*gdb.py \"\$CUR_DIR\"/usr/share/gdb/auto-load/usr/lib"
gccdestcom[15]="ln -v -sf ../usr/bin/cpp \"\$CUR_DIR\"/lib"
gccdestcom[16]="ln -v -sf gcc \"\$CUR_DIR\"/usr/bin/cc"
gccdestcom[17]="install -v -dm755 \"\$CUR_DIR\"/usr/lib/bfd-plugins"
gccdestcom[18]='ln -sfv ../../libexec/gcc/$(gcc -dumpmachine)/${gccVers}/liblto_plugin.so "$CUR_DIR"/usr/lib/bfd-plugins/'
rtrncommands=(${gccdestcom[@]})
} # end gccDestdirComms
#
mesonDestdirComms () {
local mesondestcom=""
mesondestcom[0]="pip3 wheel -w dist --no-build-isolation --no-deps \$PWD"
mesondestcom[1]="PYTHONPATH=src python3 -m installer --destdir=\"\$CUR_DIR\" dist/*.whl"
mesondestcom[2]="install -dm0755 \"\${CUR_DIR}\"/usr/bin"
mesondestcom[3]="install -vDm644 data/shell-completions/bash/meson \"\${CUR_DIR}\"/usr/share/bash-completion/completions/meson"
mesondestcom[4]="install -vDm644 data/shell-completions/zsh/_meson \"\${CUR_DIR}\"/usr/share/zsh/site-functions/_meson"
rtrncommands=(${mesondestcom[@]})
} # end mesonDestdirComms
#
ncursesComms () {
local ncursescom=""
ncursescom[0]="./configure --prefix=/usr           \\"
ncursescom[1]="            --mandir=/usr/share/man \\"
ncursescom[2]="            --with-shared           \\"
ncursescom[3]="            --without-debug         \\"
ncursescom[4]="            --without-normal        \\"
ncursescom[5]="            --enable-pc-files       \\"
ncursescom[6]="            --enable-widec          \\"
ncursescom[7]="            --with-pkg-config-libdir=/usr/lib/pkgconfig"
ncursescom[8]="make"
ncursescom[9]="make DESTDIR=\"\$CUR_DIR\" install"
ncursescom[10]="install -vm755 \"\${CUR_DIR}\"/usr/lib/libncursesw.so.${ncursesvers} /usr/lib"
ncursescom[11]="rm -v \"\${CUR_DIR}\"/usr/lib/{libncursesw.so.${ncursesvers},libncurses++w.a}"
ncursescom[12]="set +e"
ncursescom[13]="pushd ../usr > /dev/null"
ncursescom[14]="cp -a * /usr"
ncursescom[15]="popd > /dev/null"
ncursescom[16]="set -e"
ncursescom[17]="for lib in ncurses form panel menu ; do"
ncursescom[18]="    rm -vf                    /usr/lib/lib\${lib}.so"
ncursescom[19]="    echo \"INPUT(-l\${lib}w)\" > /usr/lib/lib\${lib}.so"
ncursescom[20]="    ln -sfv \${lib}w.pc        /usr/lib/pkgconfig/\${lib}.pc"
ncursescom[21]="done"
ncursescom[22]="rm -vf                     /usr/lib/libcursesw.so"
ncursescom[23]="echo \"INPUT(-lncursesw)\" > /usr/lib/libcursesw.so"
ncursescom[24]="ln -sfv libncurses.so      /usr/lib/libcurses.so"
rtrncommands=(${ncursescom[@]})
} # end ncursesComms
#
ncursesDestdirComms () {
local ncursesdestcom=""
ncursesdestcom[0]="./configure --prefix=/usr           \\"
ncursesdestcom[1]="            --mandir=/usr/share/man \\"
ncursesdestcom[2]="            --with-shared           \\"
ncursesdestcom[3]="            --without-debug         \\"
ncursesdestcom[4]="            --without-normal        \\"
ncursesdestcom[5]="            --enable-pc-files       \\"
ncursesdestcom[6]="            --enable-widec          \\"
ncursesdestcom[7]="            --with-pkg-config-libdir=/usr/lib/pkgconfig"
ncursesdestcom[8]="make"
ncursesdestcom[9]="make DESTDIR=\"\$CUR_DIR\" install"
ncursesdestcom[10]="rm -v \"\${CUR_DIR}\"/usr/lib/libncurses++w.a"
ncursesdestcom[11]="for lib in ncurses form panel menu ; do"
ncursesdestcom[12]="    rm -vf                    \"\${CUR_DIR}\"/usr/lib/lib\${lib}.so"
ncursesdestcom[13]="    echo \"INPUT(-l\${lib}w)\" > \"\${CUR_DIR}\"/usr/lib/lib\${lib}.so"
ncursesdestcom[14]="    ln -sfv \${lib}w.pc        \"\${CUR_DIR}\"/usr/lib/pkgconfig/\${lib}.pc"
ncursesdestcom[15]="done"
ncursesdestcom[16]="rm -vf                     \"\${CUR_DIR}\"/usr/lib/libcursesw.so"
ncursesdestcom[17]="echo \"INPUT(-lncursesw)\" > \"\${CUR_DIR}\"/usr/lib/libcursesw.so"
ncursesdestcom[18]="ln -sfv libncurses.so      \"\${CUR_DIR}\"/usr/lib/libcurses.so"
rtrncommands=(${ncursesdestcom[@]})
} # end ncursesDestdirComms
#
pymodDestdirComms () {
local pymoduledestcom=""
#pymoduledestcom[0]="python3 -m build -n" # need py3-build installed
pymoduledestcom[0]="pip3 wheel -w dist --no-build-isolation --no-deps \$PWD"
pymoduledestcom[1]="PYTHONPATH=src python3 -m installer --destdir=\"\$CUR_DIR\" dist/*.whl"
rtrncommands=(${pymoduledestcom[@]})
} # end pymodDestdirComms
#
shadowComms () {
local shadowcom=""
shadowcom[0]="sed -i 's/groups\$(EXEEXT) //' src/Makefile.in"
shadowcom[1]="find man -name Makefile.in -exec sed -i 's/groups\\.1 / /'   {} \\;"
shadowcom[2]="find man -name Makefile.in -exec sed -i 's/getspnam\\.3 / /' {} \\;"
shadowcom[3]="find man -name Makefile.in -exec sed -i 's/passwd\\.5 / /'   {} \\;"
shadowcom[4]="sed -e 's@#ENCRYPT_METHOD DES@ENCRYPT_METHOD SHA512@' \\"
shadowcom[5]="    -e 's@/var/spool/mail@/var/mail@'                 \\"
shadowcom[6]="    -e '/PATH=/{s@/sbin:@@;s@/bin:@@}'                \\"
shadowcom[7]="    -i etc/login.defs"
shadowcom[8]="sed -i -e 's/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\/uk/' \\"
shadowcom[9]="       -e 's/uk zh_CN zh_TW//' \\"
shadowcom[10]="       -e 's/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr /uk/' man/Makefile.in"
shadowcom[11]="./configure --sysconfdir=/etc \\"
shadowcom[12]="            --with-libcrack \\"
shadowcom[13]="            --disable-static  \\"
shadowcom[14]="            --with-group-name-max-length=32"
shadowcom[15]="make"
shadowcom[16]="make exec_prefix=/usr install"
shadowcom[17]="make -C man install-man"
shadowcom[18]="install -v -m644 /etc/login.defs /etc/login.defs.orig"
shadowcom[19]="for FUNCTION in FAIL_DELAY               \\"
shadowcom[20]="                FAILLOG_ENAB             \\"
shadowcom[21]="                LASTLOG_ENAB             \\"
shadowcom[22]="                MAIL_CHECK_ENAB          \\"
shadowcom[23]="                OBSCURE_CHECKS_ENAB      \\"
shadowcom[24]="                PORTTIME_CHECKS_ENAB     \\"
shadowcom[25]="                QUOTAS_ENAB              \\"
shadowcom[26]="                CONSOLE MOTD_FILE        \\"
shadowcom[27]="                FTMP_FILE NOLOGINS_FILE  \\"
shadowcom[28]="                ENV_HZ PASS_MIN_LEN      \\"
shadowcom[29]="                SU_WHEEL_ONLY            \\"
shadowcom[30]="                CRACKLIB_DICTPATH        \\"
shadowcom[31]="                PASS_CHANGE_TRIES        \\"
shadowcom[32]="                PASS_ALWAYS_WARN         \\"
shadowcom[33]="                CHFN_AUTH ENCRYPT_METHOD \\"
shadowcom[34]="                ENVIRON_FILE"
shadowcom[35]="do"
shadowcom[36]='    sed -i "s/^${FUNCTION}/# &/" /etc/login.defs'
shadowcom[37]="done"
shadowcom[38]='cat > /etc/pam.d/login << "EOF"'
shadowcom[39]="# Begin /etc/pam.d/login"
shadowcom[40]="# Set failure delay before next prompt to 3 seconds"
shadowcom[41]="auth      optional    pam_faildelay.so  delay=3000000"
shadowcom[42]="# Check to make sure that the user is allowed to login"
shadowcom[43]="auth      requisite   pam_nologin.so"
shadowcom[44]="# Check to make sure that root is allowed to login"
shadowcom[45]="# Disabled by default. You will need to create /etc/securetty"
shadowcom[46]="# file for this module to function. See man 5 securetty."
shadowcom[47]="#auth      required    pam_securetty.so"
shadowcom[48]="# Additional group memberships - disabled by default"
shadowcom[49]="#auth      optional    pam_group.so"
shadowcom[50]="# include system auth settings"
shadowcom[51]="auth      include     system-auth"
shadowcom[52]="# check access for the user"
shadowcom[53]="account   required    pam_access.so"
shadowcom[54]="# include system account settings"
shadowcom[55]="account   include     system-account"
shadowcom[56]="# Set default environment variables for the user"
shadowcom[57]="session   required    pam_env.so"
shadowcom[58]="# Set resource limits for the user"
shadowcom[59]="session   required    pam_limits.so"
shadowcom[60]="# Display date of last login - Disabled by default"
shadowcom[61]="#session   optional    pam_lastlog.so"
shadowcom[62]="# Display the message of the day - Disabled by default"
shadowcom[63]="#session   optional    pam_motd.so"
shadowcom[64]="# Check user's mail - Disabled by default"
shadowcom[65]="#session   optional    pam_mail.so      standard quiet"
shadowcom[66]="# include system session and password settings"
shadowcom[67]="session   include     system-session"
shadowcom[68]="password  include     system-password"
shadowcom[69]="# End /etc/pam.d/login"
shadowcom[70]="EOF"
shadowcom[71]='cat > /etc/pam.d/passwd << "EOF"'
shadowcom[72]="# Begin /etc/pam.d/passwd"
shadowcom[73]="password  include     system-password"
shadowcom[74]="# End /etc/pam.d/passwd"
shadowcom[75]="EOF"
shadowcom[76]='cat > /etc/pam.d/su << "EOF"'
shadowcom[77]="# Begin /etc/pam.d/su"
shadowcom[78]="# always allow root"
shadowcom[79]="auth      sufficient  pam_rootok.so"
shadowcom[80]="# Allow users in the wheel group to execute su without a password"
shadowcom[81]="# disabled by default"
shadowcom[82]="#auth      sufficient  pam_wheel.so trust use_uid"
shadowcom[83]="# include system auth settings"
shadowcom[84]="auth      include     system-auth"
shadowcom[85]="# limit su to users in the wheel group"
shadowcom[86]="auth      required    pam_wheel.so use_uid"
shadowcom[87]="# include system account settings"
shadowcom[88]="account   include     system-account"
shadowcom[89]="# Set default environment variables for the service user"
shadowcom[90]="session   required    pam_env.so"
shadowcom[91]="# include system session settings"
shadowcom[92]="session   include     system-session"
shadowcom[93]="# End /etc/pam.d/su"
shadowcom[94]="EOF"
shadowcom[95]='cat > /etc/pam.d/chpasswd << "EOF"'
shadowcom[96]="# Begin /etc/pam.d/chpasswd"
shadowcom[97]="# always allow root"
shadowcom[98]="auth      sufficient  pam_rootok.so"
shadowcom[99]="# include system auth and account settings"
shadowcom[100]="auth      include     system-auth"
shadowcom[101]="account   include     system-account"
shadowcom[102]="password  include     system-password"
shadowcom[103]="# End /etc/pam.d/chpasswd"
shadowcom[104]="EOF"
shadowcom[105]="sed -e s/chpasswd/newusers/ /etc/pam.d/chpasswd >/etc/pam.d/newusers"
shadowcom[106]='cat > /etc/pam.d/chage << "EOF"'
shadowcom[107]="# Begin /etc/pam.d/chage"
shadowcom[108]="# always allow root"
shadowcom[109]="auth      sufficient  pam_rootok.so"
shadowcom[110]="# include system auth and account settings"
shadowcom[111]="auth      include     system-auth"
shadowcom[112]="account   include     system-account"
shadowcom[113]="# End /etc/pam.d/chage"
shadowcom[114]="EOF"
shadowcom[115]="for PROGRAM in chfn chgpasswd chsh groupadd groupdel \\"
shadowcom[116]="               groupmems groupmod useradd userdel usermod"
shadowcom[117]="do"
shadowcom[118]='    install -v -m644 /etc/pam.d/chage /etc/pam.d/${PROGRAM}'
shadowcom[119]='    sed -i "s/chage/$PROGRAM/" /etc/pam.d/${PROGRAM}'
shadowcom[120]="done"
shadowcom[121]="[ -f /etc/login.access ] && mv -v /etc/login.access{,.NOUSE}"
shadowcom[122]="[ -f /etc/limits ] && mv -v /etc/limits{,.NOUSE}"
rtrncommands=(${shadowcom[@]})
} # end shadowComms
# same as above but using DESTDIR
shadowDestdirComms () {
local shadowdestcom=""
shadowdestcom[0]="sed -i 's/groups\$(EXEEXT) //' src/Makefile.in"
shadowdestcom[1]="find man -name Makefile.in -exec sed -i 's/groups\\.1 / /'   {} \\;"
shadowdestcom[2]="find man -name Makefile.in -exec sed -i 's/getspnam\\.3 / /' {} \\;"
shadowdestcom[3]="find man -name Makefile.in -exec sed -i 's/passwd\\.5 / /'   {} \\;"
shadowdestcom[4]="sed -e 's@#ENCRYPT_METHOD DES@ENCRYPT_METHOD SHA512@' \\"
shadowdestcom[5]="    -e 's@/var/spool/mail@/var/mail@'                 \\"
shadowdestcom[6]="    -e '/PATH=/{s@/sbin:@@;s@/bin:@@}'                \\"
shadowdestcom[7]="    -i etc/login.defs"
shadowdestcom[8]="sed -i -e 's/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\/uk/' \\"
shadowdestcom[9]="       -e 's/uk zh_CN zh_TW//' \\"
shadowdestcom[10]="       -e 's/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr /uk/' man/Makefile.in"
shadowdestcom[11]="./configure --sysconfdir=/etc \\"
shadowdestcom[12]="            --disable-static  \\"
shadowdestcom[13]="            --with-libcrack \\"
shadowdestcom[14]="            --with-group-name-max-length=32"
shadowdestcom[15]="make"
shadowdestcom[16]="make exec_prefix=/usr DESTDIR=\"\$CUR_DIR\" install"
shadowdestcom[17]="make -C man DESTDIR=\"\$CUR_DIR\" install-man"
shadowdestcom[18]="install -v -m644 \"\${CUR_DIR}\"/etc/login.defs \"\${CUR_DIR}\"/etc/login.defs.orig"
shadowdestcom[19]="for FUNCTION in FAIL_DELAY               \\"
shadowdestcom[20]="                FAILLOG_ENAB             \\"
shadowdestcom[21]="                LASTLOG_ENAB             \\"
shadowdestcom[22]="                MAIL_CHECK_ENAB          \\"
shadowdestcom[23]="                OBSCURE_CHECKS_ENAB      \\"
shadowdestcom[24]="                PORTTIME_CHECKS_ENAB     \\"
shadowdestcom[25]="                QUOTAS_ENAB              \\"
shadowdestcom[26]="                CONSOLE MOTD_FILE        \\"
shadowdestcom[27]="                FTMP_FILE NOLOGINS_FILE  \\"
shadowdestcom[28]="                ENV_HZ PASS_MIN_LEN      \\"
shadowdestcom[29]="                SU_WHEEL_ONLY            \\"
shadowdestcom[30]="                CRACKLIB_DICTPATH        \\"
shadowdestcom[31]="                PASS_CHANGE_TRIES        \\"
shadowdestcom[32]="                PASS_ALWAYS_WARN         \\"
shadowdestcom[33]="                CHFN_AUTH ENCRYPT_METHOD \\"
shadowdestcom[34]="                ENVIRON_FILE"
shadowdestcom[35]="do"
shadowdestcom[36]='    sed -i "s/^${FUNCTION}/# &/" "${CUR_DIR}"/etc/login.defs'
shadowdestcom[37]="done"
shadowdestcom[38]='cat > "${CUR_DIR}"/etc/pam.d/login << "EOF"'
shadowdestcom[39]="# Begin /etc/pam.d/login"
shadowdestcom[40]="# Set failure delay before next prompt to 3 seconds"
shadowdestcom[41]="auth      optional    pam_faildelay.so  delay=3000000"
shadowdestcom[42]="# Check to make sure that the user is allowed to login"
shadowdestcom[43]="auth      requisite   pam_nologin.so"
shadowdestcom[44]="# Check to make sure that root is allowed to login"
shadowdestcom[45]="# Disabled by default. You will need to create /etc/securetty"
shadowdestcom[46]="# file for this module to function. See man 5 securetty."
shadowdestcom[47]="#auth      required    pam_securetty.so"
shadowdestcom[48]="# Additional group memberships - disabled by default"
shadowdestcom[49]="#auth      optional    pam_group.so"
shadowdestcom[50]="# include system auth settings"
shadowdestcom[51]="auth      include     system-auth"
shadowdestcom[52]="# check access for the user"
shadowdestcom[53]="account   required    pam_access.so"
shadowdestcom[54]="# include system account settings"
shadowdestcom[55]="account   include     system-account"
shadowdestcom[56]="# Set default environment variables for the user"
shadowdestcom[57]="session   required    pam_env.so"
shadowdestcom[58]="# Set resource limits for the user"
shadowdestcom[59]="session   required    pam_limits.so"
shadowdestcom[60]="# Display date of last login - Disabled by default"
shadowdestcom[61]="#session   optional    pam_lastlog.so"
shadowdestcom[62]="# Display the message of the day - Disabled by default"
shadowdestcom[63]="#session   optional    pam_motd.so"
shadowdestcom[64]="# Check user's mail - Disabled by default"
shadowdestcom[65]="#session   optional    pam_mail.so      standard quiet"
shadowdestcom[66]="# include system session and password settings"
shadowdestcom[67]="session   include     system-session"
shadowdestcom[68]="password  include     system-password"
shadowdestcom[69]="# End /etc/pam.d/login"
shadowdestcom[70]="EOF"
shadowdestcom[71]='cat > "${CUR_DIR}"/etc/pam.d/passwd << "EOF"'
shadowdestcom[72]="# Begin /etc/pam.d/passwd"
shadowdestcom[73]="password  include     system-password"
shadowdestcom[74]="# End /etc/pam.d/passwd"
shadowdestcom[75]="EOF"
shadowdestcom[76]='cat > "${CUR_DIR}"/etc/pam.d/su << "EOF"'
shadowdestcom[77]="# Begin /etc/pam.d/su"
shadowdestcom[78]="# always allow root"
shadowdestcom[79]="auth      sufficient  pam_rootok.so"
shadowdestcom[80]="# Allow users in the wheel group to execute su without a password"
shadowdestcom[81]="# disabled by default"
shadowdestcom[82]="#auth      sufficient  pam_wheel.so trust use_uid"
shadowdestcom[83]="# include system auth settings"
shadowdestcom[84]="auth      include     system-auth"
shadowdestcom[85]="# limit su to users in the wheel group"
shadowdestcom[86]="auth      required    pam_wheel.so use_uid"
shadowdestcom[87]="# include system account settings"
shadowdestcom[88]="account   include     system-account"
shadowdestcom[89]="# Set default environment variables for the service user"
shadowdestcom[90]="session   required    pam_env.so"
shadowdestcom[91]="# include system session settings"
shadowdestcom[92]="session   include     system-session"
shadowdestcom[93]="# End /etc/pam.d/su"
shadowdestcom[94]="EOF"
shadowdestcom[95]='cat > "${CUR_DIR}"/etc/pam.d/chpasswd << "EOF"'
shadowdestcom[96]="# Begin /etc/pam.d/chpasswd"
shadowdestcom[97]="# always allow root"
shadowdestcom[98]="auth      sufficient  pam_rootok.so"
shadowdestcom[99]="# include system auth and account settings"
shadowdestcom[100]="auth      include     system-auth"
shadowdestcom[101]="account   include     system-account"
shadowdestcom[102]="password  include     system-password"
shadowdestcom[103]="# End /etc/pam.d/chpasswd"
shadowdestcom[104]="EOF"
shadowdestcom[105]="sed -e s/chpasswd/newusers/ \"\${CUR_DIR}\"/etc/pam.d/chpasswd >\"\${CUR_DIR}\"/etc/pam.d/newusers"
shadowdestcom[106]='cat > "${CUR_DIR}"/etc/pam.d/chage << "EOF"'
shadowdestcom[107]="# Begin /etc/pam.d/chage"
shadowdestcom[108]="# always allow root"
shadowdestcom[109]="auth      sufficient  pam_rootok.so"
shadowdestcom[110]="# include system auth and account settings"
shadowdestcom[111]="auth      include     system-auth"
shadowdestcom[112]="account   include     system-account"
shadowdestcom[113]="# End /etc/pam.d/chage"
shadowdestcom[114]="EOF"
shadowdestcom[115]="for PROGRAM in chfn chgpasswd chsh groupadd groupdel \\"
shadowdestcom[116]="               groupmems groupmod useradd userdel usermod"
shadowdestcom[117]="do"
shadowdestcom[118]='    install -v -m644 "${CUR_DIR}"/etc/pam.d/chage "${CUR_DIR}"/etc/pam.d/${PROGRAM}'
shadowdestcom[119]='    sed -i "s/chage/$PROGRAM/" "${CUR_DIR}"/etc/pam.d/${PROGRAM}'
shadowdestcom[120]="done"
shadowdestcom[121]="[ -f \"\${CUR_DIR}\"/etc/login.access ] && mv -v \"\${CUR_DIR}\"/etc/login.access{,.NOUSE}"
shadowdestcom[122]="[ -f \"\${CUR_DIR}\"/etc/limits ] && mv -v \"\${CUR_DIR}\"/etc/limits{,.NOUSE}"
rtrncommands=(${shadowdestcom[@]})
} # end shadowDestdirComms
#
wheelDestdirComms () {
local wheeldestcom=""
#wheeldestcom[0]="python3 -m build -n" # need py3-build installed
wheeldestcom[0]="pip3 wheel -w dist --no-build-isolation --no-deps \$PWD"
wheeldestcom[1]="PYTHONPATH=src python3 -m installer --destdir=\"\$CUR_DIR\" dist/*.whl"
rtrncommands=(${wheeldestcom[@]})
} # end wheelDestdirComms
#
GetInternalCommands () {
# $1 is the function name that creates the commands
# get access to the build array
rtrnBuild=""
getBuild
return_val=$?
if [ $return_val -eq $RETURN_PARAM ]; then # no build file present
  return $RETURN_PARAM
else
  buildScripts=(${rtrnBuild[@]})
  declare -a rtrncommands=""
  eval $1
  commandScripts=(${rtrncommands[@]})
  numclines=${#commandScripts[@]}
  countg=0 # initialize commands counter
  cont=0
  for line in "${commandScripts[@]}"; do
    case "$line" in
       sed*)
# test if sed has continuation line
         case "$line" in
           *\\)
             cacheit[cont++]="$line"
             ((countg++))
           ;;
           *)
             echo "$line"
             ((countg++))
           ;;
         esac
       ;;
       *configure*)
         break
       ;;
       make*) #  if no configure script present
         break
       ;;
       "perl Makefile.PL") # for perl modules
         break
       ;;
       "python3 -m build"*) # for wheel with destdir
         break
       ;;
       "pip3 wheel -w dist "*) # for meson with destdir
         break
       ;;
       *)
         case "$line" in
            *\\) # if a continuation line then store in cache
             cacheit[cont++]="$line"
             ((countg++))
            ;;
            *)
             if [ $cont -gt 0 ]; then # continuation line found
               for (( l=0; l<$cont; l++ )); do
                 echo "${cacheit[l]}"
               done
               echo "$line"
               cont=0
               ((countg++)) # count # of commands written to output
             else
               echo "$line"
               ((countg++)) # count # of commands written to output
             fi
            ;;
          esac
       ;;
    esac
  done
#
  rtr=""
  combineScripts commandScripts[@] buildScripts[@]
#
  if [ $countg -lt $numclines ]; then # output remaining commands
    contin=false # reset continuation line indicator
    for (( k=$countg; k<$numclines; k++ )); do
      if [[ "${commandScripts[k]}" == install* ]]; then #don't install docs
        case ${commandScripts[k]} in
            *\\) # continuation line
                contin=true
            ;;
            */usr/share/doc*) # doc so don't write the command
# * NOTE *if you want the docs, write this line
                continue
            ;;
            *) # not a doc so write it
                echo ${commandScripts[k]}
            ;;
        esac
      else
        if $contin; then
          if [[ "${commandScripts[k]}" == *\\ ]]; then # more continuation
            :
          else
            contin=false
          fi
        else
          echo ${commandScripts[k]}
        fi
      fi
    done
  fi
  return 0
fi
} # end GetInternalCommands
#
createPkguser () {
cat >> $Output << "CPUEOF"
createPkguser () {
# $1 is the UID of the package
# $2 is the GID of the package. In this scheme UID = GID
# if $1 and $2 are 0, then the values are incremented on the initial value of 10000
# does the $PkgName user exist?
ret=false
getent passwd $PkgName > /dev/null 2>&1 && ret=true
if $ret; then
  echo "user $PkgName exists"
# make sure the home dir exists
  mkdir -pv ${PkgUserDir}/${PkgName}
else # create it and add it to the install group
  echo "Creating the user $PkgName"
  if [ $2 -ne 0 ]; then
    groupadd -g $2 $PkgName
    mkdir -pv ${PkgUserDir}/${PkgName}
    useradd -d ${PkgUserDir}/${PkgName} -s /bin/bash -u $1 -g $PkgName -m -k /dev/null $PkgName
  else # increment
    groupadd $PkgName
    useradd -d ${PkgUserDir}/${PkgName} -s /bin/bash -g $PkgName -m -k /dev/null $PkgName
  fi
  usermod -aG install $PkgName # add PkgName to the install group
fi
# create the .bash_profile and .bashrc files if they don't exist
if [ ! -e ${PkgUserDir}/${PkgName}/.bash_profile ]; then
  echo "exec env -i HOME=\$HOME TERM=\$TERM PS1='\u:\w\$ ' ${LFS}/install${PkgName}.sh" >> ${PkgUserDir}/${PkgName}/.bash_profile
fi
if [ ! -e ${PkgUserDir}/${PkgName}/.bashrc ]; then
  cat > ${PkgUserDir}/${PkgName}/.bashrc << "EOF"
set +h
umask 022
LFS=/mnt/lfs
LC_ALL=POSIX
LFS_TGT=$(uname -m)-lfs-linux-gnu
PATH=/usr/bin
if [ ! -L /bin ]; then PATH=/bin:$PATH; fi
PATH=$LFS/tools/bin:$PATH
CONFIG_SITE=$LFS/usr/share/config.site
export LFS LC_ALL LFS_TGT PATH CONFIG_SITE
EOF
fi
} # end createPkguser
#
CPUEOF
} # end createPkguser
#
cleanPkgDir () {
    cat >> $Output << "EOF"
cleanpkgdir () {
# $1 is the dir to clean
# $2 is the pkgname
local dirtoClean=$1
local pkgtoClean=$2
rm -rf ${dirtoClean}/${pkgtoClean}/{..?*,.[!.]*,*}
} # end cleanpkgdir
#
EOF
} # end cleanPkgDir
#
Header () {
if $printit; then msg "writing the script to $Output"; fi
if [[ "$as_root" = true && ("$currentChapter" = chapter05 || "$currentChapter" = chapter06) ]]; then
  cat > $Output << "EOF"
#!/bin/bash -e
#
if [ $UID -eq 0 ]; then
  echo "Please do NOT run this script as root."
  echo "Run it as user lfs."
  exit 1
fi
if [ $(whoami) != "lfs" ]; then echo Please run this script as user lfs. ; exit 1; fi
#
EOF
else # as root and chapter 7,8,10 and update or as pkguser
  cat > $Output << "EOF"
#!/bin/bash -e
#
if [ $UID -ne 0 ]; then echo Please run this script as root. ; exit 1; fi
#
EOF
fi
echo "me=\$0
GITINFO=\"$GITINFO\"
AS_ROOT=$as_root" >> $Output
if $useDESTDIR; then echo "useDESTDIR=$useDESTDIR" >> $Output; fi
case "$currentChapter" in
   chapter05|chapter06)
     echo "Chapter=$Chapter
LFS=$LFS" >> $Output
     if ! $as_root; then
       echo "PkgUserDir=\${LFS}${PkgUserDir}" >> $Output
       cat >> $Output << "EOF"
buildDir=${LFS}/build
if [ ! -d ${LFS}/build ]; then
  mkdir -v ${LFS}/build
fi
chgrp install ${LFS}/{build,LFS-build.log}
chmod 1775 ${LFS}/build
chmod 664 ${LFS}/LFS-build.log
EOF
       createPkguser
     else # as root
       cat >> $Output << "EOF"  
buildDir=${LFS}/build
if [ ! -d ${LFS}/build ]; then
  mkdir -v ${LFS}/build
fi
BuildLog=/LFS-build.log
sourcedir=/sources
sourceloc=${sourcedir}/trunk
#
EOF

       CreateBuildDir
       unpack05
     fi
   ;;
   chapter07|chapter08|chapter10)
       echo "PkgUserDir=$PkgUserDir
sourcedir=$sourcedir
sourceloc=$sourceloc
BuildLog=/$BuildLog
Chapter=$Chapter
pkguserdir=/tools/${pkgFileName}
wgetopts=\"$wgetopts\"
ncc=\"--no-check-certificate\"" >> $Output
       if [[ "$Chapter" = update && "$as_root" = false ]]; then
         echo "# make sure a pkguser can write to BuildLog
chgrp install $BuildLog
chmod 664 $BuildLog" >> $Output
       fi
       if $as_root; then
         CreateBuildDirasroot
         unpack
       else
         setUserEnv # used in the package user home dir to make sure .bash_profile and .bashrc are symlinks to /etc/pkgusr dir
         resetBashProfile # make sure Chapter is set in /etc/pkgusr
       fi
       if [ "$Chapter" = update ]; then
         if $installBinTarfile; then # don't need to clean the pkg directory
           if $printit; then msg "installing binary tarfile(s) so don't use cleanPkgDir"; fi
         else # write the cleanpkgdir function
           cleanPkgDir
         fi
       fi
# if using DESTDIR and not installing files, need to create the binary tarfile
       if $createBinFile; then
         createPkgFile # write createPkgFile
         if [ "$Chapter" = chapter07 ]; then # creating dirs so need createDirsFilesPkgFile
           createDirsFilesPkgFile
         fi
       fi
   ;;
esac
} # end Header
#
unpackPkguser () {
#
# $1 is the pkguser filename
local pkguserFile=$1
if [ -L ${LFS}/tools ]; then
  echo "${LFS}/tools is currently a symbolic link"
  echo "It needs to be a directory."
  rm -v ${LFS}/tools
fi
if [ ! -d ${LFS}/tools ]; then install -vm755 -d ${LFS}/tools; fi
tar -xvf ${LFS}${sourcedir}/${pkguserFile} -C ${LFS}/tools --no-same-owner
if [ $? -ne 0 ]; then
  return $RETURN_PARAM
else
  rm ${LFS}${sourcedir}/${pkguserFile}
  return 0
fi
} #end unpackPkguser
#
copypkguserbin () { # when installing as root, may need listdelpkg.sh
cat >> $Output << "EOF"
copypkguserbin_ () {
FuncName=copypkguserbin
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName" #package already built so skip
  return 0
else
  echo "In function $FuncName"
fi
EOF
echo "pkguserdir=/tools/${pkgFileName}" >> $Output
cat >> $Output << "EOF"
cp ${pkguserdir}/bin/* /usr/bin/
echo "${FuncName}" >> $BuildLog
}
EOF
} # end copypkguserbin
#
pkguser () {
cat >> $Output << "EOF"
pkguser_ () {
FuncName=pkguser
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName" #package already built so skip
  return 0
else
  echo "In function $FuncName"
fi
# check if the required files are already installed
if [[ -e /usr/bin/groupadd && -e /usr/bin/su && -e /usr/bin/useradd ]]; then # installed
  echo "In function pkguser"
  echo "Required files already present"
else
EOF
  echo "  local pkguserdir=/tools/${pkgFileName}" >> $Output
  cat >> $Output << "EOF"
  cp ${pkguserdir}/sbin/* /usr/bin # groupadd, su and useradd (packages from shadow)
  cp ${pkguserdir}/usr/sbin/* /usr/bin # installpkg
  if [ $(uname -m) = x86_64 ]; then
    mv /usr/bin/su64 /usr/bin/su
    chmod 0755 /usr/bin/su
  else
    echo "A 32 bit su doesn't exist"
    echo "You need to create su32 using shadow - aborting"
    exit 1
  fi
  if [ ! -d /etc/pkgusr/skel-package ]; then
    install -v -m0755 -d /etc/pkgusr/skel-package
  fi
  cp -r ${pkguserdir}/etc/* /etc/pkgusr/ # bash_profile, bashrc, skel-package symlinks
  cp ${pkguserdir}/bin/* /usr/bin/ # listdelpkg.sh
  # make them executable
  chmod 755 /usr/bin/{groupadd,useradd,su,installpkg,listdelpkg.sh}
  # set some initial dirs to install and sticky
  chgrp 9999 $(cat ${pkguserdir}/installdirs.lst)
  chmod 1775 $(cat ${pkguserdir}/installdirs.lst)
fi
# check that the install group exists
if [ "$(grep -q ^install\: /etc/group;echo $?)" != 0 ]; then
  groupadd -g 9999 install
fi
# make sure pkgusers can write to the logfile
chgrp install $BuildLog
chmod 664 $BuildLog
EOF
# if using sysvinit for init then build uses /usr/libexec
if [ "$SYSTEMD" = no ]; then # set libexec to an install dir
  echo "chgrp install /usr/libexec
chmod 1775 /usr/libexec" >> $Output
fi
cat >> $Output << "EOF"
echo "${FuncName}" >> $BuildLog
} # end of pkguser
#
EOF
} # end of pkguser
#
updatePkgUser () {
# $1 is the section to use to install the pkg
local section=$1
# this function is called immediately before a pkg is installed to a other than core
echo "updatePkgUser_ () {" >>$Output
cat >> $Output << "EOF"
cat > /etc/pkgusr/bash_profile << "BashProfile"
export PATH=/usr/lib/pkgusr:/bin:/usr/bin
export PROMPT_COMMAND='PS1="package \u:"$(pwd)"> "'
cd
EOF
echo "PkgUserDir=${PKGUSERDIR}/${section}
Chapter=$Chapter
useDESTDIR=$useDESTDIR" >> $Output
cat >> $Output << "EOF"
complete -o default -o nospace -A user su finger pinky
PkgName=$LOGNAME
buildit=false
if $useDESTDIR; then
  testBuilt=".${Chapter}${PkgName}-destdir"
else
  testBuilt=".${Chapter/apter/}${PkgName}"
fi
if [ -e ${PkgUserDir}/${PkgName}/build -a ! -e ~/${testBuilt} ]; then buildit=true; fi
if $buildit; then
  cd
EOF
echo "  bash \${PkgUserDir}/\${PkgName}/$build"  >> $Output
cat >> $Output << "EOF"
  exit
fi
BashProfile
} # end updatePkgUser_
EOF
} # end updatePkgUser
#
resetBashProfile () { # assumes install dir is under /usr/src/core
# recreates bash_profile in /etc/pkgusr to reflect changes in chapter
cat >> $Output << "EOF"
resetBashProfile_ () {
cat > /etc/pkgusr/bash_profile << "BASHPEOF"
export PATH=/bin:/usr/bin

# Make prompt reflect that we are a package user.
export PROMPT_COMMAND='PS1="package \u:"`pwd`"> "'

# Go to the home directory when su to a package user.
cd
#
complete -o default -o nospace -A user su finger pinky
#export PkgName=$LOGNAME
EOF
echo "Chapter=$Chapter" >> $Output
if [ "$Chapter" = update ]; then
  if $useDESTDIR; then
    echo "testBuilt=\".\${Chapter}\${LOGNAME}-destdir\"" >> $Output
  else
    echo "testBuilt=\".\${Chapter}\${LOGNAME}\"" >> $Output
  fi
else
  if $useDESTDIR; then
    echo "testBuilt=\".\${Chapter/apter/}\${LOGNAME}-destdir\"" >> $Output
  else
    echo "testBuilt=\".\${Chapter/apter/}\${LOGNAME}\"" >> $Output
  fi
fi
cat >> $Output << "EOF"
if [ -e /usr/src/core/${LOGNAME}/build -a ! -e ~/${testBuilt} ]; then
  cd
  bash -e /usr/src/core/${LOGNAME}/build
  exit
fi
BASHPEOF
} # resetBashProfile
EOF
} # resetBashProfile
#
update_pkguser () {
cat >> $Output << "EOF"
update_pkguser_ () {
FuncName=update_pkguser
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName" #package already built so skip
  return
fi
EOF
echo "pkguserdir=/tools/${pkgFileName}" >> $Output
cat >> $Output << "EOF"
cp ${pkguserdir}/sbin/* /usr/bin # groupadd, su and useradd (packages from shadow)
cp ${pkguserdir}/usr/sbin/* /usr/bin # installpkg
if [ $(uname -m) = x86_64 ]; then
  mv /usr/bin/su64 /usr/bin/su
else
  echo "This doesn't exist"
  echo "You need to create su32 using shadow - aborting"
  exit 1
  mv /usr/bin/su32 /usr/bin/su
fi
# make sure pkgusers can write to the logfile
chgrp install $BuildLog
chmod 664 $BuildLog
#
cat > /etc/pkgusr/bash_profile << "BashProfile"
export PATH=/bin:/usr/bin:/opt/jdk/bin:/opt/ant/bin:/opt/qt/bin
export PROMPT_COMMAND='PS1="package \u:"$(pwd)"> "'
cd
EOF
echo "PkgUserDir=$PkgUserDir" >> $Output
cat >> $Output << "EOF"
complete -o default -o nospace -A user su finger pinky
#export PkgName=$LOGNAME
EOF
if $useDESTDIR; then
  echo "if [ -e \${PkgUserDir}/\${LOGNAME}/${build} -a ! -e ~/.\${LOGNAME}-destdir ]; then
  cd
  bash \${PkgUserDir}/\${LOGNAME}/$build" >> $Output
else
  echo "if [ -e \${PkgUserDir}/\${LOGNAME}/$build -a ! -e ~/.\${LOGNAME} ]; then
  cd
  bash \${PkgUserDir}/\${LOGNAME}/$build" >> $Output
fi
cat >> $Output << "EOF"
  exit
fi
BashProfile
echo "${FuncName}" >> $BuildLog
}
EOF
} # end update_pkguser
#
delSrcFile () {
echo "cd \$curdir
if ! \$usePip; then cd ..; fi
rm -rf \$curdir
rm -rf .wget-hsts .cache"
} # end of delSrcFile
#
# for py3-flit-core and py3-installer don't need the rm -rf lines as there's no source file
delPy3File () {
echo "cd \$curdir
if ! \$usePip; then cd ..; fi"
} # end of delPy3File
#
setUserEnv () {
cat >> $Output << "EOF"
setUserEnv () {
# delete the .bashrc and .bash_profile files in /usr/src/core/PkgName and
# replace with symlinks to /etc/pkgusr versions. Used in chroot so no LFS needed
# $1 is the package user directory usually /usr/src/core
# $2 is the package name
local PkgUserDir=$1
local PkgName=$2
pushd ${PkgUserDir}/${PkgName} > /dev/null
# make sure .bash_profile and .basrc are symlinks to /etc/pkgusr
rm -rf .bash_profile .bashrc
ln -svf /etc/pkgusr/bash_profile .bash_profile
ln -svf /etc/pkgusr/bashrc .bashrc
chown -h $PkgName:$PkgName .bash*
popd > /dev/null
} # end setUserEnv
EOF
} # end setUserEnv
#
createPkgFile () {
cat >> $Output << "EOF"
createPkgfile () {
# get dir names, make the package tar file and delete the build directories
# $1 is the PkgUserDir directory
# $2 is the PkgName
# if present, $3 is the package version to use, bypassing SetPkgvers
# if present, $4 is the name of the dir that contains the pkg binary tarfile
local PkgUserDir=$1
local PkgName=$2
local pkgvers=${3:-""}
local pkgBinDir=${4:-"pkgbindir"}
local listDIRS extension packageName pkgfilename
local trimto=".tar"
local separator="-"
#
# sometimes the pkg name of the binary is different from PkgName
case $PkgName in
   expect)
      packageName="expect5"
      separator="."
   ;;
   jinja2)
      packageName="Jinja2"
   ;;
   kernel)
      packageName="linux"
   ;;
   markupsafe)
      packageName="MarkupSafe"
   ;;
   python3)
      packageName="Python"
   ;;
   py3-flit-core)
      packageName="flit-core"
   ;;
   py3-installer)
      packageName="installer"
   ;;
   tcl)
      packageName="tcl8"
      trimto="-src.tar"
      separator="."
   ;;
   xml-parser)
      packageName="XML-Parser"
   ;;
   *)
      packageName=$PkgName
   ;;
esac
#
if [ $(uname -m) = x86_64 ]; then
  extension="x86_64.pkg.tar.xz"
else
  extension="i686.pkg.tar.xz"
fi
# go to the install dir
pushd ${PkgUserDir}/${PkgName} > /dev/null # make sure in the right dir
pwd
if [ ! -z "$pkgvers" ]; then
  pkgfilename="${packageName}-${pkgvers}-${extension}"
else
  echo "trimto is $trimto"
  nameToFind="${packageName}${separator}[0-9]*${trimto}.?z*"
#  echo "nameToFind is $nameToFind"
  fndSrcpkg=$(find . -name "$nameToFind")
  fndSrcpkg=${fndSrcpkg##*/} # filename only
#  echo "fndSrcpkg is $fndSrcpkg"
  pkgplusvers="${fndSrcpkg%${trimto}*}"
  pkgfilename="${pkgplusvers}-${extension}"
fi
echo "pkgfilename is $pkgfilename"
listDIRS=$(ls -l --time-style="long-iso" . | grep -E '^d' | awk '{print $8}')
# check the dirs present so as not to delete any needed ones
local chknum=( $listDIRS )
for (( i=0; i<${#chknum[@]}; i++ )); do
  if [[ ${chknum[i]} != boot && ${chknum[i]} != etc && ${chknum[i]} != usr && ${chknum[i]} != var ]]; then
    echo "Directory ${chknum[i]} will be included in the package file"
    echo "Is this correct? (Y/n)"
    read reply
      case $reply in
         [yY]|[yY][Ee][Ss])
              echo "okay continuing"
         ;;
         [nN]|[nN][Oo])
              echo "Will delete ${chknum[i]} from listDIRS"
              listDIRS=${listDIRS/${chknum[i]}/}
echo "listDIRS is now ${listDIRS[@]}"
         ;;
         *)
              echo "okay continuing"
         ;;
      esac
  fi
done
# add the .INSTALL file if present
if [ -e .INSTALL ]; then
  listDIRS="$listDIRS .INSTALL"
fi
tar -cJf $pkgfilename $listDIRS
# mv the package binary file to its own dir
# to be distinct from the source tarfile
mkdir -pv $pkgBinDir
mv -v $pkgfilename $pkgBinDir
if ! $AS_ROOT; then chown -R $PkgName:$PkgName $pkgBinDir; fi
# ask to delete the destdir directories
for dir in $listDIRS; do
  if [ -d $dir ]; then
    echo "Delete dir $dir? (Y/n)"
  elif [ -f $dir ]; then
    echo "Delete file $dir? (Y/n)"
  fi
  read reply
    case $reply in
         [yY]|[yY][Ee][Ss])
              echo "okay deleting $dir"
              rm -rf $dir
         ;;
         [nN]|[nN][Oo])
              echo "okay continuing"
         ;;
         *)
              echo "okay deleting $dir"
              rm -rf $dir
         ;;
    esac
done
popd > /dev/null
} # end createPkgfile
#
EOF
} # end createPkgFile
#
createDirsFilesPkgFile () {
# stores the output from using destdir on creatingdirs and createfiles
cat >> $Output << "EOF"
createDirsFilesPkgfile () {
# get dir names, make the package tar file and delete the build directories
# $1 is the PkgUserDir directory
# $2 is the PkgName
# $3 is the prefix for the tarfile, either creatingdirs or createfiles
local PkgUserDir=$1
local PkgName=$2
local namePrefix=$3
extension="x86_64.pkg.tar.xz"
# go to the install dir
pushd ${PkgUserDir}/${PkgName} > /dev/null # make sure in the correct dir
  pkgfilename="${namePrefix}-${extension}"
  listDIRS=$(ls -l --time-style="long-iso" . | grep -E '^d' | awk '{print $8}')
  tar -cJf $pkgfilename $listDIRS
  mkdir -pv pkgbindir
  mv -v $pkgfilename pkgbindir
# ask to delete the destdir directories
  for dir in $listDIRS; do
    echo "Delete dir $dir? (Y/n)"
    read reply
      case $reply in
         [nN]|[nN][Oo])
              echo "okay continuing"
         ;;
         *)
              echo "okay deleting $dir"
              rm -rf $dir
         ;;
      esac
  done
popd > /dev/null
} # end createDirsFilesPkgfile
#
EOF
} # end createDirsFilesPkgFile
#
destdirInstall () {
cat >> $Output << "EOF"
destdirInstall () {
# install the files from a DESTDIR build
# $1 is the directory containing the files to install
# if present $2 is the pkgname in order to control the location of /usr/libexec
local pkgfileDir=$1
local pkgName=${2:-""}
local eachDir=""
set +e
pushd $pkgfileDir > /dev/null
local listDIRS=$(ls -l --time-style="long-iso" . | grep '^d' | awk '{print $8}')
echo "directories are $listDIRS"
for eachDir in $listDIRS; do
  if [[ $eachDir != etc && $eachDir != lib && $eachDir != usr && $eachDir != var && $eachDir != opt && $eachDir != run && $eachDir != srv && $eachDir != sbin ]]; then
  echo "Install files from directory $eachDir? [y/N]"
    read reply
      case $reply in
         [yY]|[yY][Ee][Ss])
            echo "okay continuing"
         ;;
         [nN]|[nN][Oo])
            echo "Okay, ignoring directory $eachDir"
            continue
         ;;
         *)
            echo "Okay, ignoring directory $eachDir"
            continue
         ;;
      esac
  fi
  echo "installing files in $eachDir"
# take account of symlinks /bin /lib /sbin
  if [ -L "/$eachDir" ]; then # for /bin and /lib it's /usr/$eachDir. For /sbin, /usr/sbin is also a symlink
    echo "dir $eachDir is a symlink"
    if [ "$eachDir" = sbin ]; then # use /usr/bin, not /usr/sbin
      cp -a $eachDir/* /usr/bin
    else
      cp -a $eachDir/* /usr/${eachDir}
    fi
  elif [ "$eachDir" = usr ]; then # deal with symlink usr/sbin if it exists
    pushd usr > /dev/null
    local usrDIRS=$(ls -l --time-style="long-iso" . | grep '^d' | awk '{print $8}')
    echo "directories under usr are $usrDIRS"
    for eachusrDir in $usrDIRS; do
      if [ "$eachusrDir" = sbin ]; then # deal with the /usr/sbin symlink
        cp -a $eachusrDir/* /usr/bin
      elif [ "$eachusrDir" = libexec ]; then # use /usr/lib/${pkgName} instead of /usr/libexec
        cp -a $eachusrDir/* /usr/lib/${pkgName}
      elif [ "$eachusrDir" = man ]; then # use /usr/share/man not /usr/man
        cp -a $eachusrDir/* /usr/share/man
      elif [ "$eachusrDir" = usr ]; then # use /usr/share/man not usr/usr/man
        cp -a $eachusrDir/share/man/* /usr/share/man
      else
        cp -a $eachusrDir /usr
      fi
    done
    popd > /dev/null
  elif [ "$eachDir" = var ]; then # deal with symlinks /var/run and /var/lock if they exist
    pushd var > /dev/null
    local varDIRS=$(ls -l --time-style="long-iso" . | grep '^d' | awk '{print $8}')
    echo "directories under var are $varDIRS"
    for eachvarDir in $varDIRS; do
      if [ "$eachvarDir" = lock ]; then # deal with the /var/lock symlink
        cp -a $eachvarDir/* /run/lock
      elif [ "$eachvarDir" = run ]; then # deal with the /var/run symlink
        cp -a $eachvarDir/* /run
      else
        cp -a $eachvarDir /var
      fi
    done
    popd > /dev/null
  elif [ "$eachDir" = opt ]; then # deal with any symlinks under /opt
    if [ -d "$eachDir/kf5" ]; then
      pushd "$eachDir/kf5" > /dev/null
        local optDIRS=$(ls -l --time-style="long-iso" . | grep '^d' | awk '{print $8}')
        echo "directories under $eachDir/kf5 are $optDIRS"
        for eachoptDir in $optDIRS; do # deal with locale, icons/hicolor, dbus-1, polkit-1 and systemd symlinks
          if [ "$eachoptDir" = etc ]; then # dbus-1 is a symlink
            pushd etc > /dev/null
              local etcDirs=$(ls -l --time-style="long-iso" . | grep '^d' | awk '{print $8}')
              echo "directories under etc are $etcDirs"
              for subdir in $etcDirs; do
                if [ "$subdir" = dbus-1 ]; then # deal with the symlink
                  cp -a dbus-1/*  /etc/dbus-1
                else
                  cp -a $subdir /opt/kf5/etc
                fi
              done
            popd > /dev/null
          elif [ "$eachoptDir" = lib ]; then # systemd is a symlink
            pushd lib > /dev/null
              local libDirs=$(ls -l --time-style="long-iso" . | grep '^d' | awk '{print $8}')
              echo "directories under lib are $libDirs"
              for subdir in $libDirs; do
                if [ "$subdir" = systemd ]; then # deal with the symlink
                  cp -a systemd/*  /usr/lib/systemd
                else
                  cp -a $subdir /opt/kf5/lib
                fi
              done
              local libFiles=$(find -L . -maxdepth 1 -type f) # look for libraries + sonames in the lib dir
              if [ ! -z "$libFiles" ]; then # install them
                local eachFile
                for eachFile in $libFiles; do
                  cp -a $eachFile  /opt/kf5/lib
                done
              else # there are no files in lib
                echo "No files found in opt/kf5/lib, only directories"
              fi
            popd > /dev/null
          elif [ "$eachoptDir" = share ]; then
            pushd share > /dev/null
              local shareDirs=$(ls -l --time-style="long-iso" . | grep '^d' | awk '{print $8}')
              echo "directories under share are $shareDirs"
              for subdir in $shareDirs; do
                if [ "$subdir" = locale ]; then
                  cp -a locale/*  /usr/share/locale
                elif [ "$subdir" = icons ]; then
                  cp -a icons/hicolor/* /usr/share/icons/hicolor
                elif [ "$subdir" = dbus-1 ]; then
                  cp -a dbus-1/* /usr/share/dbus-1
                elif [ "$subdir" = polkit-1 ]; then
                  cp -a polkit-1/* /usr/share/polkit-1
                else
                  cp -a $subdir /opt/kf5/share
                fi
              done
            popd > /dev/null
          else # not dir etc, lib or share
            cp -a $eachoptDir /opt/kf5
          fi
        done
      popd > /dev/null
    fi # test if /opt/kf5
  else
    cp -a $eachDir /
  fi
  echo "Delete dir $eachDir [Y/n]?"
  read reply
    case $reply in
         [yY]|[yY][Ee][Ss])
            echo "okay deleting $eachDir"
            rm -rf $eachDir
         ;;
         [nN]|[nN][Oo])
            echo "okay leaving $eachDir in place"
         ;;
         *)
            echo "okay deleting $eachDir"
            rm -rf $eachDir
         ;;
    esac
done
popd > /dev/null
set -e
} # end destdirInstall
#
EOF
} # end destdirInstall
#
changeURL () {
# change one component of a URL
# $1 is the input URL to change
local inputURL=$1
# $2 is the component to change e.g
# "https://www.kernel.org/pub/linux/kernel/v6.x/
# to change v6.x $2 is 7
local val=$2
# $3 is the string to replace $2 with
local repStrng=$3
#
local compToChange=$(echo $inputURL | awk -F\/ -v var="$val" '{print $var}')
local outputURL=${inputURL/$compToChange/$repStrng}
echo $outputURL
#
} # end changeURL
#
getUrlSrcDnld () {
# get the url to download the src file and, if src downloaded already, the location to copy it from
# $1 is unpack
local unpackType=$1
# $2 is the package name
local pkgname=$2
# if present, $3 is the source tarfile name
local srcTarfile=${3:-""}
# if present, $4 is usually the chapter5 and 6 build directory /build but
# also can be the chapter07, 08 and 10 install dir i.e. /usr/src/core
local buildDir=${4:-""}
# if buildDir is null then, if Chapter=update,  useThisSrcLoc must be null
local useThisSrcLoc=""
serchstr="*$SrcName*.tar.?z*"
# set the search string for oddball cases
case $pkgname in
   kernel|linux-headers)
     serchstr="*/linux-[0-9]*.tar.?z*"
   ;;
   make) # get make not automake
     serchstr="*/make-[0-9]*"
   ;;
   py3-flit-core)
     serchstr="*flit*"
   ;;
   py3-installer)
     serchstr="*installer*"
   ;;
esac
#msg "in getUrlSrcDnld, Chapter is $Chapter"
#msg "unpackType is $unpackType"
#msg "pkgname is $pkgname"
#msg "srcTarfile is $srcTarfile"
#msg "buildDir is $buildDir"
#msg "serchstr is $serchstr"
#
# sourceURL is global and contains the contents of the wget-list file
for srcURL in ${sourceURL[@]}; do
  case $srcURL in
     $serchstr) # found serchstr in the source URL
       case $pkgname in # add the source location for downloaded src files in chapters 5 and 6
          bash|coreutils|diffutils|file|findutils|gawk|glibc|grep|gzip|m4|ncurses|openssl|patch|sed|tar|xz)
            if [ "$Chapter" != update ]; then useThisSrcLoc="${buildDir}/${pkgname}"; fi
          ;;
          binutils)
            if [ "$Chapter" != update ]; then useThisSrcLoc="${buildDir}/binutilspass1"; fi
          ;;
          gcc|gmp|mpc|mpfr)
            if [ "$Chapter" != update ]; then useThisSrcLoc="${buildDir}/gccpass1"; fi
          ;;
          gettext|bison|perl|python3|texinfo|util-linux) # possibly present in chapter08
            if [ "$Chapter" = chapter08 ]; then useThisSrcLoc="${buildDir}/${pkgname}"; fi
          ;;
          kernel|linux-headers) # use the latest kernel
            if [ "$Chapter" = chapter08 ]; then useThisSrcLoc="${buildDir}/${pkgname}"; fi
            if [ "$buildDir" = $preChrootBuild ]; then useThisSrcLoc="${buildDir}/linuxheaders"; fi
            if [[ "$Chapter" = chapter10 || "$Chapter" = update ]]; then
msg "useThisKernelVers is $useThisKernelVers"
# make sure the kernel series is correct in the URL
msg "srcURL is $srcURL"
              local curLinux=${srcURL##*/}
msg "curLinux is $curLinux"
              local kernelSeries=${useThisKernelVers%%.*}
msg "kernelSeries is $kernelSeries"
              local newSeries="v${kernelSeries}.x"
msg "newSeries is $newSeries"
              srcURL=$(changeURL $srcURL 7 $newSeries)
msg "srcURL is $srcURL"
              srcURL=${srcURL/$curLinux}
msg "srcURL is $srcURL"
              srcURL="${srcURL}${srcTarfile}"
msg "srcURL is $srcURL"
            fi
          ;;
          make) # get make not automake
            if [ "$Chapter" != update ]; then useThisSrcLoc="${buildDir}/${FuncName}"; fi
          ;;
          py3-flit-core) # installed in chapter8 from /usr/src/pythonmodules/py3-flit-core
            if [ "$Chapter" = chapter08 ]; then useThisSrcLoc="${buildDir}/py3-flit-core"; fi
          ;;
          py3-installer) # installed in chapter8 from /usr/src/pythonmodules/py3-installer
            if [ "$Chapter" = chapter08 ]; then useThisSrcLoc="${buildDir}/py3-installer"; fi
          ;;
       esac
       echo "$unpackType \$SrcName \"$srcURL\" \"$srcTarfile\" \"$useThisSrcLoc\"" >> $Output
       break
     ;;
  esac
done
#
} # end getUrlSrcDnld
#
dnldAddFiles () {
case $FuncName in
#   autoconf) # need the patch
#     cat >> $Output << "EOF"
#if [ -e ${CUR_DIR}/autoconf-*-consolidated_fixes-1.patch  ]; then
#  echo "patch already in place - will use that"
#elif [ -e ${sourceloc}/autoconf-*-consolidated_fixes-1.patch  ]; then
#  cp -v ${sourceloc}/autoconf-*-consolidated_fixes-1.patch ../
#else # download it
#  if [ -e /usr/bin/wget ]; then # wget exists on target machine
#    wget $wgetopts -O ../autoconf-2.69-consolidated_fixes-1.patch "http://www.linuxfromscratch.org/patches/lfs/development/autoconf-2.69-consolidated_fixes-1.patch"
#  else
#    echo "/usr/bin/wget not found on the target machine"
#    echo "Install it to continue"
#    echo "Aborting"
#    exit 1
#  fi
#fi
#EOF
#   ;;
#   bash) # need the patch
#     echo "bashPatch=\"$bashPatch\"" >> $Output
#     cat >> $Output << "EOF"
#if [ -e ${CUR_DIR}/${bashPatch} ]; then
#  echo "patch already in place - will use that"
#elif [ -e ${sourceloc}/${bashPatch} ]; then
#  cp -v ${sourceloc}/${bashPatch} ../
#else # download it
#  if [ -e /usr/bin/wget ]; then # wget exists on target machine
#    wget $wgetopts $ncc -O ../${bashPatch} "http://www.linuxfromscratch.org/patches/lfs/development/${bashPatch}"
#  else
#    echo "/usr/bin/wget not found on the target machine"
#    echo "Install it to continue"
#    echo "Aborting"
#    exit 1
#  fi
#fi
#EOF
#   ;;
#   binutils) # need the patch
#     echo "binutilsPatch=\"$binutilsPatch\"" >> $Output
#     cat >> $Output << "EOF"
#if [ -e ${CUR_DIR}/${binutilsPatch} ]; then
#  echo "patch already in place - will use that"
#elif [ -e ${sourceloc}/${binutilsPatch} ]; then
#  cp -v ${sourceloc}/${binutilsPatch} ../
#else # download it
#  if [ -e /usr/bin/wget ]; then # wget exists on target machine
#    wget $wgetopts $ncc -O ../${binutilsPatch} "http://www.linuxfromscratch.org/patches/lfs/development/${binutilsPatch}"
#  else
#    echo "/usr/bin/wget not found on the target machine"
#    echo "Install it to continue"
#    echo "Aborting"
#    exit 1
#  fi
#fi
#EOF
#   ;;
   bzip2) # need the patch
     echo "bzip2Patch=\"$bzip2Patch\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${bzip2Patch} ]; then
  echo "patch already in place - will use that"
elif [ -e ${sourceloc}/${bzip2Patch} ]; then
  cp -v ${sourceloc}/${bzip2Patch} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../${bzip2Patch} "http://www.linuxfromscratch.org/patches/lfs/development/${bzip2Patch}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
   coreutils) # need the patch
     echo "coreutilsPatch1=\"$coreutilsPatch1\"" >> $Output
#     echo "coreutilsPatch2=\"$coreutilsPatch2\"" >> $Output
     for ((ij=1; ij<2; ij++)); do # change 2 to 3 if have 2 patches
       cat >> $Output << EOF
if [ -e \${CUR_DIR}/\${coreutilsPatch${ij}} ]; then
  echo "patch already in place - will use that"
elif [ -e \${sourceloc}/\${coreutilsPatch${ij}} ]; then
  cp -v \${sourceloc}/\${coreutilsPatch${ij}} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget \$wgetopts \$ncc -O ../\${coreutilsPatch${ij}} "http://www.linuxfromscratch.org/patches/lfs/development/\${coreutilsPatch${ij}}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
     done
   ;;
#   gcc) # need the patch
#     echo "gccPatch=\"gcc-11.1.0-upstream_fixes-1.patch\"" >> $Output
#     cat >> $Output << "EOF"
#if [ -e ${CUR_DIR}/${gccPatch} ]; then
#  echo "$gccPatch patch already in $CUR_DIR, will use that"
#elif [ -e ${sourceloc}/${gccPatch} ]; then
#  cp -v ${sourceloc}/${gccPatch} ../
#else
#  if [ -e /usr/bin/wget ]; then # wget exists on target machine
#    wget $wgetopts $ncc -O ../${gccPatch} https://www.linuxfromscratch.org/patches/lfs/development/${gccPatch}
#  else
#    echo "/usr/bin/wget not found on the target machine"
#    echo "Install it to continue"
#    echo "Aborting"
#    exit 1
#  fi
#fi
#EOF
#   ;;
   glibc) # need the patch and the time zone data
     echo "glibcPatch=\"${glibcPatch}\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${glibcPatch} ]; then
  echo "$glibcPatch patch already in $CUR_DIR, will use that"
elif [ -e ${sourceloc}/${glibcPatch} ]; then
  cp -v ${sourceloc}/${glibcPatch} ../
else
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../${glibcPatch} http://www.linuxfromscratch.org/patches/lfs/development/${glibcPatch}
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
     echo "tzdataFile=\"$tzdataFile\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${tzdataFile} ]; then
  echo "$tzdataFile file already downloaded - will use that one"
elif [ -e ${sourceloc}/${tzdataFile} ]; then
  cp -v ${sourceloc}/${tzdataFile} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../${tzdataFile} "https://www.iana.org/time-zones/repository/releases/${tzdataFile}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
   kbd) # need the patch
     echo "kbdPatch=\"${kbdPatch}\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${kbdPatch} ]; then
  echo "patch already in place - will use that"
elif [ -e ${sourceloc}/${kbdPatch} ]; then
  cp -v ${sourceloc}/${kbdPatch} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../${kbdPatch} "http://www.linuxfromscratch.org/patches/lfs/development/${kbdPatch}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
#   meson) # need the patch
#     cat >> $Output << "EOF"
#if [ -e ${CUR_DIR}/meson-0.56.0-upstream_fix-1.patch ]; then
#  echo "patch already in place - will use that"
#elif [ -e ${sourceloc}/meson-0.56.0-upstream_fix-1.patch ]; then
#  cp -v ${sourceloc}/meson-0.56.0-upstream_fix-1.patch ../
#else # download it
#  if [ -e /usr/bin/wget ]; then # wget exists on target machine
#    wget $wgetopts $ncc -O ../meson-0.56.0-upstream_fix-1.patch "http://www.linuxfromscratch.org/patches/lfs/development/meson-0.56.0-upstream_fix-1.patch"
#  else
#    echo "/usr/bin/wget not found on the target machine"
#    echo "Install it to continue"
#    echo "Aborting"
#    exit 1
#  fi
#fi
#EOF
#   ;;
#    perl) # need the patch
#     echo "perlPatch=\"${perlPatch}\"" >> $Output
#     cat >> $Output << "EOF"
#if [ -e ${CUR_DIR}/${perlPatch} ]; then
#  echo "patch already in place - will use that"
#elif [ -e ${sourceloc}/${perlPatch} ]; then
#  cp -v ${sourceloc}/${perlPatch} ../
#else # download it
#  if [ -e /usr/bin/wget ]; then # wget exists on target machine
#    wget $wgetopts $ncc -O ../${perlPatch} "http://www.linuxfromscratch.org/patches/lfs/development/${perlPatch}"
#  else
#    echo "/usr/bin/wget not found on the target machine"
#    echo "Install it to continue"
#    echo "Aborting"
#    exit 1
#  fi
#fi
#EOF
#   ;;
   readline) # need the patch
     echo "readlinePatch=\"${readlinePatch}\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${readlinePatch} ]; then
  echo "patch already in place - will use that"
elif [ -e ${sourceloc}/${readlinePatch} ]; then
  cp -v ${sourceloc}/${readlinePatch} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../${readlinePatch} "http://www.linuxfromscratch.org/patches/lfs/development/${readlinePatch}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
#   shadow)
#     echo "shadowPatch=\"${shadowPatch}\"" >> $Output
#     cat >> $Output << "EOF"
#if [ -e ${CUR_DIR}/${shadowPatch} ]; then 
#  echo "patch already in place - will use that"
#elif [ -e ${sourceloc}/${shadowPatch} ]; then 
#  cp -v ${sourceloc}/${shadowPatch} ../
#else # download it
#  if [ -e /usr/bin/wget ]; then # wget exists on target machine
#    wget $wgetopts $ncc -O ../${shadowPatch} "http://www.linuxfromscratch.org/patches/lfs/development/${shadowPatch}"
#  else
#    echo "/usr/bin/wget not found on the target machine"
#    echo "Install it to continue"
#    echo "Aborting"
#    exit 1
#  fi
#fi
#EOF
#   ;;
   systemd) # need the man-pages
     echo "systemdManPages=\"$systemdManPages\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${systemdManPages} ]; then
  echo "systemd-man-pages already downloaded - will use that one"
elif [ -e ${sourceloc}/${systemdManPages} ]; then
  cp -v ${sourceloc}/${systemdManPages} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../${systemdManPages} "http://anduin.linuxfromscratch.org/LFS/${systemdManPages}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
# currently (29/12/22) a patch required
     echo "systemdPatch=\"$systemdPatch\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${systemdPatch} ]; then
  echo "systemd patch already downloaded - will use that one"
elif [ -e ${sourceloc}/${systemdPatch} ]; then
  cp -v ${sourceloc}/${systemdPatch} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../${systemdPatch} "https://www.linuxfromscratch.org/patches/lfs/development/${systemdPatch}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
  ;;
   tcl) # need the html file
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${SrcName}*html.tar.?z* ]; then
  echo "tcl8 html file already downloaded - will use that one"
elif [ -e ${sourceloc}/${SrcName}*html.tar.?z* ]; then
  cp -v ${sourceloc}/${SrcName}*html.tar.?z* ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
EOF
echo "    wget \$wgetopts \$ncc -O ../tcl8.${tclvers}-html.tar.gz \"https://downloads.sourceforge.net/tcl/tcl8.${tclvers}-html.tar.gz\"" >> $Output
     cat >> $Output << "EOF"
else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
#   xz) # need the patch
#     echo "xzPatch=\"${xzPatch}\"" >> $Output
#     cat >> $Output << "EOF"
#if [ -e ${CUR_DIR}/${xzPatch} ]; then
#  echo "patch already in place - will use that"
#elif [ -e ${sourceloc}/${xzPatch} ]; then
#  cp -v ${sourceloc}/${xzPatch} ../
#else # download it
#  if [ -e /usr/bin/wget ]; then # wget exists on target machine
#    wget $wgetopts $ncc -O ../${xzPatch} "http://www.linuxfromscratch.org/patches/lfs/development/${xzPatch}"
#  else
#    echo "/usr/bin/wget not found on the target machine"
#    echo "Install it to continue"
#    echo "Aborting"
#    exit 1
#  fi
#fi
#EOF
#   ;;
   zstd) # need the patch
     echo "zstdPatch=\"${zstdPatch}\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${zstdPatch} ]; then
  echo "patch already in place - will use that"
elif [ -e ${sourceloc}/${zstdPatch} ]; then
  cp -v ${sourceloc}/${zstdPatch} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../${zstdPatch} "http://www.linuxfromscratch.org/patches/lfs/development/${zstdPatch}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
esac
} # end dnldAddFiles
#
setInstallDirs () {
#set required dirs to be install dirs
# $1 is the package name
local pkgname=$1
# first deal with any .INSTALL files
case $pkgname in
   autoconf|automake|bc|coreutils|diffutils|findutils|flex|gawk|gdbm|gettext|gperf|groff|grub|gzip|libtool|m4|make|shadow|tar|texinfo)
     if $useDESTDIR; then # include the INSTALL file
       cat >> $Output << "EOF"
if [ -f "${pkguserdir}/installFiles/${PkgName}/INSTALL" ]; then
  install -m644 ${pkguserdir}/installFiles/${PkgName}/INSTALL ${PkgUserDir}/${PkgName}/.INSTALL
  if ! $AS_ROOT; then chown $PkgName:$PkgName ${PkgUserDir}/${PkgName}/.INSTALL; fi
fi
EOF
     fi
   ;;
esac
# now set install dirs
case $pkgname in
   bash) #/usr/share/aclocal
     if ! $useDESTDIR; then
        cat >> $Output << "EOF"
chgrp install /usr/share/aclocal
chmod g+w,o+t /usr/share/aclocal
chown -h bash:bash /bin/sh
exec /bin/bash --login
EOF
     fi
   ;;
   binutils)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/lib/bfd-plugins
chmod g+w,o+t /usr/lib/bfd-plugins
EOF
     fi
   ;;     
   bison)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/aclocal
chmod g+w,o+t /usr/share/aclocal
EOF
     fi
   ;;
   bzip2) # prepare locales for installation
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/locale/*/LC_MESSAGES
chmod g+w,o+t /usr/share/locale/*/LC_MESSAGES
chgrp install /usr/share/doc
chmod g+w,o+t /usr/share/doc
EOF
     fi
   ;;
   coreutils)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown 0:coreutils /etc/{group,group-}
chmod 644 /etc/{group,group-}
EOF
     fi
   ;;
   dejagnu)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown root:install /usr/share/info/{,dir}
chmod g+w,o+t /usr/share/info
chmod 664 /usr/share/info/dir
EOF
     fi
   ;;
   dbus)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown root /usr/lib/dbus-1.0/dbus-daemon-launch-helper
chmod 4750 /usr/lib/dbus-1.0/dbus-daemon-launch-helper
chgrp install /usr/lib/dbus-1.0
chmod g+w,o+t /usr/lib/dbus-1.0
chgrp install /usr/share/dbus-1
chmod g+w,o+t /usr/share/dbus-1
chgrp install /usr/share/dbus-1/services
chmod g+w,o+t /usr/share/dbus-1/services
chgrp install /usr/share/dbus-1/system-services
chmod g+w,o+t /usr/share/dbus-1/system-services
chgrp install /usr/include/dbus-1.0/dbus
chmod g+w,o+t /usr/include/dbus-1.0/dbus
chgrp install /usr/lib/systemd/
chmod g+w,o+t /usr/lib/systemd/
chgrp install /usr/lib/systemd/system
chmod g+w,o+t /usr/lib/systemd/system
chgrp install /usr/lib/systemd/system/sockets.target.wants
chmod g+w,o+t /usr/lib/systemd/system/sockets.target.wants
chgrp install /usr/lib/systemd/system/multi-user.target.wants
chmod g+w,o+t /usr/lib/systemd/system/multi-user.target.wants
EOF
     else
       cat >> $Output << "EOF"
chown root ${PkgUserDir}/${PkgName}/usr/lib/dbus-1.0/dbus-daemon-launch-helper
chmod 4750 ${PkgUserDir}/${PkgName}/usr/lib/dbus-1.0/dbus-daemon-launch-helper
mkdir -pv ${PkgUserDir}/${PkgName}/run/dbus
chown 0:0 ${PkgUserDir}/${PkgName}/run
chown dbus:dbus ${PkgUserDir}/${PkgName}/run/dbus
chmod 1777 ${PkgUserDir}/${PkgName}/run
EOF
     fi
   ;;
   eudev)
     cat >> $Output << "EOF"
chgrp install /lib/udev/rules.d
chmod g+w,o+t /lib/udev/rules.d
chgrp install /lib/firmware
chmod g+w,o+t /lib/firmware
EOF
   ;;
   expat)
     cat >> $Output << "EOF"
chgrp install /usr/lib/cmake
chmod g+w,o+t /usr/lib/cmake
EOF
   ;;
   file)
     cat >> $Output << "EOF"
rm -rf ${PkgUserDir}/${PkgName}/usr/share/man/man5 # this is empty
EOF
   ;;
   glibc) #/usr/share/info/dir
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown root:install /usr/share/info/dir
chmod 664 /usr/share/info/dir
chgrp install /usr/include/sys # for libcap
chmod g+w,o+t /usr/include/sys
if [ -d /usr/lib/systemd ]; then
  chgrp install /usr/lib/systemd
  chmod g+w,o+t /usr/lib/systemd
  chgrp install /usr/lib/systemd/system
  chmod g+w,o+t /usr/lib/systemd/system
  chgrp install /usr/lib/tmpfiles.d
  chmod g+w,o+t /usr/lib/tmpfiles.d
fi
# check the symlink ld-linux.so.2 is set up
if [ ! -L /usr/lib/ld-linux.so.2 ]; then
EOF
       echo "  ln -svf ld-${glibcvers}.so /usr/lib/ld-linux.so.2" >> $Output
       cat >> $Output << "EOF"
fi
if ! $AS_ROOT; then chown -h glibc:glibc /usr/lib/ld-linux.so.2; fi
EOF
     fi
   ;;
   grub)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /etc/bash_completion.d
chmod g+w,o+t /etc/bash_completion.d
EOF
     fi
   ;;
   inetutils) # ping, etc setuid root
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown root /bin/ping*
chmod 4755 /bin/ping*
chown root /bin/traceroute
chmod 4755 /bin/traceroute
EOF
     else
       cat >> $Output << "EOF"
chown root ${PkgUserDir}/${PkgName}/usr/bin/ping*
chmod 4755 ${PkgUserDir}/${PkgName}/usr/bin/ping*
chown root ${PkgUserDir}/${PkgName}/usr/bin/traceroute
chmod 4755 ${PkgUserDir}/${PkgName}/usr/bin/traceroute
EOF
     fi
   ;;
#   iproute2)
#     if $useDESTDIR; then
#       cat >> $Output << "EOF"
#mkdir -pv ${PkgUserDir}/${PkgName}/usr/bin
#mv ${PkgUserDir}/${PkgName}/sbin/* ${PkgUserDir}/${PkgName}/usr/bin
#rm -rf ${PkgUserDir}/${PkgName}/sbin
#if ! $AS_ROOT; then
#  chown -R -h iproute2:iproute2 ${PkgUserDir}/${PkgName}/usr/bin
#fi
#EOF
#     fi
#   ;;
   kmod)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/bash-completion/completions
chmod g+w,o+t /usr/share/bash-completion/completions
EOF
     fi
   ;;
   libcap) # add libcap module to /etc/pam.d/system-auth if chapter is update
     if [ "$Chapter" = update ]; then 
       if [[ "$useDESTDIR" = true || "$single_package" = true ]]; then
         cat >> $Output << "EOF"
install -dm0755 ${PkgUserDir}/${PkgName}/etc/pam.d
cat > ${PkgUserDir}/${PkgName}/etc/pam.d/system-auth << "CAPEOF" &&
# Begin /etc/pam.d/system-auth
auth      required    pam_unix.so
# add libcap addition
auth      optional    pam_cap.so
# End /etc/pam.d/system-auth
CAPEOF
if ! $AS_ROOT; then chown linux-pam:linux-pam ${PkgUserDir}/${PkgName}/etc/pam.d/system-auth; fi
EOF
       fi
     fi
   ;;
   linux-headers)
     if $installBinTarfile; then # a binary tarfile install
         cat >> $Output << "EOF"
chgrp install /usr/include/scsi
chmod g+w,o+t /usr/include/scsi
EOF
     elif [[ "$useDESTDIR" = true || "$single_package" = true ]]; then # using DESTDIR
       cat >> $Output << "EOF"
chgrp install ${PkgUserDir}/${PkgName}/usr/include/scsi
chmod g+w,o+t ${PkgUserDir}/${PkgName}/usr/include/scsi
EOF
     else
       cat >> $Output << "EOF"
chgrp install /usr/include/scsi
chmod g+w,o+t /usr/include/scsi
# linux-headers is not reinstalled so store the src tarfile in $PkgUserDir/$PkgName
# because the src tarfile in ${buildDir}/${FuncName} will get deleted eventually
EOF
       echo "if [ -e \${PkgUserDir}/\${PkgName}/linux-[0-9]*.tar.?z* ]; then
  echo \"kernel srcfile present in \${PkgUserDir}/\${PkgName}\"
elif [ -e ${preChrootBuild}/${FuncName}/linux-[0-9]*.tar.?z* ]; then
  cp -v ${preChrootBuild}/${FuncName}/linux-[0-9]*.tar.?z* \${PkgUserDir}/\${PkgName}
fi" >> $Output
     fi
   ;;
   man-db) #/es,it
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/man/it
chgrp install /usr/share/man/it/man*
chmod g+w,o+t /usr/share/man/it
chmod g+w,o+t /usr/share/man/it/man*
EOF
     fi
   ;;
   man-pages)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/man/{,man{1..8}}
chmod 1775 /usr/share/man/{,man{1..8}}
EOF
     else
       cat >> $Output << "EOF"
chgrp install ${PkgUserDir}/${PkgName}/usr/share/man/{,man{1..8}}
chmod 1775 ${PkgUserDir}/${PkgName}/usr/share/man/{,man{1..8}}
# these are included in coreutils
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man1/{chgrp,chmod,chown,cp,dir,dd}.1
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man1/{df,dircolors,du,install,ln,ls}.1
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man1/{mkdir,mkfifo,mknod,mv,rm,rmdir}.1
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man1/{touch,vdir}.1
# this is included in shadow
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man5/passwd.5
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man3/getspnam.3
# this is included in diffutils
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man1/diff.1
# this is included in xf86-input-mouse
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man4/mouse.4
# this is included in attr
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man5/attr.5
# this is included in tzdata
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man5/tzfile.5
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man8/{tzselect,zdump,zic}.8
EOF
     fi
   ;;
   meson)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
cat > /usr/bin/arch-meson << "MESONEOF"
EOF
     else
       cat >> $Output << "EOF"
cat > ${PkgUserDir}/${PkgName}/usr/bin/arch-meson << "MESONEOF"
EOF
     fi
     cat >> $Output << "EOF"
#!/bin/bash -ex
# Arch Linux Meson wrapper

exec meson setup \
  --prefix         /usr \
  --libdir         /usr/lib \
  --libexecdir     /usr/lib \
  --bindir         /usr/bin \
  --sbindir        /usr/bin \
  --includedir     /usr/include \
  --datadir        /usr/share \
  --mandir         /usr/share/man \
  --infodir        /usr/share/info \
  --localedir      /usr/share/locale \
  --sysconfdir     /etc \
  --localstatedir  /var \
  --sharedstatedir /var/lib \
  --wrap-mode      nodownload \
  -D               b_lto=true \
  -D               b_pie=true \
  "$@"
MESONEOF
EOF
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chmod 755 /usr/bin/arch-meson
if ! $AS_ROOT; then chown $PkgName:$PkgName /usr/bin/arch-meson; fi
chgrp install /usr/share/polkit-1
chgrp install /usr/share/polkit-1/actions
chmod g+w,o+t /usr/share/polkit-1
chmod g+w,o+t /usr/share/polkit-1/actions
EOF
     else
       cat >> $Output << "EOF"
chmod 755 ${PkgUserDir}/${PkgName}/usr/bin/arch-meson
if ! $AS_ROOT; then chown $PkgName:$PkgName ${PkgUserDir}/${PkgName}/usr/bin/arch-meson; fi
chgrp install ${PkgUserDir}/${PkgName}/usr/share/polkit-1
chgrp install ${PkgUserDir}/${PkgName}/usr/share/polkit-1/actions
chmod g+w,o+t ${PkgUserDir}/${PkgName}/usr/share/polkit-1
chmod g+w,o+t ${PkgUserDir}/${PkgName}/usr/share/polkit-1/actions
EOF
     fi
   ;;
   ncurses)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown 0:0 /etc/ld.so.cache
EOF
     fi
   ;;
   ninja)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/zsh/site-functions
chmod g+w,o+t /usr/share/zsh/site-functions
EOF
     fi
   ;;
   openssl)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /etc/ssl/{,certs}
chmod g+w,o+t /etc/ssl/{,certs}
EOF
     fi
   ;;
   perl)
     if ! $useDESTDIR; then
       echo "chgrp install /usr/lib/perl5/${perlseries}/{core_perl,site_perl}
chmod g+w,o+t /usr/lib/perl5/${perlseries}/{core_perl,site_perl}" >> $Output
     else
       echo "chgrp install ${PkgUserDir}/${PkgName}/usr/lib/perl5/${perlseries}/{core_perl,site_perl}
chmod g+w,o+t ${PkgUserDir}/${PkgName}/usr/lib/perl5/${perlseries}/{core_perl,site_perl}" >> $Output
     fi
   ;;
   pkg-config) #/usr/share/aclocal
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/aclocal
chmod g+w,o+t /usr/share/aclocal
chgrp install /usr/lib/pkgconfig
chmod g+w,o+t /usr/lib/pkgconfig
EOF
     fi
   ;;
   python3)
     if $useDESTDIR; then
       echo "chgrp install \${PkgUserDir}/\${PkgName}/usr/lib/python${pythonseries}/site-packages
chmod g+w,o+t \${PkgUserDir}/\${PkgName}/usr/lib/python${pythonseries}/site-packages" >> $Output
       cat >> $Output << "EOF"
if [ -f "${pkguserdir}/installFiles/${PkgName}/INSTALL" ]; then
  install -m644 ${pkguserdir}/installFiles/${PkgName}/INSTALL ${PkgUserDir}/${PkgName}/.INSTALL
  if ! $AS_ROOT; then chown $PkgName:$PkgName ${PkgUserDir}/${PkgName}/.INSTALL; fi
fi
EOF
     else
       echo "chgrp install /usr/lib/python${pythonseries}/site-packages
chmod g+w,o+t /usr/lib/python${pythonseries}/site-packages" >> $Output
     fi
   ;;
   shadow)
     if [[ "$Chapter" != update && "$useDESTDIR" = false ]]; then # need pwconv and grpconv
       cat >> $Output << "EOF"
pwconv
grpconv
EOF
     fi
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown 0:shadow /etc/{group,group-,gshadow,gshadow-,passwd,passwd-,shadow,shadow-}
chmod 644 /etc/{group,group-,passwd,passwd-}
chmod 640 /etc/{gshadow,gshadow-,shadow,shadow-}
EOF
       if [ "$SYSTEMD" = yes ]; then
         echo "chown root /usr/bin/{chage,chfn,chsh,expiry,gpasswd,newgidmap,newgrp,newuidmap,passwd,su}
chmod 4755 /usr/bin/{chage,chfn,chsh,expiry,gpasswd,newgidmap,newgrp,newuidmap,passwd,su}" >> $Output
       else
         echo "chown root /bin/passwd
chmod 4755 /bin/passwd" >> $Output
       fi
     else # using DESTDIR
       cat >> $Output << "EOF"
# setuid root binaries
chown root ${PkgUserDir}/${PkgName}/usr/bin/{chage,chfn,chsh,expiry,gpasswd,newgidmap,newgrp,newuidmap,passwd,su}
chmod 4755 ${PkgUserDir}/${PkgName}/usr/bin/{chage,chfn,chsh,expiry,gpasswd,newgidmap,newgrp,newuidmap,passwd,su}
mv ${PkgUserDir}/${PkgName}/usr/sbin/* ${PkgUserDir}/${PkgName}/usr/bin/
rm -rf ${PkgUserDir}/${PkgName}/usr/sbin
EOF
     fi
   ;;
   systemd)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/lib/udev/rules.d
chmod g+w,o+t /usr/lib/udev/rules.d
chgrp install /etc/udev/rules.d
chmod g+w,o+t /etc/udev/rules.d
chgrp install /usr/share/pkgconfig
chmod g+w,o+t /usr/share/pkgconfig
chgrp install /usr/share/polkit-1 # for polkit
chmod g+w,o+t /usr/share/polkit-1
chgrp install /usr/share/polkit-1/actions
chmod g+w,o+t /usr/share/polkit-1/actions
chgrp install /usr/share/dbus-1
chmod g+w,o+t /usr/share/dbus-1
chgrp install /etc/xdg # for at-spi2-core
chmod g+w,o+t /etc/xdg
chgrp install /usr/share/bash-completion/completions
chmod g+w,o+t /usr/share/bash-completion/completions
chgrp install /usr/lib/systemd/system
chmod g+w,o+t /usr/lib/systemd/system
chgrp install /usr/lib/systemd/system/sockets.target.wants # for dbus
chmod g+w,o+t /usr/lib/systemd/system/sockets.target.wants
chgrp install /usr/lib/systemd/system/multi-user.target.wants
chmod g+w,o+t /usr/lib/systemd/system/multi-user.target.wants
chgrp install /usr/lib/tmpfiles.d
chmod g+w,o+t /usr/lib/tmpfiles.d
chown root:systemd-journal /var/log/journal
chmod 2755 /var/log/journal
chown 0:0 /usr # had to change it to systemd to allow time update
systemctl preset-all
systemctl disable systemd-time-wait-sync.service
systemctl disable systemd-sysupdate
rm -fv /etc/sysctl.d/50-pid-max.conf
rm -fv /usr/lib/lib{blkid,uuid,mount}.so*
rm -fv /usr/lib/tmpfiles.d/systemd-nologin.conf
EOF
     else
       cat >> $Output << "EOF"
chown root:systemd-journal ${PkgUserDir}/${PkgName}/var/log/journal
chmod 2755 ${PkgUserDir}/${PkgName}/var/log/journal
if [ -f "${pkguserdir}/installFiles/${PkgName}/INSTALL" ]; then
  install -m644 ${pkguserdir}/installFiles/${PkgName}/INSTALL ${PkgUserDir}/${PkgName}/.INSTALL
  if ! $AS_ROOT; then chown systemd:systemd ${PkgUserDir}/${PkgName}/.INSTALL; fi
fi
EOF
     fi
   ;;
   sysvinit)
     cat >> $Output << "EOF"
rm -f /dev/initctl
mknod -m 600 /dev/initctl p
EOF
   ;;
   tcl) # if update, put man3/Thread.3 back to Perl
     if [ "$Chapter" = update ]; then
       if ! $useDESTDIR; then
         cat >> $Output << "EOF"
mv -v /usr/share/man/man3/{Thread_Perl,Thread}.3
if ! $AS_ROOT; then chown perl:perl /usr/share/man/man3/Thread.3; fi
EOF
       fi
     fi
   ;;
   util-linux) # mount setuid root
     if ! $useDESTDIR; then
       if [ "$currentChapter" = chapter08 ]; then
         if [ "$SYSTEMD" = yes ]; then
           cat >> $Output << "EOF"
chgrp install /usr/lib/systemd # for glibc
chmod g+w,o+t /usr/lib/systemd
chgrp install /usr/lib/systemd/system
chmod g+w,o+t /usr/lib/systemd/system
EOF
         fi
         cat >> $Output << "EOF"
chown root /bin/{mount,umount}
chmod 4755 /bin/{mount,umount}
chown root:tty /usr/bin/wall
chmod 2755 /usr/bin/wall
chgrp install /usr/share/bash-completion/completions
chmod g+w,o+t /usr/share/bash-completion/completions
chown root /usr/bin/su
chmod 4755 /usr/bin/su
EOF
         if [ "$SYSTEMD" = yes ]; then
           cat >> $Output << "EOF"
# do this here because libmount is now installed
systemd-machine-id-setup
chown systemd:systemd /etc/machine-id
EOF
         fi
       fi
     else # using DESTDIR
       cat >> $Output << "EOF"
chown root ${PkgUserDir}/${PkgName}/usr/bin/{mount,umount}
chmod 4755 ${PkgUserDir}/${PkgName}/usr/bin/{mount,umount}
chown root:tty ${PkgUserDir}/${PkgName}/usr/bin/wall
chmod 2755 ${PkgUserDir}/${PkgName}/usr/bin/wall
mv ${PkgUserDir}/${PkgName}/usr/sbin/* ${PkgUserDir}/${PkgName}/usr/bin/
rm -rf ${PkgUserDir}/${PkgName}/usr/sbin # rm symlink
EOF
     fi
   ;;
   vim)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/man/fr*
chgrp install /usr/share/man/it*
chgrp install /usr/share/man/it/man1
chgrp install /usr/share/man/ja
chgrp install /usr/share/man/pl*
chgrp install /usr/share/man/ru*
chmod g+w,o+t /usr/share/man/fr*
chmod g+w,o+t /usr/share/man/it*
chmod g+w,o+t /usr/share/man/it/man1
chmod g+w,o+t /usr/share/man/ja
chmod g+w,o+t /usr/share/man/pl*
chmod g+w,o+t /usr/share/man/ru*
EOF
     fi
   ;;
   xml-parser)
     if ! $useDESTDIR; then
       echo "chgrp install /usr/lib/perl5/${perlseries}/site_perl/XML
chmod g+w,o+t /usr/lib/perl5/${perlseries}/site_perl/XML
chgrp install /usr/lib/perl5/${perlseries}/site_perl/auto
chmod g+w,o+t /usr/lib/perl5/${perlseries}/site_perl/auto
chgrp install /usr/lib/perl5/${perlseries}/site_perl/auto/XML
chmod g+w,o+t /usr/lib/perl5/${perlseries}/site_perl/auto/XML
chgrp install /usr/lib/perl5/${perlseries}/core_perl/perllocal.pod
chmod 664 /usr/lib/perl5/${perlseries}/core_perl/perllocal.pod" >> $Output
     else
       echo "chgrp install \${PkgUserDir}/\${PkgName}/usr/lib/perl5/${perlseries}/site_perl/XML
chmod g+w,o+t \${PkgUserDir}/\${PkgName}/usr/lib/perl5/${perlseries}/site_perl/XML
chgrp install \${PkgUserDir}/\${PkgName}/usr/lib/perl5/${perlseries}/site_perl/auto
chmod g+w,o+t \${PkgUserDir}/\${PkgName}/usr/lib/perl5/${perlseries}/site_perl/auto
chgrp install \${PkgUserDir}/\${PkgName}/usr/lib/perl5/${perlseries}/site_perl/auto/XML
chmod g+w,o+t \${PkgUserDir}/\${PkgName}/usr/lib/perl5/${perlseries}/site_perl/auto/XML
chgrp install \${PkgUserDir}/\${PkgName}/usr/lib/perl5/${perlseries}/core_perl/perllocal.pod
chmod 664 \${PkgUserDir}/\${PkgName}/usr/lib/perl5/${perlseries}/core_perl/perllocal.pod" >> $Output
     fi
   ;;
   xz)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/man/uk/man1
chmod g+w,o+t /usr/share/man/uk/man1
EOF
     else
       cat >> $Output << "EOF"
chgrp install ${PkgUserDir}/${PkgName}/usr/share/man/uk/man1
chmod g+w,o+t ${PkgUserDir}/${PkgName}/usr/share/man/uk/man1
EOF
     fi
   ;;
esac
} # end setInstallDirs
#
postProcessing () {
# $1 is the package name
local pkgname=$1
#
case $pkgname in
   py3-flit-core) # remove the tests dir
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
rm -rf /usr/lib/python*/site-packages/flit_core/tests
EOF
     else
       cat >> $Output << "EOF"
rm -rf ${PkgUserDir}/${PkgName}/usr/lib/python*/site-packages/flit_core/tests
EOF
     fi
   ;;
esac
} # end postProcessing
#
getSrcfileURL () {
# returns two parameters:
# the src URL as srcURL 
# and useThisSrcLoc which is the location of the srcfile if it's already been downloaded
# These are returned in a global array RtrnVars
#
# $1 is the array of srcfile URLs
# $2 is the function name
# $3 is the srcname to search for
#
declare -a sourceURL=("${!1}")
local funcName=$2
local srcname=$3
local serchstr
for srcURL in ${sourceURL[@]}; do # find the url for this src file
  serchstr="*$srcname[0-9]*.tar.?z*"
  case $funcName in # modify some of the src file names to search for
     binutilspass2)
       useThisSrcLoc="/build/binutilspass1"
     ;;
     gccpass2|gcclibstdc++|libstdc++)
       useThisSrcLoc="/build/gccpass1"
     ;;
     linuxheaders) # need to check for the correct kernel series in the URL
       useThisSrcLoc=""
       filenameOnly=${srcURL##*/}
       case $srcURL in
          *$serchstr)
            if $useKernelLatest; then
              srcURL=${srcURL/$linuxvers/$kernLatestVers}
            fi
# check the srcURL, may need to change the series element /v6.x/
            kernelSeries=${kernLatestVers%%.*}
            newSeries="v${kernelSeries}.x"
            srcURL=$(changeURL $srcURL 7 $newSeries)
            srcURL=${srcURL/$curLinux}
          ;;
       esac
     ;;
     make) # make not automake
       serchstr="*/make-[0-9]*"
       useThisSrcLoc=""
     ;;
     *)
       useThisSrcLoc=""
     ;;
  esac
  case $srcURL in
     $serchstr)
#       if $printit; then msg "found the search string $serchstr"; fi
#       if $printit; then msg "srcURL is $srcURL"; fi
       RtrnVars[0]=$srcURL
       RtrnVars[1]=$useThisSrcLoc
       return 0
     ;;
  esac
done
return $RETURN_PARAM # serchstr not found so error
} # end getSrcfileURL
#
Function () {
case $PkgName in
    changingowner|kernfs|chroot)
        if [ "$Chapter" != update ]; then
          WriteScript
          return
        fi
    ;;
esac
echo "${FuncName}_ () {" >> $Output
case $currentChapter in
   chapter05|chapter06|chapter07|chapter08|chapter10)
        case "$currentChapter" in
            chapter05|chapter06)
              echo "FuncName=$FuncName
PkgName=$PkgName" >> $Output
              if $as_root; then
                TestBuiltCh56
                echo "SrcName=$SrcName
starttime=\$( date +%s )" >> $Output
                cat >> $Output << "EOF"
# check env variables set correctly
echo "Running as $(whoami)"
if [ "$LFS" != /mnt/lfs ]; then
  echo "LFS is $LFS"
  echo "It should be /mnt/lfs"
  echo "Abort"
  exit 1
fi
if [ -z "$LFS_TGT" ]; then # not set. This will not work so abort
  echo "env variable LFS_TGT not set"
  echo "Aborting"
  exit 1
elif [ "$LFS_TGT" != x86_64-lfs-linux-gnu ]; then
  echo "LFS_TGT is not set to x86_64-lfs-linux-gnu"
  echo "It is set to $LFS_TGT"
  echo "check that this is what you intended, then modify this script"
  exit 1
fi
EOF
                echo "CreateBuildDir \$FuncName" >> $Output
# download any additional files
                case $FuncName in
                   gccpass1)
                     if [ "$SOURCES" = atinstall ]; then
                       echo "gmpvers=$gmpvers
mpcvers=$mpcvers
mpfrvers=$mpfrvers" >> $Output
                       cat >> $Output << "EOF"
# download the extra files
gmpFile="gmp-${gmpvers}.tar.xz"
mpcFile="mpc-${mpcvers}.tar.gz"
mpfrFile="mpfr-${mpfrvers}.tar.xz"
if [ -e ${CUR_DIR}/${gmpFile} ]; then
  echo "file $gmpFile already in $CUR_DIR, will use that"
else
  wget $wgetopts http://ftp.gnu.org/gnu/gmp/${gmpFile}
fi
if [ -e ${CUR_DIR}/${mpcFile} ]; then
  echo "file $mpcFile already in $CUR_DIR, will use that"
else
  wget $wgetopts https://ftp.gnu.org/gnu/mpc/${mpcFile}
fi
if [ -e ${CUR_DIR}/${mpfrFile} ]; then
  echo "file $mpfrFile already in $CUR_DIR, will use that"
else
  wget $wgetopts http://www.mpfr.org/mpfr-${mpfrvers}/${mpfrFile}
fi
EOF
                       RtrnVars=""
                       getSrcfileURL sourceURL[@] $FuncName $SrcName
                       srcURL=${RtrnVars[0]}
                       useThisSrcLoc=${RtrnVars[1]}
                       echo "unpack05 \$SrcName \"$srcURL\" \"$useThisSrcLoc\"" >> $Output
                     else # sources have been downloaded
                       getSrcfileURL sourceURL[@] $FuncName $SrcName
                       srcURL=${RtrnVars[0]}
                       useThisSrcLoc=${RtrnVars[1]}
                       echo "unpack05 \$SrcName \"$srcURL\" \"$useThisSrcLoc\"" >> $Output
                       cat >> $Output << "EOF"
# in chapter5 and chapter6 gcc require unpacking mpfr, mpc and gmp
for i in mpfr gmp mpc
do
  ln -sfv ${LFS}${sourceloc}/${i}*.tar.?z* $CUR_DIR
done
EOF
                     fi
                   ;;
                   gccpass2)
                     if [ "$SOURCES" = atinstall ]; then
                       cat >> $Output << "EOF"
# copy the extra files from gccpass1
if [ -e ${CUR_DIR}/gmp*.tar.?z* ]; then
  echo "a gmp file is already in $CUR_DIR, will use that"
else
  cp -v ${LFS}/build/gccpass1/gmp*.tar.?z* .
fi
if [ -e ${CUR_DIR}/mpc*.tar.?z* ]; then
  echo "an mpc file is already in $CUR_DIR, will use that"
else
  cp -v ${LFS}/build/gccpass1/mpc*.tar.?z* .
fi
if [ -e ${CUR_DIR}/mpfr*.tar.?z* ]; then
  echo "an mpfr file is already in $CUR_DIR, will use that"
else
  cp -v ${LFS}/build/gccpass1/mpfr*.tar.?z* .
fi
EOF
                       getSrcfileURL sourceURL[@] $FuncName $SrcName
                       srcURL=${RtrnVars[0]}
                       useThisSrcLoc=${RtrnVars[1]}
                       echo "unpack05 \$SrcName \"$srcURL\" \"$useThisSrcLoc\"" >> $Output
                     else # sources have been downloaded
                       getSrcfileURL sourceURL[@] $FuncName $SrcName
                       srcURL=${RtrnVars[0]}
                       useThisSrcLoc=${RtrnVars[1]}
                       echo "unpack05 \$SrcName \"$srcURL\" \"$useThisSrcLoc\"" >> $Output
                       cat >> $Output << "EOF"
# in chapter5 and chapter6 gcc require unpacking mpfr, mpc and gmp
for i in mpfr gmp mpc
do
  ln -sfv ${LFS}${sourceloc}/${i}*.tar.?z* $CUR_DIR
done
EOF
                     fi
                   ;;
	           glibc)
                     if [ "$SOURCES" = atinstall ]; then
# download the patch
                       echo "glibcPatch=\"${glibcPatch}\"" >> $Output
                       cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${glibcPatch} ]; then
  echo "patch $glibcPatch already in $CUR_DIR, will use that"
else
  wget $wgetopts http://www.linuxfromscratch.org/patches/lfs/development/${glibcPatch}
fi
EOF
                       getSrcfileURL sourceURL[@] $FuncName $SrcName
                       srcURL=${RtrnVars[0]}
                       useThisSrcLoc=${RtrnVars[1]}
                       echo "unpack05 \$SrcName \"$srcURL\" \"$useThisSrcLoc\"" >> $Output
                     else # sources downloaded
                       getSrcfileURL sourceURL[@] $FuncName $SrcName
                       echo "unpack05 \$SrcName \"$srcURL\" \"$useThisSrcLoc\"" >> $Output
                     fi
		   ;;
                   wget) # special case for wget because it's not in LFS
# get the latest version of wget from blfs
                     local URLtoUse="https://linuxfromscratch.org/blfs/view/systemd/basicnet/wget.html"
                     local -a wgetLines=($(python3 BShref.py $URLtoUse))
                     srcURL=${wgetLines[0]} # the https url
                     useThisSrcLoc=""
                     echo "unpack05 \$SrcName \"$srcURL\" \"$useThisSrcLoc\"" >> $Output
                   ;;
                   *)
                     getSrcfileURL sourceURL[@] $FuncName $SrcName
                     srcURL=${RtrnVars[0]}
                     useThisSrcLoc=${RtrnVars[1]}
                     echo "unpack05 \$SrcName \"$srcURL\" \"$useThisSrcLoc\"" >> $Output
                   ;;
                esac
              else # as pkguser
                TestBuiltCh56
		echo "starttime=\$( date +%s )" >> $Output
	        uidVal=0
      	        gidVal=0
                if [ "$FuncName" = binutilspass1 ]; then # set initial value of 10000
  		  uidVal=10000 
		  gidVal=10000
		elif [ "$FuncName" = openssl ]; then # set the GID to 10055, the value in Ch8
                  uidVal=10055
                  gidVal=10055
                elif [ "$FuncName" = wget ]; then # set the GID to 10171, it is deleted at end of LFS
# because it is reinstalled in BLFS
                  uidVal=10171
                  gidVal=10171
	        fi
                echo "uidVal=$uidVal
gidVal=$gidVal" >> $Output
                cat >> $Output << "EOF"
createPkguser $uidVal $gidVal
chown -h -R $PkgName:$PkgName ${PkgUserDir}/${PkgName}
EOF
	        cat >> $Output << "EOF"
# create the install script
cat > ${LFS}/install${PkgName}.sh << "IPS"
EOF
                cat >> $Output << "EOF"
#!/bin/bash -e
#
if [ $UID -eq 0 ]; then 
  echo "Running as root."
EOF
                echo "  echo \"Please run this script as user $PkgName.\"" >> $Output
                cat >> $Output << "EOF"
  exit 1
fi
echo "Running as $(whoami)"
LFS=/mnt/lfs
PkgUserDir=${LFS}/usr/src/core
buildDir=${LFS}/build
BuildLog=${LFS}/LFS-build.log
sourcedir=${LFS}/sources
sourceloc=${sourcedir}/trunk
EOF
                case $SrcName in
		   libstdc++-)
		     SrcName=gcc-
		   ;;
      	           python-)
	    	     SrcName=Python-
		   ;;
                esac	 
                echo "Chapter=$currentChapter
AS_ROOT=$as_root
#" >> $Output
                cat >> $Output << "EOF"
unpack05 () {
# $1 is the source name
# $2 is the url to download the source file
# $3, if present, is the sourceloc of the file already downloaded
sourcelocOld=$sourceloc # sourceloc is global - store it to reset it at the end
local srcname=$1
local srcURL=$2
local altSourceloc=${3:-""}
if [ ! -z "$altSourceloc" ]; then # set sourceloc to this location
  sourceloc=$altSourceloc
fi
echo "sourceloc is $sourceloc"
starttime=$( date +%s )
if [ -e ${CUR_DIR}/${srcname}*.tar.?z* ]; then # src exists in current dir - use that
  echo "$srcname already in current dir - will use that one"
elif [ -e ${LFS}${sourceloc}/${srcname}*.tar.?z* ]; then # src exists so copy it to current dir
  cp -v ${LFS}${sourceloc}/${srcname}*.* . # copy any patches as well
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on the host
    wget $wgetopts $srcURL
  else
    echo "Install wget on the host to continue"
    echo "Aborting"
    exit 1
  fi
fi
cd $(tar vxf ${srcname}*.tar.?z* | awk -F\/ 'END{print $1}')
curdir=$(echo $PWD)
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
sourceloc=$sourcelocOld
} # end unpack05
#
EOF
                case $FuncName in
                   make|tar|wget) # can't use any name that is a linux command
                     echo "${FuncName}Make () {
FuncName=$FuncName
PkgName=$PkgName
SrcName=$SrcName" >> $Output
                   ;;
                   *)
                     echo "${FuncName} () {
FuncName=$FuncName
PkgName=$PkgName
SrcName=$SrcName" >> $Output
                   ;;
                esac
                cat >> $Output << "EOF"
starttime=$( date +%s )
BuildDir=${buildDir}/${FuncName}
if [ ! -d $BuildDir ]; then mkdir -pv $BuildDir; fi
cd $BuildDir
CUR_DIR=$(echo $PWD) # will write logs to this dir
EOF
                case $FuncName in
                   gccpass1)
                     if [ "$SOURCES" = atinstall ]; then
                       echo "gmpvers=$gmpvers
mpcvers=$mpcvers
mpfrvers=$mpfrvers" >> $Output
                       cat >> $Output << "EOF"
# download the extra files
gmpFile="gmp-${gmpvers}.tar.xz"
mpcFile="mpc-${mpcvers}.tar.gz"
mpfrFile="mpfr-${mpfrvers}.tar.xz"
if [ -e ${CUR_DIR}/${gmpFile} ]; then
  echo "file $gmpFile already in $CUR_DIR, will use that"
else
  wget $wgetopts http://ftp.gnu.org/gnu/gmp/${gmpFile}
fi
if [ -e ${CUR_DIR}/${mpcFile} ]; then
  echo "file $mpcFile already in $CUR_DIR, will use that"
else
  wget $wgetopts https://ftp.gnu.org/gnu/mpc/${mpcFile}
fi
if [ -e ${CUR_DIR}/${mpfrFile} ]; then
  echo "file $mpfrFile already in $CUR_DIR, will use that"
else
  wget $wgetopts http://www.mpfr.org/mpfr-${mpfrvers}/${mpfrFile}
fi
EOF
                     else
                       cat >> $Output << "EOF"
# in chapter5 and chapter6 gcc require unpacking mpfr, mpc and gmp
for i in mpfr gmp mpc
do
  ln -sfv ${LFS}${sourceloc}/${i}*.tar.?z* .
done
EOF
                     fi
                   ;;
                   gccpass2)
                     if [ "$SOURCES" = atinstall ]; then
                       cat >> $Output << "EOF"
# copy the extra files from gccpass1
if [ -e ${CUR_DIR}/gmp*.tar.?z* ]; then
  echo "a gmp file is already in $CUR_DIR, will use that"
else
  cp -v ${LFS}/build/gccpass1/gmp*.tar.?z* .
fi
if [ -e ${CUR_DIR}/mpc*.tar.?z* ]; then
  echo "an mpc file is already in $CUR_DIR, will use that"
else
  cp -v ${LFS}/build/gccpass1/mpc*.tar.?z* .
fi
if [ -e ${CUR_DIR}/mpfr*.tar.?z* ]; then
  echo "an mpfr file is already in $CUR_DIR, will use that"
else
  cp -v ${LFS}/build/gccpass1/mpfr*.tar.?z* .
fi
EOF
                     else
                       cat >> $Output << "EOF"
# in chapter5 and chapter6 gcc require unpacking mpfr, mpc and gmp
for i in mpfr gmp mpc
do
  ln -sfv ${LFS}${sourceloc}/${i}*.tar.?z* .
done
EOF
                     fi
                   ;;
                   glibc)
                     if [ "$SOURCES" = atinstall ]; then
# download the patch
                       echo "glibcPatch=\"${glibcPatch}\"" >> $Output
                       cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${glibcPatch} ]; then
  echo "patch $glibcPatch already in $CUR_DIR, will use that"
else
  wget $wgetopts http://www.linuxfromscratch.org/patches/lfs/development/${glibcPatch}
fi
EOF
                     fi
                   ;;
                esac
                case $FuncName in
                   wget) # special case for wget because it's not in LFS
# get the latest version of wget from blfs
                     local URLtoUse="https://linuxfromscratch.org/blfs/view/systemd/basicnet/wget.html"
                     local -a wgetLines=($(python3 BShref.py $URLtoUse))
                     srcURL=${wgetLines[0]} # the https url
                     useThisSrcLoc=""
                     echo "unpack05 \$SrcName \"$srcURL\" \"$useThisSrcLoc\"" >> $Output
                   ;;
                   *)
                     for srcURL in ${sourceURL[@]}; do # find the url for this src file
                       serchstr="*$SrcName[0-9]*.tar.?z*"
                       useThisSrcLoc=""
                       case $FuncName in # modify some of the src file names to search for
                          binutilspass2)
                            useThisSrcLoc="/build/binutilspass1"
                          ;;
                          gccpass2|gcclibstdc++|libstdc++)
                            useThisSrcLoc="/build/gccpass1"
                          ;;
                          linuxheaders) # need to check for the correct kernel series in the URL
                            filenameOnly=${srcURL##*/}
                            case $srcURL in
                               *$serchstr)
                                 if $useKernelLatest; then
                                   srcURL=${srcURL/$linuxvers/$kernLatestVers}
                                 fi
# check the srcURL, may need to change the series element /v6.x/
                                 local kernelSeries=${kernLatestVers%%.*}
                                 local newSeries="v${kernelSeries}.x"
                                 srcURL=$(changeURL $srcURL 7 $newSeries)
                                 srcURL=${srcURL/$curLinux}
                               ;;
                            esac
                          ;;
                          make) # make not automake
                            serchstr="*/make-[0-9]*"
                          ;;
                       esac
                       case $srcURL in
                          $serchstr)
#                            if $printit; then msg "found the search string $serchstr"; fi
#                            if $printit; then msg "srcURL is $srcURL"; fi
                            echo "unpack05 \$SrcName \"$srcURL\" \"$useThisSrcLoc\"" >> $Output
                            break
                          ;;
                       esac
                     done
		   ;;
		esac
                cat >> $Output << "EOF"
# source the environment variables in the home dir
EOF
echo ". \${PkgUserDir}/\${PkgName}/.bashrc" >> $Output
                cat >> $Output << "EOF"
# check some env variable values
if [ "$LFS" != /mnt/lfs ]; then
  echo "LFS is set to $LFS"
  echo "It should be /mnt/lfs"
  echo "Abort"
  exit 1
fi
if [ -z "$LFS_TGT" ]; then # not set. This will not work so abort
  echo "env variable LFS_TGT not set"
  echo "Aborting"
  exit 1
elif [ "$LFS_TGT" != x86_64-lfs-linux-gnu ]; then
  echo "LFS_TGT is not set to x86_64-lfs-linux-gnu"
  echo "It is set to $LFS_TGT"
  echo "check that this is what you intended, then modify this script"
  exit 1
fi
EOF
              fi
            ;;
            chapter07|chapter08|chapter10) # no revisedchroot since 03/22. Is now cleanup in Ch8
              case $PkgName in
                 chroot|cleanup|kernfs|stripping)
                   echo "FuncName=$FuncName" >> $Output
                   cat >> $Output << "EOF"
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName"
  return 0
else
  echo "In function $FuncName"
fi
EOF
                 ;;
                 creatingdirs|createfiles)
                   useFuncName=$FuncName
                   if $useDESTDIR; then # using destdir
                     useFuncName="$FuncName-destdir"
                     echo "FuncName=$useFuncName
PkgName=$PkgName" >> $Output
                   else
                     echo "FuncName=$useFuncName" >> $Output
                   fi
                   cat >> $Output << "EOF"
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName"
  return 0
else
  echo "In function $FuncName"
fi
EOF
                 ;;
	         *)
                   addPattern="" # extra bit to add to the cd line in unpack
	           case $PkgName in
                      glibc)
                        addPattern="*.tar"
                      ;;
		      kernel)
		        SrcName="linux-"
		      ;;
	              python)
		        PkgName=python3
		        SrcName="Python-"
		      ;;
                      python3) # case for Chapter=update, currentChapter=chapter08 and single package is python3
                        SrcName="Python-"
                        CmdName="Python"
                      ;;
                      py3-flit-core)
                        SrcName="flit-"
                      ;;
                      py3-installer)
                        SrcName="installer-"
                      ;;
                      systemd) # need the srcfile, not the man file
                        addPattern="[0-9]"
                      ;;
                      tcl)
                        addPattern="*-src"
                      ;;
                   esac
                   echo "PkgName=$PkgName" >> $Output
# NOTE - the py3-flit-core and  py3-installer dir is in /usr/src/pythonmodules, so have to tell the script
                   if [[ "$PkgName" = "py3-flit-core" || "$PkgName" = "py3-installer" ]]; then
                     cat >> $Output << "EOF"
PkgUserDir="/usr/src/pythonmodules"
EOF
                   fi
                   if $installBinTarfile; then
                     TestBuiltAny $Chapter "-install"
                   elif $createBinFile; then # use DESTDIR
                     TestBuiltAny $Chapter "-destdir"
                   else
                     TestBuiltAny $Chapter
                   fi
                   if ! $as_root; then
                     cat >> $Output << "EOF"
install -v -m0755 -d ${PkgUserDir}/${PkgName}
EOF
                     if [ "$Chapter" = update ]; then # clean the install directory
                       if $installBinTarfile; then
                         echo "# installing a binary tarfile so
# don't clean the package directory" >> $Output
                       else
                         echo "cleanpkgdir \$PkgUserDir \$PkgName" >> $Output
                       fi
                     fi
                     cat >> $Output << "EOF"
starttime=$( date +%s )
touch ${PkgUserDir}/${PkgName}/build
echo "#!/bin/bash" > ${PkgUserDir}/${PkgName}/build
cat >> ${PkgUserDir}/${PkgName}/build << "IPS"
set +h
EOF
                     echo "Chapter=$Chapter
PkgName=\$LOGNAME
CUR_DIR=\$HOME" >> $Output
                     if [ "$Chapter" = update ]; then
                       if $installBinTarfile; then # check if linux-headers
                         case $PkgName in
                            linux-headers)
                              SrcName="linux-headers-"
                            ;;
                         esac
                       fi
                     fi
                     echo "SrcName=$SrcName
sourcedir=$sourcedir
sourceloc=$sourceloc
wgetopts=\"$wgetopts\"
ncc=\"$ncc\"
BuildLog="/$BuildLog"
usePip=false # if false then the cd .. will be used to get to the install dir in order to cleanup
starttime=\$( date +%s )
#" >> $Output
# deal with an install that requires destdirInstall
                     if $installBinTarfile; then # installing from a binary tarfile
                       destdirInstall
                     elif $useDESTDIR  && $installDEST; then # need destdirInstall
                       destdirInstall
                     else # iproute2 needs destdirInstall
                       case $PkgName in
                          iproute2) # built with DESTDIR so add destdirInstall
                            destdirInstall
                          ;;
                       esac
                     fi
# set which unpack to use
                     if $installBinTarfile; then # unpack not required
                       echo "pkgVers=$binTarfileVers" >> $Output
                       echo "# unpack the binary tarfile" >> $Output
                     elif [ "$Chapter" = chapter10 ]; then # use unpack10
                         unpack10 >> $Output
                         useUnpack=unpack10
                     elif [ "$Chapter" = update ]; then # check make_kernel
                       if $make_kernel; then
                         unpack10 >> $Output
                         useUnpack=unpack10
                       else
                         unpack >> $Output
                         useUnpack=unpack
                       fi
                     else
                       unpack >> $Output
		       useUnpack=unpack
                     fi
#
# use the getUrlSrcDnld function to invoke the correct unpack
                     if $installBinTarfile; then # don't need to set getUrlSrcDnld
                       : # continue
                     else
                       case $PkgName in
                          py3-flit-core) # install dir is pythonmodules
                            echo "pkgVers=$flitVers" >> $Output
                            if $useDESTDIR; then
                              getUrlSrcDnld $useUnpack "$PkgName" '${SrcName}${pkgVers}.tar.gz' "/usr/src/pythonmodules"
                            else
                              echo "# don't need to call unpack, using pip to install the module" >> $Output
			    fi
                          ;;
                          py3-installer) # install dir is pythonmodules
                            echo "pkgVers=$installerVers" >> $Output
                            if $useDESTDIR; then
                              getUrlSrcDnld $useUnpack "$PkgName" '${SrcName}${pkgVers}.tar.gz' "/usr/src/pythonmodules"
                            else
                              echo "# don't need to call unpack, using pip to install the module" >> $Output
			    fi
                          ;;
                          gettext|bison|perl|python3|texinfo|util-linux)
                            getUrlSrcDnld $useUnpack "$PkgName" "" "$PkgUserDir"
                          ;;
                          kernel|linux-headers) # check if a chapter10 install or an update
                            useThisSrcLoc=$PkgUserDir # default is kernel installed 
                            if [[ "$Chapter" = chapter10 || "$Chapter" = update ]]; then
                              useThisKernelVers=$kernLatestVers
                              if [ ! -z "$linuxInstallVers" ]; then
                                if [ "$linuxInstallVers" != "$kernLatestVers" ]; then
                                  echo "The installed kernel $linuxInstallVers is different from the latest available kernel"
                                  echo "Do you want to use the latest $kernLatestVers kernel? [Y/n]"
                                  read REPLY
                                    case $REPLY in
                                       [nN]|[nN][Oo])
                                         echo "Will use the installed linux version $linuxInstallVers"
                                         useThisKernelVers=$linuxInstallVers
                                       ;;
                                       *)
                                         echo "Will use the latest linux version $useThisKernelVers"
                                         rm -rf "${LFS}${PkgUserDir}/linux-headers/linux-${linuxInstallVers}.tar.xz"
                                         rm -rf "${LFS}${PkgUserDir}/linux-headers/linux-${linuxInstallVers}"
                                       ;;
                                    esac
                                else # the same version
                                  echo "The installed kernel $useThisKernelVers is the latest version"
                                fi
                              else # linuxInstallVers is null, no kernel installed
                                if [ "$Chapter" = chapter10 ]; then useThisSrcLoc=$preChrootBuild; fi
                              fi
                              echo "pkgVers=$useThisKernelVers" >> $Output
                              if [ "$Chapter" = update ]; then # useThisSrcLoc not needed because install dir is cleaned
                                useThisSrcLoc=""
                              fi
msg "calling getUrlSrcDnld, useUnpack is $useUnpack"
                              getUrlSrcDnld $useUnpack "$PkgName" '${SrcName}${pkgVers}.tar.xz' "$useThisSrcLoc"
                            else # a problem
                              echo "calling getUrlSrcDnld but Chapter is $Chapter"
                              echo "It should be chapter10 or update"
                              echo "INVESTIGATE"
                              exit 1
                            fi
                          ;;
                          *)
                            getUrlSrcDnld $useUnpack "$PkgName" "" "$preChrootBuild"
                          ;;
                       esac
# download any additional files
                       dnldAddFiles
                     fi
                   else # building as root
                     echo "CreateBuildDirasroot \$PkgName
SrcName=$SrcName" >> $Output
                     if [[ "$SOURCES" = download || "$SOURCES" = local ]]; then
                       case $PkgName in
                          glibc)
                            echo "unpack \$SrcName \"\" \"\" \"$addPattern\"" >> $Output
# get the tzdata file
                            cat >> $Output << "EOF"
if [ -e ${sourceloc}/tzdata*.tar.?z* ]; then
  cp -v ${sourceloc}/tzdata*.tar.?z* ..
else
  echo "*** No tzdata file found in $sourceloc ***"
  echo "Place it there in order to continue."
  exit 1
fi
EOF
                          ;;
                          systemd) # distinguish the srcfile from the manpage file
                            echo "unpack \$SrcName \"\" \"\" \"$addPattern\" true" >> $Output
                          ;;
                          *)
                            echo "unpack \$SrcName \"\" \"\" \"$addPattern\"" >> $Output
                          ;;
                       esac
                     elif [[ "$SOURCES" = atinstall ]]; then # get the srcURL and download any extra files
# py3-flit-core and py3-installer are installed using pip, not from the source tarfile
                       if [[ "$PkgName" != "py3-flit-core" && "$PkgName" != "py3-installer" ]]; then
                         useUnpack="unpack"
                         case $PkgName in
                            kernel|linux-headers) # check if a chapter10 install or an update
                              if [[ "$Chapter" = chapter10 || "$Chapter" = update ]]; then
                                useThisSrcLoc=$PkgUserDir # default is kernel installed 
                                useThisKernelVers=$kernLatestVers
                                if [ ! -z "$linuxInstallVers" ]; then
                                  if [ "$linuxInstallVers" != "$kernLatestVers" ]; then
                                    echo "The installed kernel $linuxInstallVers is different from the latest available kernel"
                                    echo "Do you want to use the latest $kernLatestVers kernel? [Y/n]"
                                    read REPLY
                                      case $REPLY in
                                         [nN]|[nN][Oo])
                                           echo "Will use the installed linux version $linuxInstallVers"
                                           useThisKernelVers=$linuxInstallVers
                                         ;;
                                         *)
                                           echo "Will use the latest linux version $useThisKernelVers"
                                           rm -rf "${LFS}${PkgUserDir}/linux-headers/linux-${linuxInstallVers}.tar.xz"
                                           rm -rf "${LFS}${PkgUserDir}/linux-headers/linux-${linuxInstallVers}"
                                         ;;
                                      esac
                                  else # the same version
                                    echo "The installed kernel $useThisKernelVers is the latest version"
                                  fi
                                else # linuxInstallVers is null, no kernel installed
                                  if [ "$Chapter" = chapter10 ]; then useThisSrcLoc=$preChrootBuild; fi
                                fi
                                echo "pkgVers=$useThisKernelVers" >> $Output
                                if [ "$Chapter" = update ]; then # useThisSrcLoc not needed because install dir is cleaned
                                  useThisSrcLoc=""
                                fi
msg "calling getUrlSrcDnld, useUnpack is $useUnpack"
msg "PkgName is $PkgName"
                                getUrlSrcDnld $useUnpack "$PkgName" '${SrcName}${pkgVers}.tar.xz' "$useThisSrcLoc"
                              else # a problem
                                echo "calling getUrlSrcDnld but Chapter is $Chapter"
                                echo "It should be chapter10 or update"
                                echo "INVESTIGATE"
                                exit 1
                              fi
                            ;;
                            *)
msg "PkgName is $PkgName"
                              getUrlSrcDnld $useUnpack "$PkgName" "" "$preChrootBuild"
                              dnldAddFiles
                            ;;
                         esac
                       fi
                     fi
                   fi # end test building as root
                 ;;
              esac
          ;;
        esac
   ;;
esac # case currentChapter in
# add seds here to alter Makefiles or do any additions to the script such as timings
#
if $installBinTarfile; then # installing from a binary tarfile
# unpack the binary tarfile and call destdirInstall
  cat >> $Output << "EOF"
tar xf pkgbindir/${SrcName}${pkgVers}-x86_64.pkg.tar.xz
# install the files
destdirInstall "$CUR_DIR"
EOF
else
  case $PkgName in
     kernel) # if making the kernel, need to add mproper and any firmware
       if $make_kernel; then
         cat >> $Output << "EOF"
make mrproper
cp ${sourcedir}/.config .
# copy the firmware to /usr/lib/firmware
cp -r /tools/pkguser/firmware/* /usr/lib/firmware/
EOF
       fi
     ;;
     man-pages)
       echo "sed -i '/install -d -m 755 \\\\\$(DESTDIR)\\\\\$(MANDIR)/d ' Makefile" >> $Output
     ;;
     py3-flit-core|py3-installer) # don't call unpack but need to set timings
       if [[ ("$Chapter" = chapter08 || "$Chapter" = update) && "$useDESTDIR" = false ]]; then
         cat >> $Output << "EOF"
# using binaries from Pypi so don't call unpack
curdir=$( echo $PWD )
# have to set the following timings
starttime=$( date +%s )
endtime=$( date +%s )
if [ $endtime -eq $starttime ]; then
  unpacktime=0
else
  unpacktime=$( expr $endtime - $starttime )
fi
starttime=$( date +%s )
usePip=true
EOF
       fi
     ;;
  esac
  WriteScript
fi
closefunction
} # end of Function
closefunction () {
#msg "currentChapter is $currentChapter"
case "$currentChapter" in
    chapter05|chapter06)
       cat >> $Output << "EOF"
touch ${curdir}/../.${Chapter/apter/}${PkgName}
endtime=$( date +%s )
set +e
cd $curdir/..
rm -rf $curdir
elapsedtime=$( expr $endtime - $starttime )
set -e
EOF
# if wget, add resolv.conf
       if [[ "$as_root" = true && "$FuncName" = wget ]]; then
         cat >> $Output << "EOF"
cat > ${LFS}/etc/resolv.conf << "RESOLVEOF"
nameserver 192.168.1.1
search mynet 
RESOLVEOF
EOF
       fi
       if $as_root; then
         cat >> $Output << "EOF"
echo "$FuncName $unpacktime $elapsedtime" >> ${LFS}${BuildLog}
EOF
echo "} # end $FuncName" >> $Output
       else
         cat >> $Output << "EOF"
echo "$FuncName $unpacktime $elapsedtime" >> ${BuildLog}
EOF
echo "} # end $FuncName" >> $Output
       fi
       if ! $as_root; then
         case $FuncName in
    	    make|tar|wget) # can't use any name that is a linux command  
              makeName="${FuncName}Make"
              echo "$makeName" >> $Output
	    ;;
            *)
              echo "$FuncName" >> $Output
            ;;
         esac	  
         cat >> $Output << "EOF"
IPS
chmod 755 "${LFS}/install${PkgName}.sh"
# run the script specified in .bash_profile
su - $PkgName -c "${LFS}/install${PkgName}.sh"
# set required dirs to be install dirs
EOF
#set required dirs to be install dirs
         case $FuncName in
            bash)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/lib/pkgconfig
chmod 1775 $LFS/usr/lib/pkgconfig
chgrp install $LFS/usr/share/doc
chmod 1775 $LFS/usr/share/doc
EOF
              fi
            ;;
            binutilspass1)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/tools/{bin,lib,share/{,info,man/{,man1}},x86_64-lfs-linux-gnu/{,bin,lib/{,ldscripts}}}
chmod 1775 $LFS/tools/{bin,lib,share/{,info,man/{,man1}},x86_64-lfs-linux-gnu/{,bin,lib/{,ldscripts}}}
EOF
              fi
            ;;
            coreutils)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/share/man/man8
chmod 1775 $LFS/usr/share/man/man8
EOF
              fi
	    ;;
            file)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/share/man/{man3,man4,man5}
chmod 1775 $LFS/usr/share/man/{man3,man4,man5}
EOF
              fi
            ;;
            gccpass1)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/tools/{include,lib,libexec}
chmod 1775 $LFS/tools/{include,lib,libexec}
EOF
              fi
	    ;;
            glibc)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/libexec
chmod 1775 $LFS/usr/libexec
chgrp install $LFS/usr/share/{,i18n,locale}
chmod 1775 $LFS/usr/share/{,i18n,locale}
rm -rf $LFS/usr/share/locale/* # don't need these in chapter 5 or 6
mkdir -pv $LFS/usr/share/info # for m4 in chap 6
chgrp install $LFS/usr/share/info
chmod 1775 $LFS/usr/share/info
chgrp install $LFS/var/lib
chmod 1775 $LFS/var/lib
# run this as root and set resulting files owned by gcc
LFS_TGT="x86_64-lfs-linux-gnu"
EOF
echo '$LFS/tools/libexec/gcc/$LFS_TGT/"'$gccvers'"/install-tools/mkheaders
chown gcc:gcc /mnt/lfs/tools/lib/gcc/$LFS_TGT/"'$gccvers'"/include-fixed/{limits.h,pthread.h,syslimits.h}' >> $Output
              fi
            ;;
            linuxheaders)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/include/{,scsi}
chmod 1775 $LFS/usr/include/{,scsi}
EOF
              fi
            ;;
            m4)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/share/man/{,man1}
chmod 1775 $LFS/usr/share/man/{,man1}
EOF
              fi
	    ;;
            ncurses)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/share/man/{man3,man5,man7}
chmod 1775 $LFS/usr/share/man/{man3,man5,man7}
EOF
              fi
            ;;
         esac
         cat >> $Output << "EOF"
# delete the install script
rm -v "${LFS}/install${PkgName}.sh"
EOF
         case $FuncName in
            wget) # add the /etc/resolv.conf file as root
              cat >> $Output << "EOF"
cat > ${LFS}/etc/resolv.conf << "RESOLVEOF"
nameserver 192.168.1.1
search mynet
RESOLVEOF
EOF
            ;;
         esac
         echo "} # end $FuncName" >> $Output
       fi
    ;;
    chapter07|chapter08) # no revisedchroot since (03/22). Now cleanup in Ch8
       case $PkgName in
           chroot|cleanup|kernfs|creatingdirs|createfiles|stripping)
               cat >> $Output << "EOF"
echo "${FuncName}" >> $BuildLog
}
EOF
           ;;
           *)
             case $PkgName in
                ncurses) # need the non-wide libs for chromium
                  cat >> $Output << "EOF"
echo "installing non-wide-character Ncurses libraries"
make distclean
non-wideconfigure_commands()
{ :
  ./configure --prefix=/usr    \
              --with-shared    \
              --without-normal \
              --without-debug  \
              --without-cxx-binding \
              --with-abi-version=5
}
non-widemake_commands()
{ :
  make sources libs
}
non-wideinstall_commands()
{ :
EOF
                  if [ "$useDESTDIR" = true ]; then # ch08
                    echo "cp -av lib/lib*.so.5* \"\${CUR_DIR}\"/usr/lib" >> $Output
                  else
                    echo "cp -av lib/lib*.so.5* /usr/lib" >> $Output
                  fi
                  cat >> $Output << "EOF"
}
echo -n non-wideConfigure...
{ non-wideconfigure_commands 3>&1 1>&2 2>&3 | tee "$CUR_DIR/non-wideconfigure.err" ;} &>"$CUR_DIR/non-wideconfigure.log"
test_pipe
echo -n non-wideCompile...
{ non-widemake_commands 3>&1 1>&2 2>&3 | tee "$CUR_DIR/non-widemake.err" ;} &>"$CUR_DIR/non-widemake.log"
test_pipe
echo -n non-wideInstall...
{ non-wideinstall_commands 3>&1 1>&2 2>&3 | tee "$CUR_DIR/non-wideinstall.err" ;} &>"$CUR_DIR/non-wideinstall.log"
test_pipe
EOF
                  if [ "$useDESTDIR" = true ]; then
                    echo "ln -sv libncurses.so.5.9 \"\${CUR_DIR}\"/usr/lib/libtinfo.so.5" >> $Output # this link is for chromium
                  else
                    echo "ln -sv libncurses.so.5.9 /usr/lib/libtinfo.so.5" >> $Output
                  fi
                ;;
                iproute2) # built with DESTDIR so install the package
                  if [ ! "$Chapter" = update ]; then # chapter08
                    echo "# install the package
set +e
destdirInstall \"\$CUR_DIR\"
set -e" >> $Output
                  fi
                ;;
             esac
             if ! $as_root; then
               if [ "$Chapter" = chapter07 -o "$Chapter" = chapter08 ]; then
                 baseTestBuilt=".\${Chapter/apter/}\${PkgName}"
                 if $useDESTDIR; then
                   if $installDEST; then # need a destdirInstall install
                     cat >> $Output << "EOF"
set +e
destdirInstall "$CUR_DIR"
set -e
EOF
                   fi
                   baseTestBuilt="${baseTestBuilt}-destdir"
                 else # not destdir, test if a binary tarfile install
                   if $installBinTarfile; then
                     baseTestBuilt="${baseTestBuilt}-install"
                   fi
                 fi
               elif  [ "$Chapter" = update ]; then
                 baseTestBuilt=".\${Chapter}\${PkgName}"
                 if $useDESTDIR; then
                   baseTestBuilt="${baseTestBuilt}-destdir"
                 else # not destdir
                   if $installBinTarfile; then
                     baseTestBuilt="${baseTestBuilt}-install"
                   fi
                 fi
               fi
               echo "testBuilt=\"$baseTestBuilt\"" >> $Output
               cat >> $Output << "EOF"
touch ~/${testBuilt}
endtime=$( date +%s )
set +e
EOF
             else # as root
                cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}"
touch ${PkgUserDir}/${PkgName}/${testBuilt}
endtime=$( date +%s )
set +e
EOF
             fi # as root test
             if $installBinTarfile; then # delete the binary dirs
               echo "rm -rf etc opt run usr var" >> $Output
             else
               if [[ "$PkgName" = "py3-flit-core" || "$PkgName" = "py3-installer" ]]; then
                 delPy3File >> $Output
             else
                 delSrcFile >> $Output
             fi
             fi
             if [ "$PkgName" = glibc ]; then #also delete glibc-build
               echo "rm -rf glibc-build" >> $Output
             elif [ "$PkgName" = binutils ]; then #also delete binutils-build
               echo "rm -rf binutils-build" >> $Output
             elif [ "$PkgName" = gcc ]; then #also delete gcc-build
               echo "rm -rf gcc-build" >> $Output
             fi
             cat >> $Output << "EOF"
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "$PkgName $unpacktime $elapsedtime" >> $BuildLog
EOF
             if ! $as_root; then
               echo "IPS" >> $Output
               if [[ "$Chapter" = chapter07 && "$PkgName" = util-linux && "$createBinFile" = true ]]; then # don't want resolvelinks
                 echo "Don't need resolvelinks for util-linux in chapter07"
               else
                 setuplinks # setup any preprocessing commands
                 if [[ ! -z "$otherPrePro" || ! -z "$doFirst" || ! -z "$links" ]]; then resolvelinks; fi # not null
               fi
               case $PkgName in
                  openssl)
                    cat >> $Output << "EOF"
if [ "$(grep -q ^$PkgName\: /etc/passwd;echo $?)" != 0 ]; then
  installpkg $PkgName "core" 10055
fi
EOF
                  ;;
                  py3-flit-core|py3-installer)
                    cat >> $Output << "EOF"
if [ "$(grep -q ^$PkgName\: /etc/passwd;echo $?)" != 0 ]; then
  installpkg $PkgName "pythonmodules"
fi
EOF
                  ;;
                  wheel)
                    cat >> $Output << "EOF"
if [ "$(grep -q ^$PkgName\: /etc/passwd;echo $?)" != 0 ]; then
  installpkg $PkgName "core" 97
fi
EOF
                  ;;
                  *)
                    cat >> $Output << "EOF"
if [ "$(grep -q ^$PkgName\: /etc/passwd;echo $?)" != 0 ]; then
  installpkg $PkgName
fi
EOF
               esac
               if [[ "$Chapter" = chapter07 && "$PkgName" = util-linux && "$createBinFile" = true ]]; then # don't want resolvelinks
                 :
               else
                 if [[ ! -z "$otherPrePro" || ! -z "$doFirst" || ! -z "$links" ]]; then # preprocessing
                   cat >> $Output << "EOF"
resolvelinks
EOF
                 fi
               fi
               cat >> $Output << "EOF"
chmod 755 ${PkgUserDir}/${PkgName}/build
# make sure .bash_profile and .bashrc are symlinks to /etc/pkgusr
setUserEnv $PkgUserDir $PkgName
su $PkgName -c "source ${PkgUserDir}/${PkgName}/.bash_profile"
EOF
#
# test if the build was successful
#
               if [ "$Chapter" = chapter07 -o "$Chapter" = chapter08 ]; then
                 baseTestBuilt=".\${Chapter/apter/}\${PkgName}"
                 comment="\$PkgName failed"
                 if $useDESTDIR; then
                   baseTestBuilt="${baseTestBuilt}-destdir"
                   comment="\$PkgName using DESTDIR failed"	   
                 else # not destdir, test if a binary tarfile install
                   if $installBinTarfile; then
                     baseTestBuilt="${baseTestBuilt}-install"
                     comment="binary tarfile install for \$PkgName failed"
                   fi
                 fi
               elif [ "$Chapter" = update ]; then
                 baseTestBuilt=".\${Chapter}\${PkgName}"
                 comment="update of \$PkgName failed"
                 if $useDESTDIR; then
                   baseTestBuilt="${baseTestBuilt}-destdir"
                   comment="update of \$PkgName using DESTDIR failed"
                 fi
               fi
               echo "testBuilt=\"$baseTestBuilt\"" >> $Output
               cat >> $Output << "EOF"
if [ ! -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
EOF
               echo "  echo \"$comment\"" >> $Output
# add exit 1 if the build failed
               cat >> $Output << "EOF"
  exit 1
fi
EOF
               echo "chown \$PkgName:\$PkgName \${PkgUserDir}/\${PkgName}/$build" >> $Output
               case $PkgName in
                  linux-headers|man-pages) # do not ldconfig - not installed until glibc
                    :
                  ;;
                  *)
                    if ! $useDESTDIR; then
                      cat >> $Output << "EOF"
if [ -e "/etc/ld.so.cache~" ]; then # make sure owner is root
  chown 0 /etc/ld.so.cache~
fi
ldconfig
EOF
                    fi
                  ;;
               esac
# set required dirs to be install dirs
               setInstallDirs $PkgName
# do any post processing as root
               postProcessing $PkgName
               if $useDESTDIR; then
                 if ! $installDEST; then # create the binary tarfile
                   case $PkgName in
                      py3-flit-core)
                          echo "createPkgfile \$PkgUserDir \$PkgName \"3.7.1\"" >> $Output
                      ;;
                      linux-headers)
                          if [ ! -z "$useThisKernelVers" ]; then
                            echo "createPkgfile \$PkgUserDir \$PkgName \"$useThisKernelVers\"" >> $Output
                          else # use linuxInstallVers
                            if [ ! -z "$linuxInstallVers" ]; then
                              echo "createPkgfile \$PkgUserDir \$PkgName \"$linuxInstallVers\"" >> $Output
                            else
                              echo "didn't use linuxvers which is $linuxvers"
                              echo "Investigate"
                              exit 1
                            fi
                          fi
                      ;;
                      libelf)
                          echo "createPkgfile \$PkgUserDir \$PkgName \"$elfutilsvers\"" >> $Output
                      ;;
                      *)
                          echo "createPkgfile \$PkgUserDir \$PkgName" >> $Output
                      ;;
                   esac
                 fi
               fi
               echo "} # end $FuncName" >> $Output
             else # as root
               case $PkgName in
                  meson)
                    cat >> $Output << "EOF"
cat > /usr/bin/arch-meson << "MESONEOF"
#!/bin/bash -ex
# Arch Linux Meson wrapper

exec meson setup \
  --prefix         /usr \
  --libdir         /usr/lib \
  --libexecdir     /usr/lib \
  --bindir         /usr/bin \
  --sbindir        /usr/bin \
  --includedir     /usr/include \
  --datadir        /usr/share \
  --mandir         /usr/share/man \
  --infodir        /usr/share/info \
  --localedir      /usr/share/locale \
  --sysconfdir     /etc \
  --localstatedir  /var \
  --sharedstatedir /var/lib \
  --buildtype      plain \
  --warnlevel      2 \
  --auto-features  enabled \
  --wrap-mode      nodownload \
  -D               b_lto=true \
  "$@"
MESONEOF
chmod 755 /usr/bin/arch-meson
EOF
                  ;;
               esac
               echo "} # end $FuncName" >> $Output
             fi # end of as_root test
         ;; #name loop
       esac
    ;; # close chapter07/08 loop
    chapter10)
      if ! $as_root; then
        if $installBinTarfile; then # test if chapter10 or update
          if [ "$Chapter" = chapter10 ]; then
            cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}-install"
touch ~/${testBuilt}
EOF
          elif [ "$Chapter" = update ]; then
            cat >> $Output << "EOF"
testBuilt=".${Chapter}${PkgName}-install"
touch ~/${testBuilt}
EOF
          fi
        elif $useDESTDIR; then
          if [ "$Chapter" = update ]; then
            cat >> $Output << "EOF"
testBuilt=".update${PkgName}-destdir"
touch ~/${testBuilt}
EOF
          else
            cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}-destdir"
touch ~/${testBuilt}
EOF
          fi
        elif [ "$Chapter" = update ]; then # not destdir
          cat >> $Output << "EOF"
testBuilt=".update${PkgName}"
touch ~/${testBuilt}
EOF
        else
          cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}"
touch ~/${testBuilt}
EOF
        fi
        cat >> $Output << "EOF"
endtime=$( date +%s )
set +e
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "$PkgName $unpacktime $elapsedtime" >> $BuildLog
EOF
        echo "IPS" >> $Output
        if $installBinTarfile; then # don't need resolvelinks 
          echo "don't need resolvelinks when installing a kernel binary tarfile"
        else
          setuplinks # setup any preprocessing commands
          if [[ ! -z "$otherPrePro" || ! -z "$doFirst" || ! -z "$links" ]]; then resolvelinks; fi # not null
        fi
	cat >> $Output << "EOF"
if [ "$(grep -q ^$PkgName\: /etc/passwd;echo $?)" != 0 ]; then
  installpkg $PkgName
fi
EOF
        if $installBinTarfile; then # don't need resolvelinks
          : # continue
        else
          if [[ ! -z "$otherPrePro" || ! -z "$doFirst" || ! -z "$links" ]]; then # preprocessing
            cat >> $Output << "EOF"
resolvelinks
EOF
          fi
        fi
        echo "if ! \$AS_ROOT; then chown \$PkgName:\$PkgName \${PkgUserDir}/\${PkgName}/build; fi
chmod 755 \${PkgUserDir}/\${PkgName}/build
# make sure .bash_profile and .bashrc are symlinks to /etc/pkgusr
setUserEnv \$PkgUserDir \$PkgName
su \$PkgName -c \"source \${PkgUserDir}/\${PkgName}/.bash_profile\"" >> $Output
#
# check if the build failed
#
        if [ "$Chapter" = chapter10 ]; then # not update
          if $installBinTarfile; then
            cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}-install"
if [ ! -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
  echo "Installing $PkgName from a binary tarfile failed"
  exit 1
fi
EOF
          elif $useDESTDIR; then # write out the failure test
            cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}-destdir"
if [ ! -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
  echo "$PkgName using DESTDIR failed"
  exit 1
fi
EOF
            if ! $createBinFile; then # write ldconfig
              cat >> $Output << "EOF"
if [ -e "/etc/ld.so.cache~" ]; then # make sure owner is root
  chown 0 /etc/ld.so.cache~
fi
ldconfig
EOF
            fi
          else # not DESTDIR # write out the failure test
              cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}"
if [ ! -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
  echo "$PkgName failed"
  exit 1
fi
if [ -e "/etc/ld.so.cache~" ]; then # make sure owner is root
  chown 0 /etc/ld.so.cache~
fi
ldconfig
EOF
          fi
        elif [ "$Chapter" = update ]; then
          if $installBinTarfile; then
            cat >> $Output << "EOF"
testBuilt=".${Chapter}${PkgName}-install"
if [ ! -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
  echo "Installing $PkgName from a binary tarfile failed"
  exit 1
fi
EOF
          elif $useDESTDIR; then
            cat >> $Output << "EOF"
testBuilt=".${Chapter}${PkgName}-destdir"
if [ ! -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
  echo "$PkgName using DESTDIR failed"
  exit 1
fi
EOF
            if ! $createBinFile; then # write ldconfig
              cat >> $Output << "EOF"
if [ -e "/etc/ld.so.cache~" ]; then # make sure owner is root
  chown 0 /etc/ld.so.cache~
fi
ldconfig
EOF
	    fi
          else # not DESTDIR # write out the failure test
            cat >> $Output << "EOF"
testBuilt=".${Chapter}${PkgName}"
if [ ! -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
  echo "$PkgName failed"
  exit 1
fi
if [ -e "/etc/ld.so.cache~" ]; then # make sure owner is root
  chown 0 /etc/ld.so.cache~
fi
ldconfig
# clean the /boot dir
rm -v /boot/{config-*,System.map-*,vmlinuz-*}
EOF
          fi
        fi
        echo "chown \$PkgName:\$PkgName \${PkgUserDir}/\${PkgName}/$build" >> $Output
      else # as root
# TODO account for Chapter=update when user is root
         if $useDESTDIR; then
echo "touch \${PkgUserDir}/\${PkgName}/.\${PkgName}-destdir" >> $Output
         else
echo "touch \${PkgUserDir}/\${PkgName}/.\${PkgName}" >> $Output
         fi
         cat >> $Output << "EOF"
endtime=$( date +%s )
set +e
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "$PkgName $unpacktime $elapsedtime" >> $BuildLog
EOF
      fi # end as_root test
#
      if $make_kernel && ! $installBinTarfile; then # write out the cp commands
        kerneldir="\${PkgUserDir}/\${PkgName}/linux-"
        if $useDESTDIR; then
          echo "mkdir -pv \${PkgUserDir}/\${PkgName}/boot
useThisKernelVers=$useThisKernelVers
cp -iv ${kerneldir}\${useThisKernelVers}/arch/x86/boot/bzImage \${PkgUserDir}/\${PkgName}/boot/vmlinuz-\${useThisKernelVers}-lfs
cp -iv ${kerneldir}\${useThisKernelVers}/System.map \${PkgUserDir}/\${PkgName}/boot/System.map-\${useThisKernelVers}
cp -iv ${kerneldir}\${useThisKernelVers}/.config \${PkgUserDir}/\${PkgName}/boot/.config-\${useThisKernelVers}" >> $Output
          if [ "$Chapter" = update ]; then # create the binary tarfile
            echo "createPkgfile \$PkgUserDir \$PkgName \"\$useThisKernelVers\"" >> $Output
          fi
        else
          echo "useThisKernelVers=$useThisKernelVers
cp -iv ${kerneldir}\${useThisKernelVers}/arch/x86/boot/bzImage /boot/vmlinuz-\${useThisKernelVers}-lfs
cp -iv ${kerneldir}\${useThisKernelVers}/System.map /boot/System.map-\${useThisKernelVers}
cp -iv ${kerneldir}\${useThisKernelVers}/.config /boot/.config-\${useThisKernelVers}" >> $Output
        fi
#
# only want the following code if Chapter is not update
        if [ "$Chapter" != update ]; then
          IFSOLD=$IFS
          IFS='
' # set to CRLF
          rtrnCom=""
          CmdName=theend
          getComms "chapter11"
          for line in ${rtrnCom[@]}; do
            case $line in
              DISTRIB_CODENAME*|VERSION_CODENAME*)
                echo $line | sed -e 's@<your name here>@LFS@' >> $Output
              ;;
              *"/etc/lfs-release"*|*"/etc/lsb-release"*|*"/etc/os-release"*)
                if $useDESTDIR; then echo $line | sed -e 's|/etc/lfs-release|${PkgUserDir}/${PkgName}/etc/lfs-release|' \
                                                      -e 's|/etc/lsb-release|${PkgUserDir}/${PkgName}/etc/lsb-release|' \
                                                      -e 's|/etc/os-release|${PkgUserDir}/${PkgName}/etc/os-release|' \
                                     >> $Output
                else
                  echo $line >> $Output
                fi
              ;;
              *)
                echo $line >> $Output
              ;;
            esac
          done
          if $useDESTDIR; then
            cat >> $Output << "EOF"
if ! $AS_ROOT; then chown $PkgName:$PkgName ${PkgUserDir}/${PkgName}/etc/{lfs-release,lsb-release,os-release}; fi
EOF
            echo "createPkgfile \$PkgUserDir \$PkgName \"\$useThisKernelVers\"" >> $Output
          else
            cat >> $Output << "EOF"
if ! $AS_ROOT; then chown $PkgName:$PkgName /etc/{lfs-release,lsb-release,os-release}; fi
EOF
            if ! $as_root; then
               cat >> $Output << "EOF"
# ask to delete files owned by wget in Chapter06
echo "Do you want to delete the wget files? [y/N]"
read Reply
case $Reply in
   [yY]|[yY][Ee][Ss])
     echo "okay, the wget files will be deleted"
     /usr/bin/listdelpkg.sh 10171 10171 delete
   ;;
   *)
     echo "The wget list files will be left in place"
   ;;
esac
# change owner of /usr/share/locale/en_GB and rw installed by wget
chown bash:bash /usr/share/locale/{en_GB,rw}
chown bash:install /usr/share/locale/{rw/LC_MESSAGES,en_GB/LC_MESSAGES}
EOF
            fi
            cat >> $Output << "EOF"
# ask to delete the build dir from Ch. 5 and 6
echo "Do you want to delete the /build dir from Ch. 5 and 6? [Y/n]"
read Reply
case $Reply in
   [nN]|[nN][Oo])
     echo "okay, leaving the /build dir in place"
   ;;
   *)
     echo "okay, deleting build dir /build"
     rm -rf /build
   ;;
esac
EOF
          fi
          IFS=$IFSOLD
	fi # end Chapter not update
      fi # end test make_kernel
      echo "}" >> $Output
    ;;
esac
} #end closefunction
#
setuplinks () { # setup preprocessing
# links sets the owner of the file to the pkguser
# doFirst sets the given dir(s) to group install and sticky
# otherPrePro is anything else to do before install package
#
links=""
doFirst=""
otherPrePro=""
case $PkgName in
    gcc)
        if ! $useDESTDIR; then
          links="/usr/lib/libstdc++.{a,la} /usr/lib/libgcc_s.so{,.1} /usr/lib/libstdc++.so{,.6} /usr/lib/gcc"
        fi
    ;;
    glibc)
        if ! $useDESTDIR; then
          otherPrePro="if [ -d /lib64 ]; then chgrp install /lib64 && chmod 1775 /lib64; fi"
        fi
        if [ "$WHICH_CHAPTER" = update ]; then # /info/dir is owned by root
          links="/usr/share/info/dir"
        fi
    ;;
    bash)
        if ! $useDESTDIR; then
          links="/bin/bash /bin/sh"
        fi
    ;;
    bison) # needed in chapter07
        if ! $useDESTDIR; then
          doFirst="/usr/share/{doc,info}"
        fi
    ;;
    coreutils)
        if ! $useDESTDIR; then
          links="/bin/{cat,chmod,dd,echo,env,false,install,ln,mkdir,printf,pwd,rm,stty,touch} /etc/group"
        fi
    ;;
    flex)
        if ! $useDESTDIR; then
          otherPrePro="if [ -L /usr/bin/lex ]; then rm /usr/bin/lex; fi"
          links="/usr/lib/libfl.so.2.0.0"
        fi
    ;;
    gettext)
        if ! $useDESTDIR; then
          doFirst="/usr/share/man/*"
        fi
    ;;
    inetutils)
        if ! $useDESTDIR; then
          links="/usr/bin/{dnsdomainname,hostname,ping,ping6,traceroute} /usr/share/man/man1/{dnsdomainname.1,hostname.1}"
        fi
    ;;
    jinja2)
        if ! $useDESTDIR; then
          otherPrePro="chgrp install /usr/lib/python3.10/site-packages/easy-install.pth && chmod 664 /usr/lib/python3.10/site-packages/easy-install.pth"
        fi
    ;;
    kmod)
        if ! $useDESTDIR; then
          doFirst="/usr/share/bash-completion/completions"
        fi
    ;;
    kernel) # install /lib/firmware dir
        if [ "$Chapter" != update ]; then
          otherPrePro="mkdir -pv /usr/lib/firmware"
          doFirst="/usr/lib/firmware"
        fi
    ;;
    man-pages) # in update mode, need to own some man pages
        if [ "$WHICH_CHAPTER" = update ]; then
          if ! $useDESTDIR; then
            otherPrePro="chown man-pages:man-pages /usr/share/man/man{1..8}" 
            links="/usr/share/man/{man3/getspnam.3,man5/{attr.5,passwd.5}} "
          fi
        else
          if ! $useDESTDIR; then
            doFirst="/usr/share/man/{,man2,man6}"
          fi
        fi
    ;;
    ncurses)
        if ! $useDESTDIR; then
          links="/etc/ld.so.cache /usr/lib/libncurses.so"
        fi
    ;;
    openssl)
        if ! $useDESTDIR; then
          links="/usr/lib/libcrypto.so* /usr/include/openssl/aes.h"
        fi
    ;;
    perl)
        if ! $useDESTDIR; then
          links="/usr/bin/perl"
        fi
    ;;
    python3)
          doFirst="/usr/lib/pkgconfig"
    ;;
    shadow)
        if ! $useDESTDIR; then
          links="/usr/share/man/man{5/passwd.5,3/getspnam.3} /etc/{passwd,shadow,group,gshadow}{,-} /usr/bin/{chage,chfn,chsh,expiry,gpasswd,groupadd,newgidmap,newgrp,newuidmap,passwd,su,useradd}"
        fi
    ;;
    sysklogd)
        if ! $useDESTDIR; then
          links="/usr/share/man/man8/sysklogd.8"
        fi
    ;;
    systemd)
        if ! $useDESTDIR; then
          otherPrePro="if [ \"\$(grep -q ^systemd-journal\: /etc/group;echo \$?)\" != 0 ]; then
  groupadd -g 23 systemd-journal
fi"
          doFirst="/usr/share/locale/ka/LC_MESSAGES"
          links="/usr"
        fi
    ;;
    eudev)
        if ! $useDESTDIR; then
          links="/lib/{firmware,udev,udev/devices,udev/devices/pts}"
        fi
    ;;
    tcl) # if update, need to mv man3/Thread.3 out the way cos it's owned by Perl
        if [ "$WHICH_CHAPTER" = update ]; then
          if ! $useDESTDIR; then
            otherPrePro="mv -v /usr/share/man/man3/{Thread,Thread_Perl}.3"
          fi
        fi
    ;;
    util-linux)
        if [ "$WHICH_CHAPTER" = update ]; then
          if ! $useDESTDIR; then
            links="/usr/bin/{mount,su,umount,wall} /usr/share/man/man1/su.1"
          fi
        else
          otherPrePro="rm -rf /usr/{lib/{libmount.a,libuuid.a,libblkid.a,pkgconfig/{blkid,fdisk,mount,uuid}.pc},include/{blkid,libfdisk,libmount,uuid}}"
          links="/usr/lib/lib{blkid,fdisk,mount,uuid}.so* /usr/bin/{mount,umount,wall}"
        fi
    ;;
    vim)
        if ! $useDESTDIR; then
          links="/usr/share/vim/vim80/syntax/ninja.vim"
        fi
    ;;
    xz)
        if ! $useDESTDIR; then
          otherPrePro="rm -rf /usr/lib/liblzma.a"
          links="/usr/lib/liblzma.*"
        fi
    ;;
    zlib)
        if ! $useDESTDIR; then
          doFirst="/usr/lib/pkgconfig"
        fi
    ;;
    *)
        doFirst=""
        links=""
        otherPrePro=""
    ;;
esac
} # end setuplinks
#
resolvelinks () {
# At the beginning of chapter 6 there are symlinks that point to the tools dir
# These are owned by root so need to change owner to the package user
echo "resolvelinks () {" >> $Output
if [ ! -z "$otherPrePro" ];then echo "$otherPrePro" >> $Output; fi
if [ ! -z "$doFirst" ]; then
echo "for doDir in $doFirst; do
 if [ -d "\$doDir" ]; then
   chgrp install \$doDir # set to install group
   chmod 1775 \$doDir # set sticky bit
 fi
done" >> $Output
fi
if [ ! -z "$links" ]; then
echo "for link in $links; do
  if [ -e "\$link" -o -L "\$link" ]; then
    chown -h \$PkgName:\$PkgName \$link # change owner to package user so can overwrite
  fi
done" >> $Output
fi
echo "return 0
} # end resolvelinks" >> $Output
} #end resolvelinks
#
CreateBuildDir () {
# only used in chapter 5 and 6
cat >> $Output << "EOF"
CreateBuildDir () {
BuildDir=${buildDir}/${1}
if [ ! -e $BuildDir ]; then install -d $BuildDir; fi
cd $BuildDir
CUR_DIR=$(echo $PWD)
}
EOF
} #end CreateBuildDir
#
CreateBuildDirasroot () {
cat >> $Output << "EOF"
CreateBuildDirasroot () {
# $1 is the package name, PkgName
BuildDirasroot=${PkgUserDir}/${1}
if [ ! -e $BuildDirasroot ]; then install -d -m755 $BuildDirasroot; fi
cd $BuildDirasroot
CUR_DIR=$(echo $PWD)
} # end CreateBuildDirasroot
EOF
} # end CreateBuildDirasroot
#
unpack05 () {
cat >> $Output << "EOF"
unpack05 () {
# $1 is the source name
# $2, if present, is the url to download the source file
# $3, if present, is the sourceloc of the file already downloaded
sourcelocOld=$sourceloc # sourceloc is global - store it to reset it at the end
local srcname=$1
local srcURL=${2:-""}
local altSourceloc=${3:-""}
if [ ! -z "$altSourceloc" ]; then # set sourceloc to this location
  sourceloc=$altSourceloc
fi
echo "sourceloc is $sourceloc"
starttime=$( date +%s )
if [ -e ${CUR_DIR}/${srcname}*.tar.?z* ]; then # src exists in current dir - use that
  echo "$srcname already in current dir - will use that one"
elif [ -e ${LFS}${sourceloc}/${srcname}*.tar.?z* ]; then # src exists so copy it to current dir
  cp -v ${LFS}${sourceloc}/${srcname}*.* . # copy any patches as well
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on the host
    if [ ! -z "$srcURL" ]; then
      wget $wgetopts $srcURL
    else
      echo "No srcURL given. You need to download the source file"
      echo "Aborting"
      exit 1
    fi
  else
    echo "Install wget on the host to continue"
    echo "Aborting"
    exit 1
  fi
fi
cd $(tar vxf ${srcname}*.tar.?z* | awk -F\/ 'END{print $1}')
curdir=$(echo $PWD)
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
sourceloc=$sourcelocOld
}
EOF
} #end unpack05
#
unpack07 () {
# used when installing as root for chapter07, 8 and 10
cat >> $Output << "EOF"
unpack07 () {
# $1 is the source name
# $2 is the url to download the source file
# $3, if present, is the source filename
# note -  generally the input and output source filenames are the same but
# if using a source file from github then they are often different
# $4, if present, is the sourceloc of the file already downloaded
sourcelocOld=$sourceloc # sourceloc is global - store it to reset it at the end
local srcname=$1
local srcURL=$2
local srcFile=${3:-""}
local altSourceloc=${4:-""}
if [ ! -z "$altSourceloc" ]; then # set sourceloc to this location
  sourceloc=$altSourceloc
fi
echo "sourceloc is $sourceloc"
if [ -z "$srcFile" ]; then srcFile=${srcURL##*/}; fi
echo "srcFile to install is $srcFile" # is this file already in $CUR_DIR
starttime=$( date +%s )
EOF
case $SrcName in
   systemd-) # distinguish from the man-pages file
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${srcname}[0-9]*.tar.?z* ]; then # a srcfile exists in current dir - use that
  echo "$srcname already in current dir - will use that one"
elif [ -e ${sourceloc}/${srcname}[0-9]*.tar.?z* ]; then # src exists so copy it to current dir
EOF
   ;;
   tcl8.) # need to specify -src to distinguish from the html file
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${srcname}*-src.tar.?z* ]; then # a srcfile exists in current dir - use that
  echo "$srcname already in current dir - will use that one"
elif [ -e ${sourceloc}/${srcname}*-src.tar.?z* ]; then # src exists so copy it to current dir
EOF
   ;;
   *)
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${srcname}*.tar.?z* ]; then # a srcfile exists in current dir - use that
  echo "$srcname already in current dir - will use that one"
elif [ -e ${sourceloc}/${srcname}*.tar.?z* ]; then # src exists so copy it to current dir
EOF
   ;;
esac
cat >> $Output << "EOF"
  cp -v ${sourceloc}/${srcname}*.* . # copy any patches as well
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on the target machine
    wget $wgetopts $ncc -O $srcFile $srcURL
  else
    echo "Install wget on the target machine in order to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
case $SrcName in
   systemd-) # distinguish from the man-pages file
     cat >> $Output << "EOF"
cd $(tar vxf ${srcname}[0-9]*.tar.?z* | awk -F\/ 'END{print $1}')
EOF
   ;;
   tcl8.) # need to specify -src to distinguish from the html file
     cat >> $Output << "EOF"
cd $(tar vxf ${srcname}*-src.tar.?z* | awk -F\/ 'END{print $1}')
EOF
   ;;
   *)
     cat >> $Output << "EOF"
cd $(tar vxf ${srcname}*.tar.?z* | awk -F\/ 'END{print $1}')
EOF
   ;;
esac
cat >> $Output << "EOF"
curdir=$( echo $PWD ) #store the source dir for later deletion
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
sourceloc=$sourcelocOld
} # end unpack07
#
EOF
} # end unpack07
#
unpack10 () {
# used when installing the kernel
cat >> $Output << "EOF"
unpack10 () {
# $1 is the source name
# $2 is the url to download the source file
# $3, if present, is the source filename
# $4, if present, is the sourceloc of the file already downloaded
sourcelocOld=$sourceloc # sourceloc is global - store it to reset it at the end
local srcname=$1
local srcURL=$2
local srcFile=${3:-""}
local altSourceloc=${4:-""}
if [ ! -z "$altSourceloc" ]; then # set sourceloc to this location
  sourceloc=$altSourceloc
fi
echo "sourceloc is $sourceloc"
if [ -z "$srcFile" ]; then srcFile=${srcURL##*/}; fi
echo "srcFile to install is $srcFile"
starttime=$( date +%s )
EOF
#
cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${srcname}${pkgVers}.tar.?z* ]; then # the srcfile exists in current dir - use that
  echo "${srcname}${pkgVers} already in current dir - will use that one"
elif [ -e ${sourceloc}/${srcname}${pkgVers}.tar.?z* ]; then # src exists so copy it to current dir
  cp -v ${sourceloc}/${srcname}*.* . # copy any patches as well
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on the target machine
    wget $wgetopts $ncc -O $srcFile $srcURL
  else
    echo "Install wget on the target machine in order to continue"
    echo "Aborting"
    exit 1
  fi
fi
cd $(tar vxf ${srcname}*.tar.?z* | awk -F\/ 'END{print $1}')
curdir=$( echo $PWD ) #store the source dir for later deletion
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
sourceloc=$sourcelocOld
} # end unpack10
EOF
} # end uppack10
# the unpack used in chapter08 and update
unpack () {
cat >> $Output << "EOF"
unpack () {
# $1 is the source name
# $2 is the url to download the source file
# $3, if present, is the source filename
# note -  generally the input and output source filenames are the same but
# if using a source file from github then they are often different
# $4, if present, is the sourceloc of the file already downloaded
sourcelocOld=$sourceloc # sourceloc is global - store it to reset it at the end
local srcname=$1
local srcURL=$2
local srcFile=${3:-""}
local altSourceloc=${4:-""}
if [ ! -z "$altSourceloc" ]; then # set sourceloc to this location
  sourceloc=$altSourceloc
fi
echo "sourceloc is $sourceloc"
if [ -z "$srcFile" ]; then srcFile=${srcURL##*/}; fi
echo "srcFile to install is $srcFile" # is this file already in $CUR_DIR
starttime=$( date +%s )
EOF
case $SrcName in
   systemd-) # distinguish from the man-pages file
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${srcname}[0-9]*.tar.?z* ]; then # a srcfile exists in current dir - use that
  echo "$srcname already in current dir - will use that one"
elif [ -e ${sourceloc}/${srcname}[0-9]*.tar.?z* ]; then # src exists so copy it to current dir
EOF
   ;;
   tcl8.) # need to specify -src to distinguish from the html file
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${srcname}*-src.tar.?z* ]; then # a srcfile exists in current dir - use that
  echo "$srcname already in current dir - will use that one"
elif [ -e ${sourceloc}/${srcname}*-src.tar.?z* ]; then # src exists so copy it to current dir
EOF
   ;;
   *)
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${srcname}*.tar.?z* ]; then # a srcfile exists in current dir - use that
  echo "$srcname already in current dir - will use that one"
elif [ -e ${sourceloc}/${srcname}*.tar.?z* ]; then # src exists so copy it to current dir
EOF
   ;;
esac
if [[ "$Chapter" = update && "$PkgName" = "linux-headers" ]]; then # the linux src dir is open
  echo "    cp -v \${sourceloc}/\${srcname}*.tar.?z* ." >> $Output
else
  echo "    cp -v \${sourceloc}/\${srcname}*.* . # copy any patches as well" >> $Output
fi
cat >> $Output << "EOF"
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on the target machine
    wget $wgetopts $ncc -O $srcFile $srcURL
  else
    echo "Install wget on the target machine in order to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
case $SrcName in
   systemd-) # distinguish from the man-pages file
     cat >> $Output << "EOF"
cd $(tar vxf ${srcname}[0-9]*.tar.?z* | awk -F\/ 'END{print $1}')
EOF
   ;;
   tcl8.) # need to specify -src to distinguish from the html file
     cat >> $Output << "EOF"
cd $(tar vxf ${srcname}*-src.tar.?z* | awk -F\/ 'END{print $1}')
EOF
   ;;
   *)
     cat >> $Output << "EOF"
cd $(tar vxf ${srcname}*.tar.?z* | awk -F\/ 'END{print $1}')
EOF
   ;;
esac
cat >> $Output << "EOF"
curdir=$( echo $PWD ) #store the source dir for later deletion
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
sourceloc=$sourcelocOld
} # end unpack
EOF
# if need the package version for the script, print it here
case $SrcName in
   bzip2-)
     echo "bzip2Vers=$bzip2vers" >> $Output
   ;;
   gcc-)
     echo "gccVers=$gccvers" >> $Output
   ;;
esac
} # end unpack
#
TestBuiltCh56 () {
    cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}"
if [ -e ${buildDir}/${FuncName}/${testBuilt} ]; then
  echo "skipping $FuncName"
  return 0
  echo "Building $FuncName"
fi
EOF
} #end TestBuiltCh56
#
TestBuiltAny () {
# $1 is the chapter
# if present, $2 is the extension, -destdir or -install
local chapter=$1
local extension=${2:-""}
if [ "$chapter" != update ]; then
  testBuilt=".\${Chapter/apter/}\${PkgName}${extension}"
else
  testBuilt=".\${Chapter}\${PkgName}${extension}"
fi
echo "testBuilt=\"$testBuilt\"" >> $Output
cat >> $Output << "EOF"
if [ -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
  echo "skipping $PkgName"
  return 0
else
  echo "Building $PkgName"
fi
EOF
} # end TestBuiltAny
#
destdirInstall () {
cat >> $Output << "EOF"
destdirInstall () {
# install the files from a DESTDIR build
# $1 is the directory containing the files to install
local pkgfileDir=$1
local eachDir=""
set +e # don't stop at the cp -a
pushd $pkgfileDir > /dev/null
local listDIRS=$(ls -l --time-style="long-iso" . | grep '^d' | awk '{print $8}')
echo "directories are $listDIRS"
for eachDir in $listDIRS; do
# ignore the pkgbindir directory in the dir list - don't want to install the binary tarfile
  if [ "$eachDir" = pkgbindir ]; then # ignore
    continue
  elif [[ $eachDir != etc && $eachDir != lib && $eachDir != usr && $eachDir != var && $eachDir != opt && $eachDir != run && $eachDir != srv && $eachDir != sbin ]]; then
  echo "Install files from directory $eachDir? [y/N]"
    read reply
      case $reply in
         [yY]|[yY][Ee][Ss])
            echo "okay continuing"
         ;;
         *)
            echo "Okay, ignoring directory $eachDir"
            continue
         ;;
      esac
  fi
  echo "installing files in $eachDir"
# take account of symlinks /bin /lib /sbin
  if [ -L "/$eachDir" ]; then # for /bin and /lib it's /usr/$eachDir. For /sbin, /usr/sbin is also a symlink
    echo "dir $eachDir is a symlink"
    if [ "$eachDir" = sbin ]; then # use /usr/bin, not /usr/sbin
      cp -a $eachDir/* /usr/bin
    else
      cp -a $eachDir/* /usr/${eachDir}
    fi
  elif [ "$eachDir" = usr ]; then # deal with symlink usr/sbin if it exists
    pushd usr > /dev/null
    local usrDIRS=$(ls -l --time-style="long-iso" . | grep '^d' | awk '{print $8}')
    echo "directories under usr are $usrDIRS"
    for eachusrDir in $usrDIRS; do
      if [ "$eachusrDir" = sbin ]; then # deal with the /usr/sbin symlink
        cp -a $eachusrDir/* /usr/bin
      elif [ "$eachusrDir" = libexec ]; then # use /usr/lib instead of /usr/libexec
        cp -a $eachusrDir/* /usr/lib
      elif [ "$eachusrDir" = man ]; then
        cp -a $eachusrDir/* /usr/share/man
      elif [ "$eachusrDir" = usr ]; then
        cp -a $eachusrDir/share/man/* /usr/share/man
      else
        cp -a $eachusrDir /usr
      fi
    done
    popd > /dev/null
  elif [ "$eachDir" = var ]; then # deal with symlink /var/run if it exists
    pushd var > /dev/null
    local varDIRS=$(ls -l --time-style="long-iso" . | grep '^d' | awk '{print $8}')
    echo "directories under var are $varDIRS"
    for eachvarDir in $varDIRS; do
      if [ "$eachvarDir" = run ]; then # deal with the /var/run symlink
        cp -a $eachvarDir/* /run
      else
        cp -a $eachvarDir /var
      fi
    done
    popd > /dev/null
  else
    cp -a $eachDir /
  fi
  echo "Delete dir $eachDir? [Y/n]"
  read reply
    case $reply in
         [yY]|[yY][Ee][Ss])
            echo "okay deleting $eachDir"
            rm -rf $eachDir
         ;;
         [nN]|[nN][Oo])
            echo "okay leaving $eachDir in place"
         ;;
         *)
            echo "okay deleting $eachDir"
            rm -rf $eachDir
         ;;
    esac
done
popd > /dev/null
set -e
} # end destdirInstall
#
EOF
} # end destdirInstall
#
WriteScript () {
case $PkgName in
    acl)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/make install install-dev/make DIST_ROOT="$CUR_DIR" install install-dev/' \
                 -e 's/chmod -v 755 \/usr\/lib\/libacl.so/chmod -v 755 ${CUR_DIR}\/usr\/lib\/libacl.so/' \
                 -e '/mv -v/,/ln -sfv/d' \
           >> $Output
        else
          GetCommands \
           | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
                 -e '/prefix=\/usr/a\              --libdir=\/usr\/lib \\' \
                 -e '/mv -v/,/ln -sfv/d' \
           >> $Output
        fi
    ;;
    attr)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/make install install-dev/make DIST_ROOT="$CUR_DIR" install install-dev/' \
                 -e '/chmod -v 755 \/usr\/lib\/libattr.so/i rm -f ${CUR_DIR}\/usr\/lib\/libattr.a' \
                 -e 's/chmod -v 755 \/usr\/lib\/libattr.so/chmod -v 755 ${CUR_DIR}\/usr\/lib\/libattr.so/' \
                 -e '/mv -v/,/ln -sfv/d' \
           >> $Output 
        else
          if [ "$SYSTEMD" = yes -a "$isSystemdBook" = false ]; then
            GetCommands \
             | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
                   -e '/prefix=\/usr/a\              --libdir=\/usr\/lib \\' \
                   -e '/mv -v/,/ln -sfv/d' \
             >> $Output
          else # book is systemd
            GetCommands \
             | sed -e 's/disable-static/disable-static --bindir=\/usr\/bin --libdir=\/usr\/lib/' \
                   -e '/mv -v/,/ln -sfv/d' \
             >> $Output
          fi
        fi
    ;;
    bash)
        if [ "$currentChapter" = chapter06 ]; then
	  GetCommands \
	   | sed -e '/mv $LFS\/usr\/bin\/bash/d' \
	         -e 's/bin\/sh/usr\/bin\/sh/' \
	   >> $Output
	else # chapter08
          if [ "$SYSTEMD" = yes ]; then 
            if $useDESTDIR; then 
              GetCommands \
              | sed -e '/docdir=\/usr\/share\/doc/i\              --bindir=\/usr\/bin            \\' \
                    -e '/chown -Rv tester/,/exit/d' \
                    -e '/EOF/d' \
                    -e '/exec \/usr\/bin\/bash/i ln -s bash ${CUR_DIR}\/usr\/bin\/sh' \
                    -e '/exec \/usr\/bin\/bash --login/d' \
              >> $Output
            else
              GetCommands \
              | sed -e '/docdir=\/usr\/share\/doc/i\              --bindir=\/usr\/bin            \\' \
                    -e '/chown -Rv tester/,/exit/d' \
                    -e '/EOF/d' \
                    -e '/exec \/usr\/bin\/bash/i rm -rf \/usr\/bin\/sh\n\ln -s bash \/usr\/bin\/sh' \
                    -e '/exec \/usr\/bin\/bash --login/d' \
              >> $Output
            fi
          else
            GetCommands \
            | sed -e '/chown -Rv tester/,/exit/d' \
                  -e '/EOF/d' \
            >> $Output
          fi
	fi
    ;;
    bc)
       GetCommands \
        | sed -e '/echo "quit"/d' \
        >> $Output
    ;;
    binutils)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/expect -c/d' \
                 -e '/find -name/d' \
                 -e 's/make tooldir=\/usr install/make prefix="${CUR_DIR}"\/usr tooldir="${CUR_DIR}"\/usr install/' \
                 -e '/rm -fv \/usr\/lib/i\install -m644 libiberty\/pic\/libiberty.a "${CUR_DIR}\/usr\/lib"' \
                 -e '/rm -fv \/usr\/lib/i\rm -fv "${CUR_DIR}"\/usr\/share\/man\/man1\/{dlltool,windres,windmc}*' \
                 -e 's/rm -fv \/usr\/lib\/lib{bfd/rm -fv ${CUR_DIR}\/usr\/lib\/lib{bfd/' \
           | awk '{
if ($1 == "mkdir" && $2 =="-v")
  print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
  print $0;
}' \
           >> $Output
        else
          GetCommands \
           | sed -e '/expect -c/d' \
                 -e '/find -name/d' \
           | awk '{
if ($1 == "mkdir" && $2 =="-v")
  print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
  print $0;
}' \
           >> $Output
        fi
    ;;
    bzip2)
        if [ "$Chapter" != update ]; then # ch08
          if $useDESTDIR; then
            GetInternalCommands bzip2DestdirComms >> $Output
          else
            GetCommands \
             | sed -e '/make PREFIX=\/usr/i\  make bzip2 bzip2recover' \
                   -e 's/cp -v bzip2-shared \/bin\/bzip2/cp -v bzip2-shared \/usr\/bin\/bzip2/' \
                   -e 's/cp -av libbz2.so\* \/lib/cp -av libbz2.so\* \/usr\/lib/' \
                   -e '/ln -sv ..\/..\/lib/d' \
                   -e '/rm -v/i ln -sv libbz2.so.1.0 /usr/lib/libbz2.so' \
                   -e 's/bunzip2,bzcat,bzip2/bunzip2,bzcat/' \
                   -e 's/\/bin\/bunzip2/\/usr\/bin\/bunzip2/' \
                   -e 's/\/bin\/bzcat/\/usr\/bin\/bzcat/' \
             >> $Output
          fi
        else # update
          if $useDESTDIR; then
            GetInternalCommands bzip2DestdirComms >> $Output
          else
            GetCommands \
             | sed -e "/patch/i sed -e 's\/^CFLAGS=\\\(.\*\\\)\$\/CFLAGS=\\\1 \\\\\$(BIGFILES)\/' -i ./Makefile-libbz2_so" \
                   -e '/make PREFIX=\/usr/i\  make bzip2 bzip2recover' \
                   -e '/ln -sv libbz2.so/i rm -v \/usr\/lib\/libbz2.so' \
                   -e '/ln -sfv bzip2/i\  rm -v \$i' \
             >> $Output
          fi
        fi
    ;;
    changingowner)
        if $as_root; then # use the -R recursive for all dirs
          GetCommands \
           | sed -e 's/sbin,tools/sbin,sources,tools/' \
           >> $Output
        else # pkguser so leave the dirs as they are
          GetCommands \
           | sed -e '/^chown -R root:root/i# installing as a pkguser\n# top level directories left alone' \
                 -e '/chown -R root:root/,/esac/d' \
           >> $Output
        fi
    ;;
    check)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/ install/ DESTDIR="$CUR_DIR" install/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    cleanup) # chapter07
        if [ "$currentChapter" = chapter07 ]; then
          GetCommands \
           | sed -e '/rm -rf \/tools/,/tar -cJpf/d' \
                 -e 's/\(.*\)&&$/\1/' \
           >> $Output
        elif [ "$currentChapter" = chapter08 ]; then
          GetCommands \
           | sed -e '/rm -rf \/tmp\/\*/a echo "copy'\''n'\''paste the following:\n' \
                 -e "/find \/usr\/lib \/usr\/libexec/i logout\n\"\necho \"chroot \\\\\"\\\\\$LFS\\\\\" \/usr\/bin\/env -i          \\\\\\\\\"\necho \"    HOME=\/root TERM=\\\\\"\\\\\$TERM\\\\\"            \\\\\\\\\"\necho \"    PS1='(lfs chroot) \\\u:\\\w\\\\\\\\$ '        \\\\\\\\\"\necho \"    PATH=\/usr\/bin:\/usr\/sbin            \\\\\\\\\"\necho \"    \/bin\/bash --login\"\n" \
                 -e '/find \/usr -depth/aecho "*** do not delete the \/tools dir, needed for chapter10 ***"' \
                 -e '/rm -rf \/tools/d' \
                 -e 's/^/echo "/' \
                 -e 's/\$/\\$/g' \
                 -e 's/\\$/\\\\/' \
                 -e 's/$/"/' \
           >> $Output
          cat >> $Output << "EOF"
echo "
#
# Install chapter 9 and then su kernel to install the kernel.
# Don't forget:
# 1. set a root password
# 2. check for broken symlinks with: find /usr/lib -xtype l
EOF
echo "#\"" >> $Output
        fi
    ;;
    coreutils)
	if [ "$currentChapter" = chapter06 ]; then
	  GetCommands \
	   | sed -e '/mv -v $LFS\/usr\/bin\/chroot/d' \
	   >> $Output
	else # chapter08
          if $useDESTDIR; then
            if [ "$SYSTEMD" = yes ]; then
              GetCommands \
               | sed -e 's/uptime/uptime \\\n\              --libexecdir=\/usr\/lib/' \
                     -e "/make NON_ROOT_USERNAME=nobody/,/sed -i '\/dummy\/d' \/etc\/group/d" \
                     -e '/mv -v \/usr\/bin\/chroot \/usr\/sbin/d' \
                     -e '/mv -v \/usr\/bin\/{head/d' \
                     -e '/chroot.1/i mkdir -pv ${CUR_DIR}\/usr\/share\/man\/man8' \
                     -e 's/\/usr\/share\/man/${CUR_DIR}\/usr\/share\/man/g' \
               >> $Output
            else
              GetCommands \
               | sed -e "/make NON_ROOT_USERNAME=nobody/,/sed -i '\/dummy\/d' \/etc\/group/d" \
                     -e '/mv -v \/usr\/bin\/chroot \/usr\/sbin/d' \
                     -e 's/\/usr\/bin\//${CUR_DIR}\/usr\/bin\//g' \
                     -e '/chroot.1/i mkdir -pv ${CUR_DIR}\/usr\/share\/man\/man8' \
                     -e 's/\/usr\/share\/man/${CUR_DIR}\/usr\/share\/man/g' \
               >> $Output
            fi
          else # not useDESTDIR
            if [ "$SYSTEMD" = yes ]; then
              GetCommands \
               | sed -e 's/uptime/uptime \\\n\              --libexecdir=\/usr\/lib/' \
                     -e "/make NON_ROOT_USERNAME=nobody/,/sed -i '\/dummy\/d' \/etc\/group/d" \
                     -e '/mv -v \/usr\/bin\/chroot \/usr\/sbin/d' \
               >> $Output
            else
              GetCommands \
               | sed -e "/make NON_ROOT_USERNAME=nobody/,/sed -i '\/dummy\/d' \/etc\/group/d" \
                     -e '/mv -v \/usr\/bin\/chroot \/usr\/sbin/d' \
               >> $Output
            fi
          fi
	fi
    ;;
    createfiles)
        if ! $as_root; then
          if $useDESTDIR; then
            GetCommands \
             | sed -e '/ln -sv \/proc/i mkdir -pv \/${PkgUserDir}\/${PkgName}\/{etc,var\/log}' \
                   -e '/mounts \/etc\/mtab/iif [ ! -L \/${PkgUserDir}\/${PkgName}\/etc\/mtab ]; then' \
                   -e '/mounts \/etc\/mtab/afi' \
                   -e 's/mounts \/etc\/mtab/mounts \/${PkgUserDir}\/${PkgName}\/etc\/mtab/' \
                   -e 's/\/etc\/hosts/\/${PkgUserDir}\/${PkgName}\/etc\/hosts/' \
                   -e 's/\/etc\/passwd/\/${PkgUserDir}\/${PkgName}\/etc\/passwd/' \
                   -e '/nobody/ibinutils:x:10000:10000::/mnt/lfs/usr/src/core/binutils:/bin/bash\ngcc:x:10001:10001::/mnt/lfs/usr/src/core/gcc:/bin/bash\nlinux-headers:x:10002:10002::/mnt/lfs/usr/src/core/linux-headers:/bin/bash\nglibc:x:10003:10003::/mnt/lfs/usr/src/core/glibc:/bin/bash\nm4:x:10004:10004::/mnt/lfs/usr/src/core/m4:/bin/bash\nncurses:x:10005:10005::/mnt/lfs/usr/src/core/ncurses:/bin/bash\nbash:x:10006:10006::/mnt/lfs/usr/src/core/bash:/bin/bash\ncoreutils:x:10007:10007::/mnt/lfs/usr/src/core/coreutils:/bin/bash\ndiffutils:x:10008:10008::/mnt/lfs/usr/src/core/diffutils:/bin/bash\nfile:x:10009:10009::/mnt/lfs/usr/src/core/file:/bin/bash\nfindutils:x:10010:10010::/mnt/lfs/usr/src/core/findutils:/bin/bash\ngawk:x:10011:10011::/mnt/lfs/usr/src/core/gawk:/bin/bash\ngrep:x:10012:10012::/mnt/lfs/usr/src/core/grep:/bin/bash\ngzip:x:10013:10013::/mnt/lfs/usr/src/core/gzip:/bin/bash\nmake:x:10014:10014::/mnt/lfs/usr/src/core/make:/bin/bash\npatch:x:10015:10015::/mnt/lfs/usr/src/core/patch:/bin/bash\nsed:x:10016:10016::/mnt/lfs/usr/src/core/sed:/bin/bash\ntar:x:10017:10017::/mnt/lfs/usr/src/core/tar:/bin/bash\nxz:x:10018:10018::/mnt/lfs/usr/src/core/xz:/bin/bash' \
                   -e 's/\/etc\/group/\/${PkgUserDir}\/${PkgName}\/etc\/group/' \
                   -e '/nogroup/iinstall:x:9999:binutils,gcc,linux-headers,glibc,m4,ncurses,bash,coreutils,diffutils,file,findutils,gawk,grep,gzip,make,patch,sed,tar,xz\nbinutils:x:10000:\ngcc:x:10001:\nlinux-headers:x:10002:\nglibc:x:10003:\nm4:x:10004:\nncurses:x:10005:\nbash:x:10006:\ncoreutils:x:10007:\ndiffutils:x:10008:\nfile:x:10009:\nfindutils:x:10010:\ngawk:x:10011:\ngrep:x:10012:\ngzip:x:10013:\nmake:x:10014:\npatch:x:10015:\nsed:x:10016:\ntar:x:10017:\nxz:x:10018:' \
                   -e '/wheel/d' \
                   -e 's/nobody:x:99:99/nobody:x:65534:65534/' \
                   -e 's/nogroup:x:99/nogroup:x:65534/' \
                   -e '/tester/d' \
                   -e '/exec \/usr\/bin\/bash --login/d' \
                   -e "/600  \/var\/log\/btmp/ased -i 's/\\\/mnt\\\/lfs//' \${PkgUserDir}/\${PkgName}/etc/passwd\ncreateDirsFilesPkgfile \$PkgUserDir \$PkgName \"createfiles\"" \
                   -e 's/touch \/var/touch \/${PkgUserDir}\/${PkgName}\/var/' \
                   -e 's/utmp \/var\/log\/lastlog/utmp \/${PkgUserDir}\/${PkgName}\/var\/log\/{btmp,lastlog,wtmp}/' \
                   -e 's/664  \/var\/log\/lastlog/664 \/${PkgUserDir}\/${PkgName}\/var\/log\/{lastlog,wtmp}/' \
                   -e 's/600  \/var\/log\/btmp/660  \/${PkgUserDir}\/${PkgName}\/var\/log\/btmp/' \
             >> $Output
          else
            GetCommands \
             | sed -e '/mounts \/etc\/mtab/iif [ ! -L \/etc\/mtab ]; then' \
                   -e '/mounts \/etc\/mtab/afi' \
                   -e '/nobody/ibinutils:x:10000:10000::/mnt/lfs/usr/src/core/binutils:/bin/bash\ngcc:x:10001:10001::/mnt/lfs/usr/src/core/gcc:/bin/bash\nlinux-headers:x:10002:10002::/mnt/lfs/usr/src/core/linux-headers:/bin/bash\nglibc:x:10003:10003::/mnt/lfs/usr/src/core/glibc:/bin/bash\nm4:x:10004:10004::/mnt/lfs/usr/src/core/m4:/bin/bash\nncurses:x:10005:10005::/mnt/lfs/usr/src/core/ncurses:/bin/bash\nbash:x:10006:10006::/mnt/lfs/usr/src/core/bash:/bin/bash\ncoreutils:x:10007:10007::/mnt/lfs/usr/src/core/coreutils:/bin/bash\ndiffutils:x:10008:10008::/mnt/lfs/usr/src/core/diffutils:/bin/bash\nfile:x:10009:10009::/mnt/lfs/usr/src/core/file:/bin/bash\nfindutils:x:10010:10010::/mnt/lfs/usr/src/core/findutils:/bin/bash\ngawk:x:10011:10011::/mnt/lfs/usr/src/core/gawk:/bin/bash\ngrep:x:10012:10012::/mnt/lfs/usr/src/core/grep:/bin/bash\ngzip:x:10013:10013::/mnt/lfs/usr/src/core/gzip:/bin/bash\nmake:x:10014:10014::/mnt/lfs/usr/src/core/make:/bin/bash\npatch:x:10015:10015::/mnt/lfs/usr/src/core/patch:/bin/bash\nsed:x:10016:10016::/mnt/lfs/usr/src/core/sed:/bin/bash\ntar:x:10017:10017::/mnt/lfs/usr/src/core/tar:/bin/bash\nxz:x:10018:10018::/mnt/lfs/usr/src/core/xz:/bin/bash' \
                   -e '/nogroup/iinstall:x:9999:binutils,gcc,linux-headers,glibc,m4,ncurses,bash,coreutils,diffutils,file,findutils,gawk,grep,gzip,make,patch,sed,tar,xz\nbinutils:x:10000:\ngcc:x:10001:\nlinux-headers:x:10002:\nglibc:x:10003:\nm4:x:10004:\nncurses:x:10005:\nbash:x:10006:\ncoreutils:x:10007:\ndiffutils:x:10008:\nfile:x:10009:\nfindutils:x:10010:\ngawk:x:10011:\ngrep:x:10012:\ngzip:x:10013:\nmake:x:10014:\npatch:x:10015:\nsed:x:10016:\ntar:x:10017:\nxz:x:10018:' \
                   -e '/wheel/d' \
                   -e 's/nobody:x:99:99/nobody:x:65534:65534/' \
                   -e 's/nogroup:x:99/nogroup:x:65534/' \
                   -e '/tester/d' \
                   -e '/exec \/usr\/bin\/bash --login/d' \
                   -e "/600  \/var\/log\/btmp/ased -i 's/\\\/mnt\\\/lfs//' /etc/passwd" \
             >> $Output
          fi
        else # as root 
          GetCommands \
           | sed -e '/mounts \/etc\/mtab/iif [ ! -L \/etc\/mtab ]; then' \
                 -e '/mounts \/etc\/mtab/afi' \
                 -e '/exec \/usr\/bin\/bash --login/d' \
           >> $Output
        fi
    ;;
    creatingdirs)
        if [ "$SYSTEMD" = yes ]; then # symlink /bin, /lib and /sbin to /usr
          if $useDESTDIR; then
            GetCommands \
             | sed -e '/mkdir -pv \/{boot/i mkdir -pv ${PkgUserDir}/${PkgName}' \
                   -e 's#mkdir -pv /#mkdir -pv ${PkgUserDir}/${PkgName}/#' \
                   -e 's/bin,lib,sbin/bin,lib/' \
                   -e 's/cache,local,log/cache,local\/{,la-files},log/' \
                   -e 's#ln -sfv /run /var/run#ln -sfv /run ${PkgUserDir}/${PkgName}/var/run#' \
                   -e 's#ln -sfv /run/lock /var/lock#ln -sfv /run/lock ${PkgUserDir}/${PkgName}/var/lock#' \
                   -e 's#/root#${PkgUserDir}/${PkgName}/root#' \
                   -e 's#/tmp /var/tmp#${PkgUserDir}/${PkgName}/tmp ${PkgUserDir}/${PkgName}/var/tmp#' \
                   -e '/install -dv -m 1777/a createDirsFilesPkgfile \$PkgUserDir \$PkgName "creatingdirs"' \
             >> $Output
          else
            GetCommands \
             | sed -e 's/pv \/lib\/firmware/pv \/usr\/lib\/firmware/' \
                   -e 's/cache,local,log/cache,local\/{,la-files},log/' \
             >> $Output
          fi
        else
          GetCommands \
           | sed -e 's/cache,local,log/cache,local\/{,la-files},log/' \
           >> $Output
        fi
    ;;
    dbus)
        if $useDESTDIR; then
          GetInternalCommands dbusComms \
           | sed -e 's/\/var\/lib\/dbus/${CUR_DIR}\/var\/lib\/dbus/' \
           >> $Output
        else
          GetInternalCommands dbusComms >> $Output
        fi
    ;;
    e2fsprogs)
        if $useDESTDIR; then
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/mkdir -v build/mkdir -v e2fsprogs-build/' \
                   -e 's/cd       build/cd e2fsprogs-build/' \
                   -e '/configure --prefix=\/usr/a\              --sysconfdir=/etc \\' \
                   -e '/enable-elf-shlibs/i\               --libdir=\/usr\/lib       \\\n\               --sbindir=\/usr\/bin      \\' \
                   -e 's/rm -fv \/usr\/lib\/{libcom_err/rm -fv "${CUR_DIR}"\/usr\/lib\/{libcom_err/' \
                   -e 's/\/usr\/share\/info/${CUR_DIR}\/usr\/share\/info/g' \
                   -e '/makeinfo -o      doc/,/install-info --dir-file=\/usr/d' \
             >> $Output
          else
            GetCommands \
             | sed -e 's/mkdir -v build/mkdir -v e2fsprogs-build/' \
                   -e 's/cd       build/cd e2fsprogs-build/' \
                   -e 's/rm -fv \/usr\/lib\/{libcom_err/rm -fv "${CUR_DIR}"\/usr\/lib\/{libcom_err/' \
                   -e 's/\/usr\/share\/info/${CUR_DIR}\/usr\/share\/info/' \
                   -e '/makeinfo -o      doc/,/install-info --dir-file=\/usr/d' \
             >> $Output
           fi
        else
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/mkdir -v build/mkdir -v e2fsprogs-build/' \
                   -e 's/cd       build/cd e2fsprogs-build/' \
                   -e '/configure --prefix=\/usr/a\               --sysconfdir=/etc        \\' \
                   -e '/enable-elf-shlibs/i\               --libdir=\/usr\/lib       \\\n\               --sbindir=\/usr\/bin      \\' \
             >> $Output
          else
            GetCommands \
             | sed -e 's/mkdir -v build/mkdir -v e2fsprogs-build/' \
                   -e 's/cd       build/cd e2fsprogs-build/' \
             >> $Output
           fi
        fi
    ;;
    eudev)
        GetCommands \
         | sed -e '/make LD_LIBRARY_PATH=\/tools\/lib check/d' \
         >> $Output
    ;;
    expect)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/\.so \/usr\/lib/\.so "${CUR_DIR}"\/usr\/lib/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    file) # in chapter06 and 08 don't need to mv libmagic
        GetCommands \
         | sed -e '/libmagic.so/d' \
         >> $Output
    ;;
    findutils)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/locate/locate --libexecdir=\/usr\/lib\/findutils/' \
                 -e '/mv -v/,/sed -i/d' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    flex)
        if [ "$Chapter" = update ]; then # don't re-create /usr/bin/lex
          if $useDESTDIR; then
            GetCommands \
             | sed -e 's/ln -sv flex \/usr/ln -sv flex ${CUR_DIR}\/usr/' \
             >> $Output
          else
            GetCommands \
             | sed -e '/ln -sv flex/d' \
             >> $Output
          fi
        else # ch08
          if $useDESTDIR; then
            GetCommands \
             | sed -e 's/ln -sv flex \/usr/ln -sv flex ${CUR_DIR}\/usr/' \
             >> $Output
          else
            GetCommands >> $Output
          fi
        fi
    ;;
    gawk)
	if [ "$currentChapter" = chapter08 ]; then
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/prefix=\/usr/prefix=\/usr \\\n\              --libexecdir=\/usr\/lib \\\n\              --sysconfdir=\/etc \\\n\              --localstatedir=\/var/' \
             >> $Output
          else
            GetCommands >> $Output
          fi
	else
	  GetCommands >> $Output
	fi
    ;;
    gcc)
	if [ "FuncName" = libstdc++ ]; then
          GetCommands \
           | awk '{
if ($1 == "mkdir" && $2 =="-v")
  print "if [ ! -e "$NF" ]; then\n  "$0"\nfi\n";
else
  print $0;
}' \
           >> $Output
	else # gcc not libstdc++
          if [ "$Chapter" != update ]; then
            if [ "$SYSTEMD" = yes ]; then
              if $useDESTDIR; then
                GetCommands \
                 | sed -e 's/with-system-zlib/with-system-zlib       \\\n\              --libdir=\/usr\/lib \\\n\              --libexecdir=\/usr\/lib/' \
                       -e '/chown -v -R root:root/,/include{,-fixed}/d' \
                       -e '/cpp \/usr\/lib/a mkdir -pv "${CUR_DIR}"\/usr\/lib\/bfd-plugins' \
		       -e 's#cpp /usr/lib#cpp "${CUR_DIR}"/usr/lib#' \
                       -e 's#/usr/lib/bfd-plugins/#"${CUR_DIR}"/usr/lib/bfd-plugins/#' \
                       -e "/echo 'int main(){}' > dummy.c/,/rm -v dummy.c a.out dummy.log/d" \
                       -e 's/..\/..\/libexec/../' \
                       -e 's#/usr/share/gdb/auto-load/usr/lib#"${CUR_DIR}"/usr/share/gdb/auto-load/usr/lib#' \
                       -e 's#mv -v /usr/lib#mv -v "${CUR_DIR}"/usr/lib#' \
                 | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0;
}' \
                >> $Output
              else # not DESTDIR
                if [ "$currentChapter" = chapter05 ]; then 
                  GetCommands \
                   | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0;
}' \
                   >> $Output
                else # chapter 6 and 8
                  GetCommands \
                   | sed -e 's/--prefix=\/usr/--prefix=\/usr \\\n\               --libdir=\/usr\/lib \\\n\               --libexecdir=\/usr\/lib/' \
                         -e '/chown -v -R root:root/,/\/usr\/lib\/gcc\/\$(gcc/d' \
                         -e 's|/../libexec||' \
                   | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0;
}' \
                   >> $Output
                fi # test Chapter = update
              fi # test useDESTDIR
            else # SYSTEMD is no
              GetCommands \
               | sed -e "/ln -sv gcc/ a set +e" \
               | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0;
}' \
               >> $Output
            fi
          else # Chapter is update
            if $useDESTDIR; then
              GetInternalCommands gccDestdirComms >> $Output
            else
              GetInternalCommands gccComms >> $Output
            fi
          fi
	fi # end test of gcc or libstdc
        echo "set -e" >> $Output
    ;;
    gettext)
        if [ "$currentChapter" = chapter07 ]; then
          if $useDESTDIR; then
            GetCommands \
             | sed -e '/cp -v gettext-tools/i\  install -v -m0755 -d "${CUR_DIR}"/usr/bin' \
                   -e 's/xgettext} \/usr\/bin/xgettext} "${CUR_DIR}"\/usr\/bin/' \
             >> $Output
          else
            GetCommands >> $Output
          fi
        else # chapter08
          if $useDESTDIR; then
            GetCommands \
             | sed -e 's/chmod -v 0755 \/usr\/lib\/preloadable/chmod -v 0755 "${CUR_DIR}"\/usr\/lib\/preloadable/' \
             >> $Output
          else
            GetCommands >> $Output
          fi
        fi
    ;;
    glibc)
        if [ "$Chapter" != update ]; then
          if [ "$currentChapter" = chapter08 ]; then
# set up glibc's timezone
# test if the build dir exists
# if SYSTEMD=yes, but the book is not systemd, then need to add the nscd systemd files
            if [ "$SYSTEMD" = yes -a "$isSystemdBook" = false ]; then
              GetCommands \
               | sed -e 's/prefix=\/usr/prefix=\/usr --libexecdir=\/usr\/lib/' \
                     -e '/mkdir -pv \/usr\/lib\/locale/i install -v -Dm644 ..\/nscd\/nscd.tmpfiles \/usr\/lib\/tmpfiles.d\/nscd.conf\ninstall -v -Dm644 ..\/nscd\/nscd.service \/usr\/lib\/systemd\/system\/nscd.service' \
                     -e '/tzselect/d' \
                     -e 's/zic/\/usr\/sbin\/zic/' \
                     -e 's[\*\*EDITME<xxx>EDITME\*\*['$TZ'[' \
               | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0
}' \
               | awk '{if ($1 == "mkdir" && $NF =="/etc/ld.so.conf.d")
print "if [ ! -e "$NF" ]; then\n  "$1" -v "$NF"\nfi";
else
print $0
}' \
               >> $Output
            else
              GetCommands \
               | sed -e 's/prefix=\/usr/prefix=\/usr --libexecdir=\/usr\/lib/' \
	             -e 's/libc_cv_slibdir=\/lib/libc_cv_slibdir=\/usr\/lib/' \
		     -e 's/ld-linux.so.2        \/lib/ld-linux.so.2        \/usr\/lib/' \
		     -e 's/ld-linux-x86-64.so.2 \/lib/ld-linux-x86-64.so.2 \/usr\/lib/' \
		     -e 's/service \/lib\/systemd\/system/service \/usr\/lib\/systemd\/system/' \
                     -e '/tzselect/d' \
                     -e 's/zic/\/usr\/sbin\/zic/' \
                     -e 's[\*\*EDITME<xxx>EDITME\*\*['$TZ'[' \
               | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0
}' \
               | awk '{if ($1 == "mkdir" && $NF =="/etc/ld.so.conf.d")
print "if [ ! -e "$NF" ]; then\n  "$1" -v "$NF"\nfi";
else
print $0
}' \
               >> $Output
            fi
          else # chapter05
	    if ! $as_root; then
              GetCommands \
	       | sed -e '/install-tools\/mkheaders/d' \
               | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0
}' \
               >> $Output
            else
              GetCommands \
               | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0
}' \
               >> $Output
            fi
          fi
        else # update so modify some of the commands
          if $useDESTDIR; then
            GetCommands \
             | sed -e '/configure_commands()/i echo "slibdir=\/usr\/lib" >> configparms\necho "rtlddir=\/usr\/lib" >> configparms\necho "sbindir=\/usr\/bin" >> configparms\necho "rootsbindir=\/usr\/bin" >> configparms' \
                   -e '/--disable-werror/i\               --libdir=\/usr\/lib --libexecdir=\/usr\/lib                \\' \
                   -e '/touch \/etc\/ld.so.conf/i\  install -dm755 ${CUR_DIR}/etc' \
                   -e 's/touch \/etc\/ld.so.conf/touch ${CUR_DIR}\/etc\/ld.so.conf/' \
                   -e 's/\/etc\/nscd.conf/${CUR_DIR}\/etc\/nscd.conf/' \
                   -e 's/\/var\/cache\/nscd/${CUR_DIR}\/var\/cache\/nscd/' \
                   -e'/\/usr\/lib\/tmpfiles.d/i install -dm755 ${CUR_DIR}\/usr\/lib\/{locale,systemd\/system,tmpfiles.d}' \
                   -e 's/\/usr\/lib\/tmpfiles.d\/nscd.conf/${CUR_DIR}\/usr\/lib\/tmpfiles.d\/nscd.conf/' \
                   -e 's/\/usr\/lib\/systemd\/system\/nscd.service/${CUR_DIR}\/usr\/lib\/systemd\/system\/nscd.service/' \
                   -e '/mkdir -pv \/usr\/lib\/locale/,/make localedata\/install-locales/d' \
                   -e '/localedef -i POSIX /,/localedef -i ja_JP /d' \
                   -e 's/cat > \/etc\/nsswitch.conf/cat > ${CUR_DIR}\/etc\/nsswitch.conf/' \
                   -e 's/$ZONEINFO/${CUR_DIR}$ZONEINFO/' \
                   -e 's[\*\*EDITME<xxx>EDITME\*\*['$TZ'[' \
                   -e 's/\/etc\/localtime/${CUR_DIR}\/etc\/localtime/' \
                   -e 's/cat > \/etc\/ld.so.conf/cat > ${CUR_DIR}\/etc\/ld.so.conf/' \
                   -e 's/cat >> \/etc\/ld.so.conf/cat >> ${CUR_DIR}\/etc\/ld.so.conf/' \
                   -e 's/mkdir -pv \/etc\/ld.so.conf.d/mkdir -pv ${CUR_DIR}\/etc\/ld.so.conf.d/' \
                   -e '/tzselect/d' \
             | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0
}' \
             >> $Output
          else # not DESTDIR
            GetCommands \
             | sed -e '/--disable-werror/i\               --libexecdir=\/usr\/lib                   \\' \
	           -e '/touch \/etc\/ld.so.conf/d' \
                   -e '/mkdir -pv \/usr\/lib\/locale/,/End \/etc\/nsswitch.conf/d' \
                   -e '/EOF/d' \
                   -e '/tzselect/,/mkdir -pv \/etc\/ld.so.conf.d/d' \
             | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0
}' \
             >> $Output
           fi 
        fi
    ;;
    gmp)
        # if building for 64bit need to remove config for 32
        # remove cp commands for less capable CPU than the host
        GetCommands \
         | sed -e '/ABI=32/d' \
               -e '/cp -v configfsf/d' \
         >> $Output
    ;;
    grep)
        if [ "$SYSTEMD" = yes ]; then
           GetCommands \
            | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
            >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    groff)
        if [ "$Chapter" = update ]; then
          GetCommands \
           | sed -e 's/\*\*EDITME<paper_size>EDITME\*\*/'$PAPER_SIZE'/' \
                 -e 's/prefix=\/usr/prefix=\/usr \\\n              --sysconfdir=\/etc \\\n              --with-appresdir=\/etc\/X11\/app-defaults/' \
                 -e '/End of editable block/d' \
                 -e '/ln -sv/d' \
           >> $Output
        else
          GetCommands \
           | sed -e 's/\*\*EDITME<paper_size>EDITME\*\*/'$PAPER_SIZE'/' \
                 -e '/End of editable block/d' \
           >> $Output
        fi
    ;;
    grub)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/mv -v \/etc/i mkdir -p "${CUR_DIR}"\/usr\/share\/bash-completion\/completions' \
                 -e 's#/etc/bash_completion#../etc/bash_completion#' \
                 -e 's/grub \/usr\/share/grub "${CUR_DIR}"\/usr\/share/' \
           >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    gzip)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
                 -e '/mv -v/d' \
           >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    iana-etc)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/cp services/i\  install -dm0755 "${CUR_DIR}"\/etc' \
                 -e 's/protocols \/etc/protocols "${CUR_DIR}"\/etc/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    inetutils)
        if [ "$SYSTEMD" = yes ]; then
          if [ "$Chapter" != update -o $useDESTDIR ]; then
            GetCommands \
             | sed -e '/disable-logger/i\              --libexecdir=/usr/lib  \\' \
                   -e '/mv -v/d' \
             >> $Output
          else
            GetCommands \
             | sed -e '/disable-logger/i\              --libexecdir=/usr/lib  \\' \
                   -e 's/disable-servers/disable-servers \\\n              --disable-hostname \\\n              --disable-ifconfig/' \
                   -e '/mv -v/d' \
             >> $Output
          fi
        else
          GetCommands  >> $Output
        fi
    ;;
    iproute2) # installed using destdir
        GetCommands \
         | sed -e 's/make SBINDIR=\/usr\/sbin/make DESTDIR="$CUR_DIR" SBINDIR=\/usr\/bin/' \
         >> $Output
    ;;
    jinja2)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/pip3 install/i\  PYTHONPATH=src python3 -m installer --destdir=\"\$CUR_DIR\" dist/*.whl' \
                 -e '/pip3 install/d' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    kbd)
          GetCommands \
           | sed -e "/make install/i\  sed -i '0,/install -d -m 755 \\\$(DESTDIR)\\\$(datadir)/ s///' data/Makefile" \
           >> $Output
    ;;
    kernel)
        if $make_kernel; then
          if $useDESTDIR; then
              GetCommands \
               | sed -e '/make mrproper/,/make menuconfig/d' \
                     -e 's/make modules_install/make INSTALL_MOD_PATH="${CUR_DIR}\/usr" INSTALL_MOD_STRIP=1 \\\n\   DEPMOD=\/doesnt\/exist modules_install/' \
                     -e '/mount \/boot/,/cp -iv \.config/d' \
                     -e 's/install -v -m755 -d \/etc/install -v -m755 -d ${CUR_DIR}\/etc/' \
                     -e 's/cat > \/etc/cat > ${CUR_DIR}\/etc/' \
               >> $Output
          else # not DESTDIR
            GetCommands \
             | sed -e '/make mrproper/,/make menuconfig/d' \
                   -e '/mount \/boot/,/cp -iv \.config/d' \
             >> $Output
          fi  # test useDESTDIR
	else # MAKE_KERNEL is no so just do make mrproper
	  GetCommands >> $Output
        fi
    ;;
    kernfs) # change permissions on /dev/shm
        GetCommands \
         | sed -e '/fi/i\  chmod 1777 $LFS\/dev\/shm/' \
         >> $Output
    ;;
    kmod)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/for target in depmod/,/ln -sfv kmod/d' \
                 -e '/make install/a\  install -dm755 ${CUR_DIR}\/{etc,usr\/lib}\/{depmod,modprobe}.d\n\  for tool in {ins,ls,rm,dep}mod mod{probe,info}; do\n\   ln -sfv kmod ${CUR_DIR}\/usr\/bin\/${tool}\n\  done' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    libcap)
        if [ "$Chapter" = update ]; then
          if $useDESTDIR; then
            GetCommands \
             | sed -e '0,/make prefix=\/usr lib=lib/s//make prefix=\/usr lib=lib\n\  make -C pam_cap/' \
                   -e '/make prefix=\/usr lib=lib install/a\  install -dm0755 "${CUR_DIR}"\/usr\/lib\/security\n\  install -v -m755 pam_cap\/pam_cap.so "${CUR_DIR}"\/usr\/lib\/security\n\  install -dm0755 "${CUR_DIR}"\/etc\/security\n\  install -v -m644 pam_cap\/capability.conf "${CUR_DIR}"\/etc\/security' \
                   -e 's/make prefix=\/usr lib=lib install/make DESTDIR="$CUR_DIR" prefix=\/usr lib=lib sbindir=bin install/' \
             >> $Output
          else
            GetCommands \
             | sed -e 's/make prefix=\/usr lib=lib install/make prefix=\/usr lib=lib sbindir=bin install/' \
             >> $Output
          fi
        else # ch08
          if $useDESTDIR; then
            GetCommands \
             | sed -e 's/make prefix=\/usr lib=lib install/make DESTDIR="$CUR_DIR" prefix=\/usr lib=lib sbindir=bin install/' \
             >> $Output
          else
            GetCommands \
             | sed -e 's/make prefix=\/usr lib=lib install/make prefix=\/usr lib=lib sbindir=bin install/' \
             >> $Output
          fi
        fi
    ;;
    libelf)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/libelf install/libelf DESTDIR="$CUR_DIR" install/' \
                 -e 's/libelf.pc \/usr\/lib\/pkgconfig/libelf.pc "${CUR_DIR}"\/usr\/lib\/pkgconfig/' \
                 -e 's/rm \/usr\/lib\/libelf.a/rm "${CUR_DIR}"\/usr\/lib\/libelf.a/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    libtool)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/rm -fv \/usr\/lib\/libltdl/rm -fv "${CUR_DIR}"\/usr\/lib\/libltdl/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    linux-headers)
        if [[ "$useDESTDIR" = true || "$single_package" = true ]]; then
          GetCommands \
           | sed -e '/cp -rv usr\/include/i\  mkdir -pv ${CUR_DIR}\/usr\/include' \
                 -e 's/include \/usr/include ${CUR_DIR}\/usr/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    man-db)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/disable-setuid/i\              --libexecdir=\/usr\/lib \\\n\              --sbindir=/usr/bin \\' \
                 -e 's/\/usr\/lib\/tmpfiles.d\/man-db.conf/"${CUR_DIR}"\/usr\/lib\/tmpfiles.d\/man-db.conf/' \
           >> $Output
        else
          if [ "$SYSTEMD" = yes ]; then
            if $as_root; then
              GetCommands \
               | sed -e 's/bin\/grap/bin\/grap --libexecdir=\/usr\/lib/' \
               >> $Output
            else
              GetCommands \
               | sed -e 's/bin\/grap/bin\/grap --libexecdir=\/usr\/lib/' \
                     -e 's/man root:root root/man man:man-db man-db/' \
               >> $Output
            fi
          else
            GetCommands >> $Output
          fi
        fi
    ;;
    man-pages)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/make prefix=\/usr install/make prefix=\/usr DESTDIR="$CUR_DIR" install/' \
           >> $Output
        elif ! $installBinTarfile; then
          GetCommands \
           | sed -e '/configure_commands/i sed -i "s|prefix := /usr/local|prefix := /usr|g" Makefile' \
           >> $Output
        fi
    ;;
    markupsafe)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/pip3 install/i\  PYTHONPATH=src python3 -m installer --destdir=\"\$CUR_DIR\" dist/*.whl' \
                 -e '/pip3 install/d' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    meson)
        if $useDESTDIR; then
          GetInternalCommands mesonDestdirComms >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    ncurses)
        if [ "$currentChapter" = chapter06 ]; then
          GetCommands >> $Output
	else # chapter08 and update
          if [ "$SYSTEMD" = yes ]; then
            if $useDESTDIR; then
              GetInternalCommands ncursesDestdirComms >> $Output
            else
              GetInternalCommands ncursesComms >> $Output
            fi
          else # sysv
             GetCommands \
              | sed -e '/make distclean/,/cp -av lib\/lib/d' \
              >> $Output
          fi
	fi # chapter06 or 08
    ;;
    ninja)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/install -vm755 ninja/i\  install -dm0755 "${CUR_DIR}"\/usr\/{bin,share}' \
                 -e 's/ \/usr\/bin/ "${CUR_DIR}"\/usr\/bin/' \
                 -e 's/ \/usr\/share/ "${CUR_DIR}"\/usr\/share/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    openssl)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/make MANSUFFIX/make DESTDIR="$CUR_DIR" MANSUFFIX/' \
                 -e 's/mv -v \/usr\/share\/doc\/openssl \/usr/mv -v "${CUR_DIR}"\/usr\/share\/doc\/openssl "${CUR_DIR}"\/usr/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    procps-ng)
        if [ "$SYSTEMD" = yes ]; then # add the sysctl.conf file
          if [ "$Chapter" != update ]; then
            GetCommands \
             | sed -e '/libdir=\/usr\/lib/i\              --bindir=\/usr\/bin \\\n\              --sbindir=\/usr\/bin \\\n\              --with-systemd                           \\' \
                   -e '/sed -i/,/make check/d' \
                   -e '/ln -sfv/a touch \/etc\/sysctl.conf' \
                   -e '/mv -v/,/ln -sfv/d' \
             >> $Output
          else # update
            GetCommands \
             | sed -e '/libdir=\/usr\/lib/i\              --bindir=\/usr\/bin \\\n\              --sbindir=\/usr\/bin \\\n\              --with-systemd                           \\' \
                   -e '/sed -i/,/make check/d' \
                   -e '/mv -v/,/ln -sfv/d' \
             >> $Output
          fi
        else
           GetCommands >> $Output
        fi
    ;;
    psmisc)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e '/mv -v/d' \
           >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    python3) # remove doc commands
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/configure --prefix/i\  CXX=\"\/usr\/bin\/g++\"               \\' \
                 -e '/sed -e/,/-i \/usr\/lib/d' \
                 -e 's/5 \/usr\/share\/doc/5 "${CUR_DIR}"\/usr\/share\/doc/' \
                 -e '/tar --strip-components/,/-xvf /d' \
           >> $Output
        else
          GetCommands \
           | sed -e '/tar --strip-components/,/-xvf /d' \
           >> $Output
        fi
    ;;
    py3-flit-core)
        if [ "$Chapter" = chapter08 ]; then
          if $useDESTDIR; then # needs py3-installer installed to do a destdir install
            GetInternalCommands pymodDestdirComms \
             | sed -e 's/PYTHONPATH=src/PYTHONPATH=flit_core/' \
             >> $Output
          else
            GetCommands >> $Output # pip install
          fi
        elif [ "$Chapter" = update ]; then
          if $useDESTDIR; then # needs py3-installer installed to do a destdir install
            GetInternalCommands pymodDestdirComms \
             | sed -e 's/PYTHONPATH=src/PYTHONPATH=flit_core/' \
             >> $Output
          else # do a pip install upgrade
            GetCommands \
             | sed -e 's/python3 -m pip install/python3 -m pip install --upgrade/' \
             >> $Output
          fi
        fi
    ;;
    py3-installer)
        if [ "$Chapter" != update ]; then # chapter08
          if $useDESTDIR; then # needs py3-installer installed to do a destdir install
            GetInternalCommands pymodDestdirComms >> $Output
          else
            GetCommands >> $Output
          fi
        else # update
          if $useDESTDIR; then
            GetInternalCommands pymodDestdirComms >> $Output
          else
            GetCommands \
             | sed -e 's/python3 -m pip install/python3 -m pip install --upgrade/' \
             >> $Output
          fi
        fi
    ;;
    readline)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/lncursesw\" install/lncursesw\" DESTDIR=\"\$CUR_DIR\" install/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    sed)
        if $useDESTDIR; then
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
                   -e 's/make -C doc install/make -C doc DESTDIR="$CUR_DIR" install/' \
             >> $Output
          else
             GetCommands \
              | sed -e 's/make -C doc install/make -C doc DESTDIR="$CUR_DIR" install/' \
              >> $Output
          fi
        else # not using DESTDIR
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
             >> $Output
          else
             GetCommands >> $Output
          fi
        fi
    ;;
    shadow)
        # the following apply if not update:
        # assume without cracklib support
        # do not install foreign man pages
        # do not set root passwd
        # setup shadow passwd files
        # delete pwconv and grpconv because cannot lock /etc/passwd
        # do pwconv and grpconv later as root
      if [ "$Chapter" != update ]; then # ch08
        if $useDESTDIR; then
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e '/DICTPATH/d' \
                   -e 's#touch /usr/bin/passwd#mkdir -pv "${CUR_DIR}"/usr/bin\ntouch "${CUR_DIR}"/usr/bin/passwd#' \
                   -e "/configure_commands()/i sed -i -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\\\\/uk/' \\\\\n\       -e 's\/uk zh_CN zh_TW\/\/' \\\\\n\       -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr\/uk/'  man/Makefile.in" \
                   -e 's/sysconfdir=\/etc/sysconfdir=\/etc \\\n\              --bindir=\/usr\/bin \\\n\              --sbindir=\/usr\/bin \\\n\              --libdir=\/usr\/lib/' \
                   -e 's#make exec_prefix=#make DESTDIR="$CUR_DIR" exec_prefix=#' \
                   -e 's#make -C man install#make DESTDIR="$CUR_DIR" -C man install#' \
		   -e '/pwconv/,/grpconv/d' \
                   -e 's#mkdir -p /etc/default#mkdir -p "${CUR_DIR}"/etc/default#' \
                   -e '/useradd -D/,/passwd root/d' \
             >> $Output
          else # sysV - won't work, needs changing
            GetCommands \
             | sed -e '/DICTPATH/d' \
                   -e "/configure_commands()/i sed -i -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\\\\/uk/' \\\\\n\       -e 's\/uk zh_CN zh_TW\/\/' \\\\\n\       -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr\/uk/'  man/Makefile.in" \
                   -e 's/sysconfdir=\/etc/sysconfdir=\/etc \\\n\              --bindir=\/usr\/bin \\\n\              --sbindir=\/usr\/bin \\\n\              --libdir=\/usr\/lib/' \
                   -e '/pwconv/,/grpconv/d' \
                   -e '/passwd root/d' \
                   -e "s/sed -i 's\/yes\/no\/' \/etc\/default\/useradd/sed -i 's\/yes\/no\/' \${CUR_DIR}\/etc\/default\/useradd/" \
             >> $Output
          fi
        else # not useDESTDIR
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e '/DICTPATH/d' \
                   -e "/configure_commands()/i sed -i -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\\\\/uk/' \\\\\n\       -e 's\/uk zh_CN zh_TW\/\/' \\\\\n\       -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr\/uk/'  man/Makefile.in" \
                   -e '/make -C man install-man/d' \
                   -e '/pwconv/ i touch /etc/shadow\nchmod 640 /etc/shadow' \
                   -e '/grpconv/ i touch /etc/gshadow\nchmod 640 /etc/gshadow' \
                   -e '/pwconv/d' \
                   -e '/grpconv/d' \
                   -e '/passwd root/d' \
             >> $Output
          else # sysV - won't work, needs changing
            GetCommands \
             | sed -e '/DICTPATH/d' \
                   -e "/configure_commands()/i sed -i -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\\\\/uk/' \\\\\n\       -e 's\/uk zh_CN zh_TW\/\/' \\\\\n\       -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr\/uk/'  man/Makefile.in" \
                   -e '/passwd root/d' \
                   -e '/pwconv/ i touch /etc/shadow\nchmod 640 /etc/shadow' \
                   -e '/grpconv/ i touch /etc/gshadow\nchmod 640 /etc/gshadow' \
                   -e '/pwconv/d' \
                   -e '/grpconv/d' \
             >> $Output
          fi
        fi
      else # update
          if $useDESTDIR; then # use the destdir commands
            GetInternalCommands shadowDestdirComms >> $Output
          else
            GetInternalCommands shadowComms >> $Output
         fi 
      fi
    ;;
    stripping)
        echo "set +e" >> $Output
        if ! $as_root; then 
          GetCommands \
           | sed -e "/strip --strip-unneeded \/tmp\/\$LIB/a\    USER=\$(stat -c '%U' \/usr\/lib\/\$LIB)\n\    GROUP=\$(stat -c '%G' \/usr\/lib\/\$LIB)" \
                 -e "/strip --strip-unneeded \/tmp\/\$BIN/a\    USER=\$(stat -c '%U' \/usr\/bin\/\$BIN)\n\    GROUP=\$(stat -c '%G' \/usr\/bin\/\$BIN)" \
                 -e 's/install -vm755 \/tmp\/$LIB \/usr\/lib/install -vm755 -o $USER -g $GROUP \/tmp\/$LIB \/usr\/lib\n\    if [ -e "$LIB.dbg" ]; then chown -v $USER:$GROUP $LIB.dbg; fi/' \
                 -e 's/install -vm755 \/tmp\/$BIN \/usr\/bin/install -vm755 -o $USER -g $GROUP \/tmp\/$BIN \/usr\/bin/' \
           >> $Output
        else # as root so don't need to specify the USER and GROUP ids
          GetCommands >> $Output
        fi
    ;;
    sysklogd)
        if ! $as_root; then
        # fix the Make file to use the install wrapper and not the default install bin
          GetCommands \
           | awk '{if ($NF == "install" && $1 == "make") $1 = "  make INSTALL=install"; print $0}' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    systemd)
        if ! $as_root; then
          if $useDESTDIR; then
            GetCommands \
             | sed -e 's/ninja install/DESTDIR="$CUR_DIR" ninja install/' \
                   -e '/tar -xf /i install -dm0755 "${CUR_DIR}"\/usr\/share\/man' \
                   -e 's/--strip-components=1 //' \
		   -e 's/-C \/usr\/share\/man/-C "${CUR_DIR}"\/usr\/share\/man/' \
                   -e '/systemd-machine-id-setup/,/systemctl disable systemd-sysupdate/d' \
             >> $Output
          else
            GetCommands \
             | sed -e 's/--strip-components=1 //' \
                   -e '/tar -xf/a # mv the man pages to the correct dir\npushd /usr/share/man/systemd-man-pages-* > /dev/null\nfor page in 1 3 5 7 8; do\n  cd man${page}\n  mv -v *.* /usr/share/man/man${page}\n  cd ..\ndone\ncd ..\nrm -rf -v systemd-man-pages-*\npopd > /dev/null' \
                   -e '/systemd-machine-id-setup/,/systemctl disable systemd-sysupdate/d' \
             >> $Output
          fi
        else
          GetCommands >> $Output
	fi
    ;;
    sysvinit)
        GetCommands \
         | sed -e "/patch/a sed -i '/dev\\\/initctl/d' src/Makefile" \
         >> $Output
    ;;
    tar)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/bindir=\/bin/bindir=\/usr\/bin --libexecdir=\/usr\/lib\/tar/' \
                 -e 's/make -C doc install-html/make -C doc DESTDIR=\"\$CUR_DIR\" install-html/' \
           >> $Output
        else
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/bindir=\/bin/bindir=\/usr\/bin --libexecdir=\/usr\/lib\/tar/' \
             >> $Output
          else
            GetCommands >> $Output
          fi
        fi
    ;;
    tcl)
      if [ "$Chapter" != update ]; then
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/chmod -v u+w \/usr/chmod -v u+w \"\${CUR_DIR}\"\/usr/' \
                 -e 's/ln -sfv tclsh8.6 \/usr/ln -sfv tclsh8.6 \"\${CUR_DIR}\"\/usr/' \
                 -e 's/mv \/usr\/share\/man\/man3/mv \"\${CUR_DIR}\"\/usr\/share\/man\/man3/' \
	   >> $Output
        else
          GetCommands >> $Output
        fi
      else # update
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/chmod -v u+w \/usr/chmod -v u+w \"\${CUR_DIR}\"\/usr/' \
                 -e 's/ln -sfv tclsh8.6 \/usr/ln -sfv tclsh8.6 \"\${CUR_DIR}\"\/usr/' \
                 -e 's/mv \/usr\/share\/man\/man3/mv \"\${CUR_DIR}\"\/usr\/share\/man\/man3/' \
           >> $Output
        else
          GetCommands \
           | sed -e '/ln -sfv tclsh8.6 /irm -v \/usr\/bin\/tclsh' \
                 -e '/mv \/usr\/share\/man\/man3/i\if [ -e "\/usr\/share\/man\/man3\/Tcl_Thread.3" ]; then\n\  rm -v "\/usr\/share\/man\/man3\/Tcl_Thread.3"\nfi' \
           >> $Output
        fi
      fi
    ;;
    texinfo)
        # tries and fails to rebuild /usr/share/info/dir
        GetCommands \
         | sed -e '/make TEXMF=/d' \
               -e '/pushd/,/popd/d' \
         >> $Output
    ;;
    util-linux)
        GetCommands \
         | sed -e "/make install/i\  sed -e '/chgrp tty \\\\\$(DESTDIR)/ s/^/#/' \\\\\n\      -e '/chown root:root \\\\\$(DESTDIR)/ s/^/#/' \\\\\n\      -i Makefile" \
         >> $Output
    ;;
    vim)
        if [ "$Chapter" != update ]; then
          GetCommands \
           | sed -e 's/make test/make -j1 test/' \
                 -e '/:options/d' \
           >> $Output
        else
          if $useDESTDIR; then
            GetCommands \
             | sed -e 's/ln -sv vim \/usr/ln -sv vim ${CUR_DIR}\/usr/' \
                   -e 's/for L in  \/usr/for L in  ${CUR_DIR}\/usr/' \
                   -e '/ln -sv ..\/vim\/vim82\/doc/i mkdir -pv ${CUR_DIR}\/usr\/share\/doc' \
                   -e 's/vim82\/doc \/usr/vim82\/doc ${CUR_DIR}\/usr/' \
                   -e '/cat > \/etc\/vimrc/i mkdir -pv ${CUR_DIR}\/etc' \
                   -e 's/cat > \/etc\/vimrc/cat > ${CUR_DIR}\/etc\/vimrc/' \
                   -e '/:options/d' \
             >> $Output
          else
            GetCommands \
             | sed -e '/:options/d' \
             >> $Output
          fi
        fi
    ;;
    wheel)
        if [ "$Chapter" != update ]; then
          GetCommands >> $Output
        else # update
          if $useDESTDIR; then # needs py3-installer installed
            GetInternalCommands wheelDestdirComms >> $Output
          else
            GetCommands \
             | sed -e 's/pip3 install --no-index/pip3 install --no-index --upgrade/' \
             >> $Output
          fi
        fi
    ;;
    xz)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/prefix=\/usr/prefix=\/usr --libdir=\/usr\/lib/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    zlib)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/make install/make DESTDIR="$CUR_DIR" install/' \
                 -e 's/rm -fv \/usr\/lib\/libz/rm -fv "${CUR_DIR}"\/usr\/lib\/libz/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    zstd)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/make prefix=\/usr install/make PREFIX=\/usr DESTDIR="$CUR_DIR" install/' \
                 -e 's/make prefix=\/usr/make PREFIX=\/usr/' \
                 -e '/rm -v \/usr/i ln -sf \/usr\/bin\/zstd "${CUR_DIR}\/usr\/bin\/zstdmt"' \
                 -e 's/rm -v \/usr\/lib\/libzstd/rm -v "${CUR_DIR}"\/usr\/lib\/libzstd/' \
           >> $Output
        else
          GetCommands  >> $Output
        fi
    ;;
    *)
        GetCommands >> $Output
        return_val=$?
        if [ $return_val -eq $RETURN_PARAM ]; then # no build file
          echo "No build file available in ${LFS}/tools/pkguser"
          echo "Please place the build file there to continue."
          exit 1
        elif [ $return_val -eq $RETURN_NO_CMNDS ]; then
          echo "*** WARNING ***"
          echo "No commands found for package $PkgName"
	  if $single_package; then
	    echo "Package $SINGLE_PACKAGE not found in $Chapter"
	    echo "You should set Chapter to the one you want and try again"
	    echo "Exiting now"
	    exit 1
	  fi
        fi
    ;;
esac
} # end WriteScript
#
cleanstart () {
# $1 is the script name to delete. Can be all
if [ "$1" = all ]; then
  scriptToDelete="$ch7asroot $ch7chroot $ch5script $ch6script $ch8script LFS-chroot.sh"
elif [[ "$1" = chapter05 || "$1" = chapter06 || "$1" = update ]]; then
  scriptToDelete=${1}.sh
elif [ "$1" = chapter07 ]; then
  scriptToDelete="$ch7asroot $ch7chroot $ch7script"
elif [ "$1" = chapter08 ]; then
  scriptToDelete="$ch8script LFS-chroot.sh"
fi
for Script in $scriptToDelete; do
  for loc in $LFS ~/; do
    if [ -e $loc/$Script ]; then rm $loc/$Script; fi
  done
done
} #end cleanstart
#
addCommands () {
# adds commands to the $lfscommands dir for a given book-chapter and package
# $1 is the package name
# $2 is the number to add to the front of the package name (must be unique)
# $3 is the chapter in the book where this package is installed
# $4 is the commands to add
local pkgnm=$1
local number=$2
local chapter=$3
local commands=("${!4}")
# the location of the commands
local location="${DumpedCommands}/${chapter}"
local com
if [ ! -d "$location" ]; then
  return $RETURN_PARAM
else
  local fileLoc="${location}/${number}-${pkgnm}"
# check if required commands are in place
  if [ -e "$fileLoc" ]; then # exists
    return 0
  else
# add the commands for pkgnm to location
    if $printit; then msg "will add commands for $pkgnm to $location"; fi
    cat > $fileLoc << EOF
$(
    for com in "${commands[@]}"; do
      echo "$com"
    done
 )
EOF
  fi
  return 0
fi
} # end addCommands
#
arrangeOrder () {
# $1 is the script to arrange
# $2 is the chapter
tmpfile=/tmp/$(date +%d%B%Y_%H:%M)tmp.file
local IFS=' ' # set the separator to a space
local scriptToArrange=$1
local chapter=$2
#
for scrpt in $scriptToArrange; do
  Output=$scrpt
# match the start line for each function and output it
  awk '/_[[:space:]]\(\)[[:space:]]\{/ {print $1}' $Output >> $tmpfile

#
# the install order for Chapter08 in book version sysv is different from version systemd
# need to change the install order here
#
# TODO - this is a mess, but not sure there is an elegant solution to rearranging
#
  while read eachFunc; do
    if [[ "$chapter" = chapter08 || "$WHICH_CHAPTER" = update ]]; then
      if [[ "$SYSTEMD" = yes ]]; then # don't need sysklogd and sysvinit
        if [[ "$isSystemdBook" = false ]]; then # need to change the order
          if [[ "$eachFunc" = sysklogd_ || "$eachFunc" = sysvinit_ ]]; then
            : # don't write it
          elif [[ "$eachFunc" = procpsng_ || "$eachFunc" = e2fsprogs_ || "$eachFunc" = coreutils_ || "$eachFunc" = gperf_ || "$eachFunc" = intltool_ || "$eachFunc" = diffutils_ || "$eachFunc" = gawk_ || "$eachFunc" = findutils_ || "$eachFunc" = xz_ || "$eachFunc" = kmod_ || "$eachFunc" = utillinux_ || "$eachFunc" = mandb_ || "$eachFunc" = eudev_ ]]; then # will be moved
            :
          elif [[ "$eachFunc" = gdbm_ ]]; then # add gperf
            echo "$eachFunc
gperf_" >> $Output
          elif [[ "$eachFunc" = xmlparser_ ]]; then # add intltool
            echo "$eachFunc
intltool_" >> $Output
          elif [[ "$eachFunc" = automake_ ]]; then # ad xz
            echo "$eachFunc
xz_
kmod_" >> $Output
          elif [[ "$eachFunc" = systemd_ ]]; then # add procps-ng, etc
            echo "$eachFunc
procpsng_
e2fsprogs_
coreutils_
diffutils_
gawk_
findutils_" >> $Output
          elif [[ "$eachFunc" = dbus_ ]]; then # add util-linux and man-db
            echo "$eachFunc
utillinux_
mandb_" >> $Output
          else
            echo $eachFunc >> $Output
          fi
        else # SYSTEMD=yes and isSystemdBook=true, add py3 modules before stripping
          if [[ "$eachFunc" = sysklogd_ || "$eachFunc" = sysvinit_ ]]; then
            : # don't write it
          elif [[ "$eachFunc" = e2fsprogs_ ]]; then # add py3 modules
            if ! $as_root; then
              echo "$eachFunc
updatePkgUser_
py3flitcore_
py3installer_" >> $Output
            fi
          elif [[ "$eachFunc" = py3flitcore_ || "$eachFunc" = py3installer_ || "$eachFunc" = updatePkgUser_ ]]; then
            : # don't write them here
          else
            echo $eachFunc >> $Output
          fi
        fi
      else # chapter08 or update and SYSTEMD=no
        if [[ "$eachFunc" = dbus_ || "$eachFunc" = systemd_ ]]; then
          : # don't write it
        else 
          echo $eachFunc >> $Output
        fi
      fi
    else # chapter07 - need to move creatingdirs first
      if [[ "$eachFunc" = resetBashProfile_ ]]; then # has to come after pkguser
	    :
      elif [[ "$eachFunc" = pkguser_ ]]; then
         echo "$eachFunc
resetBashProfile_" >> $Output
      else # write them
        echo $eachFunc >> $Output
      fi
    fi
  done < $tmpfile
  rm $tmpfile
  chmod 700 $Output
done
} # end arrangeOrder
#
removeTests () {
# removes all the test commands from a script
# $1 is the script file
local scriptFile=$1
echo "Removing test commands for script $scriptFile"
sed -e '/make -k check 2>&1 | tee glibc-check-log/d' \
    -e '/grep Error glibc-check-log/d' \
    -e '/make check/d' \
    -e '/make -j1 check/d' \
    -e '/make -j4 check/d' \
    -e '/make -k check/d' \
    -e '/make -kj1 check/d' \
    -e '/make -k -j1 check/d' \
    -e '/make RUN_EXPENSIVE_TESTS=yes check/d' \
    -e '/TZ=UTC make test/d' \
    -e '/make check 2>&1 | tee gmp-check-log/d' \
    -e "/awk '\/# PASS:\/{total+=\$3} ; END{print total}' gmp-check-log/d" \
    -e '/ulimit -s 32768/,/contrib\/test_summary/d' \
    -e '/make NON_ROOT_USERNAME=nobody check-root/d' \
    -e '/echo "dummy:x:1000:nobody" >> \/etc\/group/d' \
    -e '/bash tests\/run.sh --srcdir=\$PWD --builddir=\$PWD/d' \
    -e '/chown -Rv nobody ./d' \
    -e '/su nobody -s \/bin\/bash -c "PATH=\$PATH make check"/d' \
    -e '/su nobody -s \/bin\/bash -c \"make RUN_EXPENSIVE_TESTS=yes check\"/d' \
    -e '/su nobody -s \/bin\/bash -c "make tests"/d' \
    -e "/sed -i '\/dummy\/d' \/etc\/group/d" \
    -e '/tester/d' \
    -e '/make test/d' \
    -e '/make -k test/d' \
    -e '/make -j1 test/d' \
    -e '/ninja_test/d' \
    -e '/make PERL5LIB=\$PWD\/tests/d' \
    -e '/make localedata\/install-locales/d' \
    -e '/ln -sfv \/tools\/lib\/lib{blk,uu}id.so.1 lib/,/make LD_LIBRARY_PATH=\/tools\/lib check/d' \
    -i $scriptFile
} # end removeTests
#
containsElement () {
#msg "in containsElement"
# check if an array contains a value
# $1 is the element to find
# $2 is the array to search
local toFind=$1
declare -a anArray=("${!2}")
local elem
for elem in $anArray; do
  if [[ "$toFind" == "$elem" ]]; then return 0; fi
done
return $RETURN_PARAM
} # end containsElement
#
Start () {
cleanstart $WHICH_CHAPTER
local bookdir=$1
local book_version=$2
# if a single package used, then $3 is the package name
local singlePackage=$3
local listPackages
#
REPODIR="${bookdir}/${trunkDIR}"
Chapter=$WHICH_CHAPTER # don't change Chapter, change reqChaps
# build the requested chapters or a single package
scriptName=""
if $single_package; then
  scriptName="${LFS}/${singlePackage}.sh"
  if [ "$singlePackage" = kernel ]; then
    reqChaps=chapter10
  else
    reqChaps=chapter08
  fi
  if $printit; then msg "reqChaps is $reqChaps"; fi
  if $printit; then msg "Chapter is $Chapter"; fi
else # not a single package
  reqChaps=$WHICH_CHAPTER
  if [ "$WHICH_CHAPTER" = update ]; then
    if $make_kernel; then
      reqChaps=chapter10
    else
      reqChaps=chapter08
    fi
  fi
  if [ "$reqChaps" = all ]; then # *** this currently (05/2022) doesn't work ***
    reqChaps=$allChaps # doesn't include update
    echo "*** WARNING *** all chapters does not work. It is not tested"
    exit 1
  fi
  if $printit; then msg "reqChaps is $reqChaps"; fi
  if $printit; then msg "Chapter is $Chapter"; fi
fi
# cycle through the requested chapters
# TODO get this to work for multiple chapters
for currentChapter in $reqChaps; do
  if ! $single_package; then
# set the output script name
    if $printit; then msg "currentChapter is $currentChapter"; fi
    case $currentChapter in
       chapter05)
         scriptName=${LFS}/${ch5script}
       ;;
       chapter06)
         scriptName=${LFS}/${ch6script}
       ;;
       chapter07)
         scriptName=${LFS}/${ch7script}
       ;;
       chapter08)
         if [ "$Chapter" = update ]; then
           scriptName=${LFS}/${updateScript}
         else
           scriptName=${LFS}/${ch8script}
         fi
       ;;
       chapter10)
         if [ "$Chapter" = update ]; then
           if $make_kernel; then
             scriptName="${LFS}/${updateScript/\.sh/}-kernel.sh"
           fi
         else
           scriptName=${LFS}/${ch10script}
         fi
       ;;
    esac
  fi
  if $printit; then msg "scriptName is $scriptName"; fi
  Output=$scriptName # global variable
  if [[ ("$Chapter" = chapter10 || "$Chapter" = update) && "$make_kernel" = true ]]; then
    if ! $single_package; then
      if $useDESTDIR; then
        echo "A binary tarfile will be created for the kernel"
      fi
    fi
  fi
  Header # set the header values
  if $single_package; then
    listPackages=$singlePackage
  else # all packages in currentChapter
# if chapter is not update then remove linux-headers from chapter08
    testForLinuxHeaders="${DumpedCommands}/${currentChapter}/071-linux-headers"
    if [ "$Chapter" != update ]; then
      if [ -e $testForLinuxHeaders ]; then rm -v $testForLinuxHeaders; fi
    fi
#msg "haveCommands is $haveCommands"
    if $haveCommands; then # use the $lfscommands dir on the target machine
      listPackages=$( ls -l ${DumpedCommands}/${currentChapter} | tail -n+2 | awk '{print $NF}' | sed 's/^[^-]*-//g')
    elif [ -d "${REPODIR}/lfs/${currentChapter}" ]; then # use the book xml files to get pkgnames
      listPackages=$( awk -F\" '/href/ && !/<!--/ {gsub(/\.xml/,"");print $(NF -1)}' ${REPODIR}/lfs/${currentChapter}/${currentChapter}.xml )
    else
      echo "No book found in ${REPODIR}/lfs/${currentChapter}"
      echo "and no commands in ${DumpedCommands}/${currentChapter}"
      echo "Aborting"
      exit 1
    fi
  fi
  if ! $single_package; then # check if linux-headers is needed
    if [ "$Chapter" = update ]; then # is linux-headers in listPackages
      if ! $make_kernel; then
        nl='
'
        containsElement "linux-headers" listPackages[@]
        retval=$?
        if [ $retval -ne 0 ]; then listPackages="linux-headers""${nl}"$listPackages; fi
      else # install the kernel
        listPackages[0]="kernel"
      fi
    fi
  fi
if $printit; then msg "listPackages is ${listPackages[@]}"; fi
  for Name in $listPackages; do
# ignore systemd and dbus if using sysv
    if [[ "$isSystemdBook" = false && ("$Name" == systemd || "$Name" == dbus) ]]; then # not installed in this book version
      :
    else
      if [[ "$SYSTEMD" = yes && "$Name" = eudev ]]; then # ignore this - replaced by systemd
        :
      else
        FuncName=$( echo $Name | sed -e s/-//g ) # no - allowed in bash names
        PkgName=$( echo $Name | sed -e s/pass.$// -e s/-$// )
        SrcName=$PkgName-
        CmdName=$Name
        if [ "$PkgName" = Python ]; then # use python3 for Python-3*
          FuncName=python3
          PkgName=python3
        elif [ "$PkgName" = flit ]; then
          FuncName=py3flitcore
          PkgName=py3-flit-core
        elif [ "$PkgName" = installer ]; then
          FuncName=py3installer
          PkgName=py3-installer
        fi
# if installing binary tarfile(s) and chapter07, don't create the ch7asroot and ch7chroot files
        if [ "$currentChapter" = chapter07 ]; then 
          if  $installBinTarfile; then
            Output=${LFS}/${ch7script}
          else # create the 3 files
            case $FuncName in
               changingowner)
                 Output=${LFS}/${ch7asroot}
               ;;
               chroot)
                 Output=${LFS}/${ch7chroot}
# if you log out or reboot you need to mount the kernelfs again
# so include some conditionals to look after this
                 cat ${LFS}/${ch7asroot} \
                  | awk '/mount -v/ { printf "if [ \"$(grep -q \""$NF"\" /proc/mounts;echo $?)\" != \"0\" ]; then\n  "$0"\nfi\n"}' \
                  >> $Output
               ;;
               *)
                 Output=${LFS}/${ch7script}
               ;;
            esac
          fi
        fi
# if installing binary tarfile(s), check if the tarfile exists for this package
# if not present then ignore this package
        if $installBinTarfile; then # check if the binary tarfile exists, if so then get pkgVers
          reviseSection=""
          separator="-" # usually a hyphen
# in some cases, the binary tarfile name is different from the PkgName
          case $PkgName in
             expect)
               serchPkg="expect5"
               separator="."
             ;;
             jinja2)
               serchPkg="Jinja2"
             ;;
             kernel)
               serchPkg="linux"
             ;;
             markupsafe)
               serchPkg="MarkupSafe"
             ;;
             py3-flit-core)
               reviseSection="pythonmodules"
               serchPkg="flit-core"
             ;;
             py3-installer)
               reviseSection="pythonmodules"
               serchPkg="installer"
             ;;
             python3)
               serchPkg="Python"
             ;;
             tcl)
               serchPkg="tcl8"
               separator="."
             ;;
             xml-parser)
               serchPkg="XML-Parser"
             ;;
             *)
               serchPkg=$PkgName
             ;;
          esac
          binTarfileVers=$(getBinTarfileVers $PkgName $serchPkg $separator $reviseSection)
          retval=$?
          if [[ $retval -eq $RETURN_PARAM || $retval -eq $RETURN_FNF ]]; then
            echo "No binary tarfile found for package $PkgName"
            echo "Will ignore package $PkgName"
            continue
          elif [ $retval -eq 0 ]; then # found a binary tarfile
# if chapter10 and grub, then ignore it
            if [ "$currentChapter" = chapter10 ]; then
              if [ "$PkgName" = grub ]; then # ignore
                echo "No binary tarfile found for package $PkgName"
                echo "Will ignore package $PkgName"
                continue
              else
                echo "binary tarfile found for package $PkgName"
              fi
            else
              echo "binary tarfile found for package $PkgName"
            fi
            if $printit; then msg "binTarfileVers is $binTarfileVers"; fi
          fi
        fi
        case $PkgName in # call Function
           createfiles)
              if [ "$Chapter" != update ]; then
                Function
# Now have a base file structure so add pkguser
                if ! $as_root; then pkguser; fi
              fi
           ;;
           creatingdirs)
              if [ "$Chapter" != update ]; then
                Function
              else
                cleanPkgDir
                update_pkguser # add some files to the tools dir
                if $useDESTDIR; then createPkgFile; fi
              fi
           ;;
           expect)
              SrcName=expect5
              Function
           ;;
           fstab) # cannot deal with this here - created in chapter10
              :
           ;;
           gcc-libstdc++) # name in chapter05 - remove the gcc-
              PkgName=gcc
              SrcName=gcc-
              if [ "$FuncName" = "gcclibstdc++" ]; then
                CmdName="gcc-libstdc++"
              fi
#              if [ "$FuncName" = "gcclibstdc++pass1" ]; then
#                CmdName="gcc-libstdc++-pass1"
#              fi
              Function
           ;;
           gettext) 
              Function
              if [[ "$SYSTEMD" = yes && "$isSystemdBook" = false && "$currentChapter" = chapter06 ]]; then # add systemd
                for sysFile in systemd; do
                  FuncName=$sysFile
                  PkgName=$sysFile
                  SrcName=$sysFile-
                  Function
                done
              fi
           ;;
           introduction|toolchaintechnotes|generalinstructions|pkgmgt|aboutdebug)
              : # do not need any of these
           ;;
           jinja2)
              SrcName=Jinja2-
              Function
           ;;
           kernfs)
              if [ "$currentChapter" = chapter07 ]; then
                Output=${LFS}/${ch7asroot}
                Function
              fi
           ;;
           libelf)
              SrcName=elfutils-
              Function
           ;;
           libstdc++)
              PkgName=gcc
              SrcName=gcc-
	      if [ "$FuncName" = "libstdc++pass2" ]; then
		CmdName="gcc-libstdc++-pass2"
	      else
	        CmdName="gcc-libstdc++-pass1"
	      fi
              Function
 	   ;;    
           linux-headers|kernel)
              SrcName=linux-
              Function
           ;;
           markupsafe)
              SrcName=MarkupSafe-
              Function
           ;;
           patch) 
              Function
              if [[ "$SYSTEMD" = yes && "$isSystemdBook" = false && "$currentChapter" = chapter06 ]]; then
# add dbus after patch
                for sysFile in dbus; do
                  FuncName=$sysFile
                  PkgName=$sysFile
                  SrcName=$sysFile-
                  Function
                done
              fi
           ;;
           pkgconfig)
              PkgName=pkg-config
              CmdName=pkg-config
              SrcName=pkg-config-
              Function
           ;;
           procps)
              FuncName=procpsng
              PkgName=procps-ng
              CmdName=procps-ng
              SrcName=procps-ng-
              Function
           ;;
           py3-flit-core)
              if ! $as_root; then updatePkgUser "pythonmodules"; fi
              Function
           ;;
           py3-installer) # add updatePkgUser if a single package
              if $single_package && ! $as_root; then updatePkgUser "pythonmodules"; fi
              Function
           ;;
           cleanup)
               if [[ "$currentChapter" = chapter08 && "$useDESTDIR" = false ]]; then
                Function
              fi
           ;;
           tcl)
                SrcName=tcl8.
                Function
           ;;
           xml-parser)
                SrcName=XML-Parser-
                Function
           ;;
           *)
              if [[ "$currentChapter" == chapter10 && "$PkgName" == grub ]]; then # want the grub in chapter08 but not the one in chapter10
                :
              else
                if [[ "$FuncName" = stripping && "$useDESTDIR" = true ]]; then # ignore
                  :
                else
                  Function
                fi
              fi
           ;;
        esac
      fi
    fi
  done # end of Name in $listPackages
  if [[ "$single_package" = true || ("$currentChapter" != chapter07 && "$currentChapter" != chapter08) ]]; then
# create the function name to run - use this if not using arrangeOrder, i.e. chapters 5, 6, 10 and single_package
    awk '/_[[:space:]]\(\)[[:space:]]\{/ {print $1}' $Output >> $Output
  else # 7, 8 and update
    arrangeOrder $scriptName $currentChapter
  fi
  chmod 700 $Output # make it executable and if chapter07, asroot and chroot as well
  if [ "$currentChapter" = chapter07 ]; then
    if ! $installBinTarfile; then chmod 700 ${LFS}/${currentChapter}{-asroot.sh,-chroot.sh}; fi
  fi
done # end of currentChapter in $reqChaps
# make sure the script is using useThisKernelVers
if [ "$BOOK_VERSION" = trunk ]; then
  if [ ! -z "$useThisKernelVers" ]; then
    if [ ! -z "$linuxcomvers" ]; then
      if [ "$linuxcomvers" != "$useThisKernelVers" ]; then
        sed -e "s/$linuxcomvers/$useThisKernelVers/g" -i $Output
      fi
    fi
    if [ ! -z "$linuxvers" ]; then
      if [ "$linuxvers" != "$useThisKernelVers" ]; then
        sed -e "s/$linuxvers/$useThisKernelVers/g" -i $Output
      fi
    fi
  fi
fi
#
# remove tests if not requested
if [ "$TESTS" = no ]; then
  echo "TESTS is set to no"
  case $WHICH_CHAPTER in
     chapter10) # no tests in 10
       :
     ;;
     *)
       removeTests $scriptName
     ;;
  esac
fi
#
if [[ "$WHICH_CHAPTER" = chapter05 || "$WHICH_CHAPTER" = chapter06 ]]; then
# make sure the build dir exists for chapter05/06.sh and set owner to lfs if installing as root
  if [ ! -d $buildDir ]; then
    mkdir -pv $buildDir
    if $as_root; then chown lfs $buildDir; fi
  else
    if $as_root; then chown lfs $buildDir; fi
  fi
fi
if [[ "$useDESTDIR" = true && ("$currentChapter" = chapter07 || "$currentChapter" = chapter08) ]]; then # use DESTDIR
  sed -e 's/make install/make DESTDIR="$CUR_DIR" install/' \
      -e 's/make prefix=\/usr install/make prefix="${CUR_DIR}"\/usr install/' \
      -e 's/-i \/usr\/bin\/ldd/-i "${CUR_DIR}"\/usr\/bin\/ldd/' \
      -i $Output
fi
IFS=$IFSOLD # put it back the way it was
} # end Start
#
getMd5sumInfo () {
# returns information from the md5sums file
# if $1 is "pkgVers", returns the package version
# if $1 is "patchName", returns the patch name
# $2 is the array of package names and patch names from the md5sums file
# $3 is the search string to find the required package name or patch name
local srcFile patchName
local searchStr=$3
if [ -z "$3" ]; then return $RETURN_PARAM; fi
# check if the array of package and patch names is given
if [ ! -z "$2" ]; then
  local SrcName=$2[@]
  local srcname=("${!SrcName}")
  if [ "$1" = pkgVers ]; then
    for srcFile in ${srcname[@]}; do
      case $srcFile in
         $searchStr)
           rtrvers=""
#msg "*** CALLING GetPkgVersion, srcFile is $srcFile ***"
           GetPkgVersion "" $srcFile ".tar"
           if [ "$?" = 0 ]; then
             echo $rtrvers
             break
           else
             echo "return value from GetPkgVersion is $?"
             echo "Investigate why this didn't work"
             exit 1
           fi
           break
         ;;
      esac
    done
  elif [ "$1" = patchName ]; then
    for srcFile in ${srcname[@]}; do # need the name of the patch
      case $srcFile in
         $searchStr)
           patchName=$srcFile
           echo "$patchName"
           break
         ;;
      esac
    done
  else # $1 not either pkgVers or patchName, abort
    return $RETURN_PARAM
  fi
else
  return $RETURN_PARAM
fi
} # end getMd5sumInfo
#
getPatchName () {
# if the patch is to be downloaded at install time, then need the patch name
# this is obtained from the md5sums file
# $1 is the source name array
# $2 is the search string for the patch file e.g. bzip2-*.patch
# if present $3 is the location of the dir containing the source files and patches
local SrcName=$1[@]
local srcname=("${!SrcName}")
local searchName=$2
local sourceDir=${3:-""}
local patchName=""
if [ ! -z "$sourceDir" ]; then # use the source directory
  rtrvers=""
#msg "*** CALLING GetPkgVersion, searchName is $searchName ***"
  GetPkgVersion $sourceDir $searchName "" "" patch returnName
  patchName=$rtrvers
  echo "$patchName"
else # use the srcname array
  for srcFile in ${srcname[@]}; do # need the name of the patch
    case $srcFile in
       $searchName)
         patchName=$srcFile
         echo "$patchName"
         break
       ;;
    esac
  done
fi
if [ -z "$patchName" ]; then # didn't find the patch name - return error
  return $RETURN_PARAM
else # patch file found
  return 0
fi
} # end getPatchName
#
getLatestKernel () {
# get the latest kernel from the website
local URLtoUse="https://www.kernel.org"
declare -a klines=($(python3 BShref.py $URLtoUse))
if [ "$?" != 0 ]; then return $RETURN_PARAM; fi
#
local kernelURL=${klines[0]}
kernSrcFile=${kernelURL##*/} # global
rtrvers=""
kernLatestVers=""
#msg "*** CALLING GetPkgVersion, kernSrcFile is $kernSrcFile ***"
GetPkgVersion "" $kernSrcFile ".tar"
if [ "$?" = 0 ]; then
  if [ ! -z "$rtrvers" ]; then
    kernLatestVers=$rtrvers # global
    return 0
  else
    echo "rtrvers is NULL. Can't get the kernel version"
    echo "Investigate why this failed"
  fi
else
   echo "return value for kernel vers from GetPkgVersion is $? It should be zero"
   echo "Investigate why this didn't work"
fi
return $RETURN_OTHER_ERR
} # end getLatestKernel
#
getLinuxFile () {
# linux-headers is installed in chapter05 in the /build directory
# if this dir exists, get the linux tarfile name
local lhBuildDir="${buildDir}/linuxheaders"
if [ -d "$lhBuildDir" ]; then # dir exists
  local fileLoc=$(compgen -G "${lhBuildDir}/linux-[0-9]*.tar.?z*")
  local fileNameOnly=${fileLoc##*/}
  echo $fileNameOnly
  return 0
else
  return $RETURN_PARAM
fi
} # end getLinuxFile
#
getBinTarfileVers () {
# PkgUserDir is global for /usr/src/core
# $1 is the pkgname in the directory pkguserdir/pkgname
# $2 is the name at the beginning of the binary tarfile, usually pkgname but can be different
# this is the name to search for
# $3 if present, is the separator between the pkgname and the version number - usually "-"
# $4 if present, it is the section, i.e not core
local pkgname=$1
local serchName=$2
local separator=${3:-"-"}
local section=${4:-"core"}
local pkguserdir="/usr/src/${section}"
#msg "in getBinTarfileVers, pkgname is $pkgname"
#msg "serchName is $serchName"
#msg "section is $section"
#msg "pkguserdir is $pkguserdir"
local foundFile=""
local filenameOnly binTarfileVers
local binTarFileLoc="${pkguserdir}/${pkgname}/pkgbindir"
if [ -d "${LFS}${binTarFileLoc}" ]; then # directory exists
  foundFile=$(find ${LFS}${binTarFileLoc} -maxdepth 1 -name "${serchName}${separator}*-x86_64.pkg.tar.xz" -print -quit)
  if [ ! -z "$foundFile" ]; then
# get the version
    filenameOnly=${foundFile##*/}
    rtrvers=""
    GetPkgVersion "" $filenameOnly "-x86_64.pkg.tar.xz" "$separator"
    binTarfileVers=$rtrvers
    echo $binTarfileVers
    return 0
  else # foundFile is null
#    msg "*** No binary tarfile not found in ${LFS}${binTarFileLoc} ***"
#    msg "You need to create the binary tarfile for $SINGLE_PACKAGE"
    return $RETURN_FNF
  fi
else # no dir binTarFileLoc
#  msg "directory ${LFS}${binTarFileLoc} doesn't exist"
#  msg "You need to create the binary tarfile for $SINGLE_PACKAGE"
  return $RETURN_PARAM
fi
} # end getBinTarfileVers
#
#**********************************************************************************
#
# main program
#
#**********************************************************************************
# check if the user lfs exists on the target machine
if [ -e ${LFS}/etc/passwd ]; then
  chklfs=$(grep -c '^lfs:' ${LFS}/etc/passwd)
  if [ $chklfs -eq 1 ]; then
# get the uid
    useThisUID=$(grep '^lfs:' ${LFS}/etc/passwd | awk -F\: '{print $3}')
  else
    useThisUID="lfs" 
  fi
fi
configEdit # option to change the config file
source $cfg # maybe config edited - update the values
#
# check the config file values for consistency
#
# useproxy
useProxy=false
if [ "$USEPROXY" = yes ]; then useProxy=true; fi
#
printit=$PRINTIT
single_package=false
if [ "$SINGLE_PACKAGE" != no ]; then single_package=true; fi
#
make_kernel=false
useDESTDIR=false
installDEST=false
installBinTarfile=false
createBinFile=false
# make_kernel
if [ "$MAKE_KERNEL" = yes ]; then # check WHICH_CHAPTER
  if [ "$WHICH_CHAPTER" = chapter10 -o "$WHICH_CHAPTER" = update ]; then
    make_kernel=true
  else
    echo "MAKE_KERNEL is yes so WHICH_CHAPTER should either be chapter10 or update"
    echo "WHICH_CHAPTER is actually set to $WHICH_CHAPTER"
    echo "Change it to chapter10 if this is a fresh install or set it to"
    echo "update if this is an update of an existing kernel"
    echo "Abort"
    exit 1
  fi
fi
# check SINGLE_PACKAGE with MAKE_KERNEL and WHICH_CHAPTER
if $single_package; then
  if [[ "$WHICH_CHAPTER" != chapter07 && "$WHICH_CHAPTER" != chapter08 && "$WHICH_CHAPTER" != chapter10 && "$WHICH_CHAPTER" != update ]]; then
    echo "When using the SINGLE_PACKAGE option, WHICH_CHAPTER should be set to"
    echo "chapter07, 08, 10 or update. It is $WHICH_CHAPTER."
    echo "Set it to chapter07, 08, 10 or update to continue"
    echo "Aborting"
    exit 1
  fi
  if [ "$SINGLE_PACKAGE" = kernel ]; then
    if $make_kernel; then
      echo "Will create a binary tarfile for the kernel."
    else    
      echo "SINGLE_PACKAGE is set to kernel and MAKE_KERNEL is no"
      echo "This will do nothing"
      echo "Set MAKE_KERNEL=yes and make sure the .config file has been"
      echo "copied to $SOURCEDIR"
      exit 1
    fi
  else # check which chapter first
    if [ "$WHICH_CHAPTER" = chapter10 ]; then # chapter10 is for the kernel
      echo "WHICH_CHAPTER is chapter10 but SINGLE_PACKAGE is $SINGLE_PACKAGE"
      echo "You need to set WHICH_CHAPTER to the chapter in the book for this single package"
      echo "or set SINGLE_PACKAGE to kernel"
      echo "Abort"
      exit 1
    fi
    if [ "$DESTDIR" = no ]; then # check if INSTALLDEST is yes
      if [ "$INSTALLDEST" = yes ]; then # will install a binary tarfile
        echo "Will install a binary tarfile for $SINGLE_PACKAGE"
        installBinTarfile=true
      else # INSTALLDEST=no
        echo "DESTDIR=no and INSTALLDEST=no"
        echo "The SINGLE_PACKAGE option is meant to be used with DESTDIR"
        echo "in order to create a binary package tarfile for $SINGLE_PACKAGE"
        echo "Will set DESTDIR=yes and WHICH_CHAPTER=update"
        DESTDIR="yes"
        WHICH_CHAPTER=update
      fi
    else # use DESTDIR
# check CLEAN_SRC_DIR
      if [[ "$CLEAN_SRC_DIR" == no ]]; then
        echo "You've chosen to create a package binary from $SINGLE_PACKAGE"
        echo "but CLEAN_SRC_DIR is set to no. This will be set to yes to continue"
        CLEAN_SRC_DIR=yes
      fi
    fi
  fi
else # not single_package
# check if installing from binary tarfile(s)
  if [ "$DESTDIR" = yes ]; then useDESTDIR=true; fi
  if [ "$INSTALLDEST" = yes ]; then installDEST=true; fi
  if $installDEST && ! $useDESTDIR; then
    installBinTarfile=true
# check which chapter is asked for 
    if [ "$WHICH_CHAPTER" = update ]; then
      if $make_kernel; then
        echo "Will install a binary tarfile for the kernel"
      else
        echo "Will install any binary tarfiles for the packages in chapter08"
        echo "This will include linux-headers which will be added to chapter08"
      fi
    elif [ "$WHICH_CHAPTER" = chapter07 -o "$WHICH_CHAPTER" = chapter08 ]; then
      echo "Will install any binary tarfiles for the packages in $WHICH_CHAPTER"
    elif [ "$WHICH_CHAPTER" = chapter10 ]; then
      echo "Will install a binary tarfile for the kernel in chapter10"
    else
      echo "When installing from existing binary tarfile(s),"
      echo "WHICH_CHAPTER should be chapter07, chapter08, chapter10 or update"
      echo "It is currently $WHICH_CHAPTER"
      echo "Please set WHICH_CHAPTER correctly"
      echo "Aborting"
      exit 1
    fi
  fi
  if ! $installBinTarfile; then # check the rest of the config file
# check SOURCES and UPDATESRCFILES
    if [[ "$SOURCES" = atinstall && "$UPDATESRCFILES" = yes ]]; then
      echo "You've set SOURCES = atinstall. The sources will be downloaded using the"
      echo "md5sums file from the book. These are the latest versions"
      echo "UPDATESRCFILES will be set to no"
      UPDATESRCFILES=no
    fi
#
    if $make_kernel; then # check the .config file is in place
      if [[ "$WHICH_CHAPTER" = chapter10 || "$WHICH_CHAPTER" = update ]]; then
        if [ ! -e ${SOURCEDIR}/.config ]; then
          echo "MAKE_KERNEL is yes but the Kernel .config file is not in $SOURCEDIR"
          echo "Place it there to continue or set MAKE_KERNEL=no"
          exit 1
        else # .config in place
          if [ "$WHICH_CHAPTER" = chapter10 ]; then
            echo "The .config file is in $SOURCEDIR so the kernel can be installed"
          elif [ "$WHICH_CHAPTER" = update ]; then
            echo "The .config file is in $SOURCEDIR so the kernel can be updated"
          fi
        fi
      else
        echo "MAKE_KERNEL is set to yes so WHICH_CHAPTER should be either"
        echo "chapter10 or update, but it is $WHICH_CHAPTER"
        echo "Use chapter10 if this is a fresh install"
        echo "Use update if a kernel is installed and you are updating it"
        echo "Either change WHICH_CHAPTER or set MAKE_KERNEL to no if you"
        echo "actually want $WHICH_CHAPTER."
        echo "Aborting"
        exit 1
      fi
    else # MAKE_KERNEL=no
      if [[ "$WHICH_CHAPTER" = chapter10 && "$DESTDIR" = yes ]]; then
        echo "WHICH_CHAPTER=chapter10, MAKE_KERNEL=no and DESTDIR=yes"
        echo "This will do nothing. If you want to use DESTDIR, set MAKE_KERNEL=yes"
        echo "Aborting"
        exit 1
      fi
    fi
# check DESTDIR
    if $useDESTDIR; then # check which chapter specified
      if [[ "$WHICH_CHAPTER" = chapter05 || "$WHICH_CHAPTER" = chapter06 ]]; then
        echo "You cannot use DESTDIR in chapters 5 and 6. This is because"
        echo "DESTDIR=\$LFS in these chapters, so you cannot change it."
        echo "You can use DESTDIR once you have entered chroot."
        echo "Set WHICH_CHAPTER to chapter07, 08, 10 or update"
        echo "Aborting"
        exit 1
      else
        if ! $single_package; then echo "Files for chapter $WHICH_CHAPTER will be created using DESTDIR"; fi
      fi
      if $installDEST; then
        echo "installDEST is true so the files will be installed"
        echo "No package binary tarfiles will be created"
      else # INSTALLDEST=no
        if $single_package; then
         echo "installDEST is false so a binary tarfile will be created for"
         echo "single package $SINGLE_PACKAGE"
       else
         if [ "$WHICH_CHAPTER" = chapter10 ]; then
           echo "installDEST is false so a binary tarfile will be created for the kernel"
         else
           echo "installDEST is false so a binary tarfile will be created for each"
           echo "package in $WHICH_CHAPTER"
         fi
       fi
       createBinFile=true
     fi
    else # DESTDIR=no, so check INSTALLDEST
      if ! $installDEST; then
        echo "Files for $WHICH_CHAPTER will be compiled and installed"
      fi
    fi
  fi # test installBinTarfile
fi # test single_package
#
# check the value of WHICH_CHAPTER and set the initial values of Chapter and
# currentChapter to control the addition of commands for packages not in the book
WHICH_CHAPTER=$(echo ${WHICH_CHAPTER,,*}) # make sure it's lower case
# check the chapter name
case $WHICH_CHAPTER in
   chapter05|chapter06|chapter07|chapter08|chapter10|update)
     : # continue
   ;;
   *)
     echo "Invalid value for WHICH_CHAPTER. $WHICH_CHAPTER not allowed"
     echo "Should be one of chapter05, chapter06, chapter07, chapter08, chapter10, or update"
     echo "Exiting now"
     exit 1
   ;;
esac
if [ "$WHICH_CHAPTER" = update ]; then
  currentChapter=chapter08
  Chapter=update
else
  currentChapter=$WHICH_CHAPTER
  Chapter=$WHICH_CHAPTER
fi
#
if $printit; then msg "CLEAN_SRC_DIR is $CLEAN_SRC_DIR"; fi
if $printit; then msg "WHICH_CHAPTER is $WHICH_CHAPTER"; fi
#
as_root=false
if [ "$AS_ROOT" = yes ]; then # make sure lfs can write to BuildLog if not updating
  as_root=true
  if [ "$WHICH_CHAPTER" != update ]; then chown lfs ${LFS}/${BuildLog}; fi
else # root is owner of BuildLog when installing as a pkguser
  chown root:install ${LFS}/${BuildLog}
  chmod 664 ${LFS}/${BuildLog}
fi
wgetlist=$WGETLISTNAME # the name of the wget-list file
#
# set up the script filenames
ch5script="chapter05.sh"
ch6script="chapter06.sh"
ch7asroot="chapter07-asroot.sh"
ch7chroot="chapter07-chroot.sh"
ch7script="chapter07.sh"
ch8script="chapter08.sh"
ch10script="chapter10.sh"
updateScript="update.sh"
#
# check if installing as root
if [ "$AS_ROOT" = yes ]; then # test which chapter
  if [ "$WHICH_CHAPTER" = chapter05 -o "$WHICH_CHAPTER" = chapter06 ]; then # install as user lfs
    echo "*** INFORMATION ***"
    echo "You've chosen to install as root and WHICH_CHAPTER is $WHICH_CHAPTER"
    echo "This chapter will be installed as user lfs"
    echo "Do you wish to continue [Y/n]?"
    read REPLY
      case $REPLY in
         [nN]|[nN][Oo])
            echo "Okay, aborting"
            exit 1
         ;;
         *)
            echo "Okay, continuing"
         ;;
      esac
  fi
fi
#
# get the requested book
#
haveCommands=false
bookDir=$LFS_BOOK_GIT_LOC_DIR
version=$BOOK_VERSION
# set version properly
case $version in
   */)
     version=${version%?} # remove trailing / if present
   ;;
   SYSTEMD|Systemd|systemd) # not okay - abort
     echo "The book version should not be systemd."
     echo "To use systemd, set BOOK_VERSION=trunk and SYSTEMD=yes in the menu."
     exit 1
   ;;
   Current_Development|trunk)
     version="trunk"
   ;;
esac
if [ ! -d $bookDir ]; then mkdir -pv $bookDir; fi
if [ "$BOOK_ORIGIN" = git ]; then # download the book regardless of whether one exists
  if [ -d "${bookDir}/${trunkDIR}" ]; then rm -rf -v ${bookDir}/${trunkDIR}; fi
# download the book - check if git is installed on the host
    if [ -e "/usr/bin/git" ]; then
      git clone "${GIT_URL}/lfs.git" "${bookDir}/${trunkDIR}/lfs"
      echo "need to make the requested version current"
    else
      echo "you will have to install git on the host"
      echo "Abort"
      exit 1
    fi
elif [ "$BOOK_ORIGIN" = local ]; then # check if the commands are in place
  whichChapter=$WHICH_CHAPTER
  if [ "$whichChapter" = update ]; then # need to test chapter08
    whichChapter="chapter08"
  fi
  if [ -d "${DumpedCommands}/${whichChapter}" ]; then # $lfscommands dir exists, check if empty
    if [ "$(ls -A ${DumpedCommands}/${whichChapter})" ]; then
      haveCommands=true
    else
      echo "The directory ${DumpedCommands}/${whichChapter} is empty"
      echo "Did you download the book?"
      echo "Aborting"
      exit 1
    fi
  elif [ -d "${bookDir}/${trunkDIR}/lfs" ]; then # book present
    echo "local book found at ${bookDir}/${trunkDIR}/lfs"
    if [ "$version" != blank ]; then
      echo "will make sure the requested version $version is current"
    else # blank
      echo "choose which book version to use"
    fi
  else
    echo "No commands found for $whichChapter"
    echo "You need to download the book commands"
    echo "Aborting"
    exit 1
  fi
else
  echo "BOOK_ORIGIN should be git or local, but it is $BOOK_ORIGIN"
  echo "Aborting"
  exit 1
fi
# if got here then a book is in place and/or commands exist in lfs-commands on the target machine
if ! $haveCommands; then # need to dump the commands from the book
# need to make the requested version current
  foundVersion=false
  if [ "$version" != blank ]; then
# is the requested branch already available?
    pushd "${bookDir}/${trunkDIR}/lfs" > /dev/null
      branches=$(git branch)
      echo "branches is $branches"
      for branch in $branches; do
        case $branch in
           *$version) # make sure it is set
             git checkout $version
             foundVersion=true
             break
           ;;
        esac
      done
    popd > /dev/null
    if ! $foundVersion; then
      pushd "${bookDir}/${trunkDIR}/lfs" > /dev/null
        git fetch --all # get access to all the remore branches
        branches=$(git branch -a)
        echo "book branches found are $branches"
        echo "version requested is $version"
# compare existing branches with requested book version
        for branch in $branches; do
          case $branch in
             *$version) # make sure it is set
               git checkout $version
               foundVersion=true
               break
             ;;
          esac
        done
        if ! $foundVersion; then
          echo "didn't find $version in remote branches - investigate"
          echo "Abort"
          exit 1
        fi
      popd > /dev/null
    fi
  else # version is blank - ask which version wanted
    WhichLFSBook
    echo "book version requested is $BOOK_VERSION"
    case $BOOK_VERSION in
       Current_Development)
         BOOK_VERSION="trunk"
       ;;
       *)
         if [[ "$BOOK_VERSION" == [0-9]* ]]; then # should be 10.0 or higher
           testIntFloatChar $BOOK_VERSION
           retval=$?
           if [ $retval -eq 89 -o $retval -eq 93 ]; then
             echo "BOOK_VERSION should be a floating point number >= 10.0"
             exit 1
           elif [ $retval -eq 91 ]; then # compare two floats
             if awk "BEGIN {exit !($BOOK_VERSION >= 10.0)}"; then
               echo "Book version $BOOK_VERSION requested" # check if trunk is in place
               if [ -f "${LFS_BOOK_GIT_LOC_DIR}/${trunkDIR}/lfs/.git" ]; then # ok
                 echo "found lfs trunk in ${LFS_BOOK_GIT_LOC_DIR}/${trunkDIR}/lfs - can continue"
                 echo "will git checkout version $BOOK_VERSION"
                 pushd ${LFS_BOOK_GIT_LOC_DIR}/${trunkDIR}/lfs > /dev/null
       	           git checkout $BOOK_VERSION
                 popd > /dev/null
               else
                 echo "didn't find downloaded book in ${LFS_BOOK_GIT_LOC_DIR}/${trunkDIR}/lfs"
                 echo "you need to download the trunk version of the book first"
                 echo "Aborting"
                 exit 1
               fi
             else
               echo "Book version is $BOOK_VERSION, should be 10.0 or higher"
               echo "Aborting"
               exit 1
             fi
           fi
         fi
       ;;
    esac
  fi
# check that lfs: is in the book Makefile
  destin="${LFS_BOOK_GIT_LOC_DIR}/${trunkDIR}/lfs"
  if grep -q "lfs:" "${destin}/Makefile"; then
    echo "the string \"lfs\" is in ${destin}/Makefile"
  else
    sed -i '/book:/i lfs: book wget-list\n' "${destin}/Makefile"
  fi
# remove the # from commented-out dump-commands
# * NOTE * - as of 09/2022 these commands have been uncommented - thanks Pierre
#
#  lineStart=$(grep -nr "#dump-commands" "${destin}/Makefile" | cut -d : -f1)
#  if [ ! -z "$lineStart" ]; then
#    lineEnd=$((lineStart+14))
#    echo "lineStart is $lineStart"
#    echo "lineEnd is $lineEnd"
#    sed -i "${lineStart},${lineEnd} s/^#//" "${destin}/Makefile"
#  fi
#
  DumpCommands $REPO $bookDir "trunk" #parse the LFS xml
# check that the commands were dumped to dir lfs-commands
  if [ "$(ls -A ${DumpedCommands}/${whichChapter})" ]; then
    haveCommands=true
  else
    echo "Dir ${DumpedCommands}/${whichChapter} doesn't exist or is empty"
    echo "INVESTIGATE why DumpCommands didn't work"
    echo "Aborting"
    exit 1
  fi
#
fi # test haveCommands is false
# if chapter06 then add additional commands for openssl and wget
retVal=1
if [ "$currentChapter" = chapter06 ]; then
  declare -a opensslComs
  opensslComs[0]="./config --prefix=/usr         \\"
  opensslComs[1]="         --openssldir=/etc/ssl \\"
  opensslComs[2]="         --libdir=lib          \\"
  opensslComs[3]="         shared"
  opensslComs[4]="sed -i '/install_docs:/s/install_man_docs install_html_docs//' Makefile"
  opensslComs[5]="make"
  opensslComs[6]="sed -i '/INSTALL_LIBS/s/libcrypto.a libssl.a//' Makefile"
  opensslComs[7]="make DESTDIR=\$LFS MANSUFFIX=ssl install"
  addCommands "openssl" "058" "chapter06" opensslComs[@]
  retVal=$?
  if [ $retVal -eq $RETURN_PARAM ]; then
    echo "didn't find ${DumpedCommands}/${currentChapter}"
    echo "did you download the book?"
    echo "*** failed to add the commands for openssl"
    echo "Investigate why this failed"
  else
    echo "Commands for openssl are in ${DumpedCommands}/${currentChapter}"
  fi
  declare -a wgetComs
  wgetComs[0]="PKG_CONFIG_PATH=\$LFS/usr/lib/pkgconfig    \\"
  wgetComs[1]="./configure --prefix=/usr                 \\"
  wgetComs[2]="            --sysconfdir=/etc             \\"
  wgetComs[3]="            --with-ssl=openssl            \\"
  wgetComs[4]="            --without-libpsl              \\"
  wgetComs[5]="            --without-zlib                \\"
  wgetComs[6]="            --disable-iri                 \\"
  wgetComs[7]="            --disable-pcre                \\"
  wgetComs[8]="            --disable-pcre2               \\"
  wgetComs[9]="            --host=\$LFS_TGT               \\"
  wgetComs[10]="            --build=\$(build-aux/config.guess)"
  wgetComs[11]="make"
  wgetComs[12]="make DESTDIR=\$LFS install"
  addCommands "wget" "059" "chapter06" wgetComs[@]
  retVal=$?
  if [ $retVal -eq $RETURN_PARAM ]; then
    echo "didn't find ${DumpedCommands}/${currentChapter}"
    echo "did you download the book?"
    echo "*** failed to add the commands for wget"
    echo "Investigate why this failed"
  else
    echo "Commands for wget are in ${DumpedCommands}/${currentChapter}"
  fi
elif [ "$currentChapter" = chapter08 ]; then # add commands for py3-flit-core and py3-installer
  if [ ! -e ${DumpedCommands}/${currentChapter}/151-flit ]; then
    declare -a flitComs
    flitComs[0]="python3 -m pip install flit-core"
    addCommands "flit" "151" "chapter08" flitComs[@]
    retVal=$?
    if [ $retVal -eq $RETURN_PARAM ]; then
      echo "didn't find ${DumpedCommands}/${currentChapter}"
      echo "did you download the book?"
      echo "*** failed to add the commands for py3-flit ***"
      echo "Investigate why this failed"
    elif [[ $retVal -eq 0 ]]; then
      echo "Commands for py3-flit are in ${DumpedCommands}/${currentChapter}"
    fi
  else
    echo "Commands for py3-flit are in ${DumpedCommands}/${currentChapter}"
  fi
  if [ ! -e ${DumpedCommands}/${currentChapter}/152-installer ]; then
    declare -a installerComs
    installerComs[0]="python3 -m pip install installer"
    addCommands "installer" "152" "chapter08" installerComs[@]
    retVal=$?
    if [ $retVal -eq $RETURN_PARAM ]; then
      echo "didn't find ${DumpedCommands}/${currentChapter}"
      echo "did you download the book?"
      echo "*** failed to add the commands for py3-installer ***"
      echo "Investigate why this failed"
    elif [[ $retVal -eq 0 ]]; then
      echo "Commands for py3-installer are in ${DumpedCommands}/${currentChapter}"
    fi
  else
    echo "Commands for py3-installer are in ${DumpedCommands}/${currentChapter}"
  fi
# if update then add commands to chapter08 for linux-headers (installed in chapter05 but needed for update)
  if [ "$Chapter" = update ]; then
    if ! $make_kernel; then
      if [ ! -e ${DumpedCommands}/${currentChapter}/071-linux-headers ]; then
        declare -a comsToAdd
        comsToAdd[0]="make mrproper"
        comsToAdd[1]="make headers"
        comsToAdd[2]="find usr/include -type f ! -name '*.h' -delete"
        comsToAdd[3]="cp -rv usr/include /usr"
        addCommands "linux-headers" "071" "chapter08" comsToAdd[@]
        retVal=$?
        if [ $retVal -eq $RETURN_PARAM ]; then
          echo "didn't find ${DumpedCommands}/${currentChapter}"
          echo "did you download the book?"
          echo "*** failed to add the commands for linux-headers ***"
          echo "Investigate why this failed"
        elif [[ $retVal -eq 0 ]]; then
          echo "Commands for linux-headers are in ${DumpedCommands}/${currentChapter}"
        fi
      else
        echo "Commands for linux-headers are in ${DumpedCommands}/${currentChapter}"
      fi
    fi
  fi
fi
# set isSystemdBook
isSystemdBook=false # use sysv
VersToCompare=10.0 # first book that will work here
if [ "$SYSTEMD" = yes ]; then
  if [ "$version" = trunk ]; then
    isSystemdBook=true
  else
    compare_versions $VersToCompare $version "."
    ret_val=$?
    if [ $ret_val -eq 0 ]; then
      isSystemdBook=true
    else
      echo "version is set to $version"
      echo "This version will not work with these scripts."
      echo "Abort"
      exit 1
    fi
  fi
fi
echo "isSystemdBook is $isSystemdBook"
# install the pkguser files
pkgFileName="${PKGUSERFILE%.tar*}" # the name of the unpacked package file dir
# check if the ${LFS}/tools/${pkgFileName} dir exists
PKGFILENAME="${LFS}/tools/${pkgFileName}"
if [ ! -d "$PKGFILENAME" ]; then # doesn't exist so try and build it
# is there a tar package file present?
  if [ -e ${LFS}${sourcedir}/${PKGUSERFILE} ]; then # unpack it
    unpackPkguser $PKGUSERFILE
    if [ $? -eq $RETURN_PARAM ]; then # pkguser file failed to unpack
      echo "Package user file $PKGUSERFILE in ${LFS}${sourcedir}"
      echo "failed to unpack. Is it a tarfile?"
      echo "Exiting now"
      exit 1
    fi
  else
    echo "The tarfile $PKGUSERFILE should be in ${LFS}${sourcedir}"
    echo "Please place it there in order to continue"
    echo "Exiting now"
    exit 1
  fi
else # the dir $PKGFILENAME exists - test if the tafile is present
  if [ -e ${LFS}${sourcedir}/${PKGUSERFILE} ]; then # ask if want to replace the build files
    echo "**Warning** - $PKGUSERFILE present and $PKGFILENAME exists."
    echo "Replace $PKGFILENAME with the contents of $PKGUSERFILE? [Y/n]"
    read reply
      case $reply in
         [nN]|[nN][Oo])
            echo "okay - continuing with existing $PKGFILENAME"
         ;;
         *)
            echo "okay replacing $PKGFILENAME"
            echo "will rm PKGFILENAME and remake it"
            rm -rf $PKGFILENAME
            mkdir -pv $PKGFILENAME
            unpackPkguser $PKGUSERFILE
         ;;
      esac
  else # PKGFILENAME exists
    echo "pkguser dir $PKGFILENAME exists"
  fi
fi
#
# get the sources
#
wgetopts=""
ncc="--no-check-certificate"
# is a proxy server being used?
if $useProxy; then
# test if squid is present
  if [ -e /usr/bin/squid ]; then
# first set the proxy values - assumes port 3128
#
    ipaddr=$( /sbin/ip addr | grep "192.168" | awk '{print $2}' | awk -F\/ '{print $1}' )
    proxyset=http://${ipaddr}:3128/
    http_proxy=$proxyset
    ftp_proxy=$proxyset
    https_proxy=$proxyset
    wgetopts="-e http_proxy=$http_proxy -e ftp_proxy=$ftp_proxy -e https_proxy=$https_proxy"
  else # squid not installed
    useProxy=false
  fi
fi # end test useProxy
# declare a global array to hold any missing src file names
declare -a filesNotPresent
#
version=${version%/} # remove any trailing /
SourceDir=${SOURCEDIR}/${version}
sourceloc=${sourcedir}/${version} # location wrt lfs system
WgetList=${SourceDir}/${wgetlist}
#if [ ! -e $WgetList ]; then
#  echo "wget-list file $WgetList doesn't exist"
#  echo "will get it from the book" 
#fi
#
# if SINGLE_PACKAGE requested, check if the package src file is in the wget-list file
# if it isn't, try and download it
#
if $single_package; then
  if $printit; then msg "single_package is $single_package"; fi
  if $printit; then msg "SINGLE_PACKAGE is $SINGLE_PACKAGE"; fi
#  msg "installBinTarfile is $installBinTarfile"
# sometimes the pkgname is different from the src filename
  separator="-"
  case $SINGLE_PACKAGE in
     expect)
       filesNotPresent[0]=expect5
       separator="."
     ;;
     linux-headers)
       filesNotPresent[0]=linux
     ;;
     kernel)
       filesNotPresent[0]=linux
     ;;
     tcl)
       filesNotPresent[0]=tcl8
       separator="."
     ;;
     xml-parser)
       filesNotPresent[0]=XML-Parser
     ;;
     *)
       filesNotPresent[0]=$SINGLE_PACKAGE
     ;;
  esac
  if $installBinTarfile; then # check if the binary tarfile exists and get pkgVers
    binTarfileVers=$(getBinTarfileVers $SINGLE_PACKAGE $SINGLE_PACKAGE $separator "")
    retval=$?
    if [ $retval -eq $RETURN_PARAM ]; then # pkgbindir not present
      echo "No binary tarfile found for package $SINGLE_PACKAGE"
    elif [ $retval -eq $RETURN_FNF ]; then # no binary tarfile found
      echo "No binary tarfile found for package $SINGLE_PACKAGE"
    elif [ $retval -eq 0 ]; then # found
      echo "binary tarfile found for package $SINGLE_PACKAGE"
      if $printit; then msg "binTarfileVers is $binTarfileVers"; fi
    fi
    rtrnName=""
    if [ ! -e $WgetList ]; then
      echo "$WgetList file doesn't exist"
      if [ "$SOURCES" = atinstall ]; then
        if $printit; then msg "Will get the $WgetList file from the downloaded book"; fi
      else
        if $printit; then msg "You need to download the source for $SINGLE_PACKAGE and place in $SourceDir"; fi
      fi
    else # wget-list in place so check single package exists
      if [ "$SOURCES" != atinstall ]; then
#        echo "filesNotPresent is ${filesNotPresent[@]}"
        ChkPkgExists $WgetList filesNotPresent[@]
        retval=$?
        if [ $retval -eq $RETURN_PARAM ]; then # wget-list file doesn't exist
          echo "No $WgetList file present"
          echo "Will download the source for ${filesNotPresent[0]}"
        elif [ $retval -eq $RETURN_FNF ]; then
          echo "${filesNotPresent[0]} not found in $WgetList"
          echo "Check the package name"
          exit 1
        else
          filesNotPresent[0]=$rtrnName
        fi
      fi
    fi
# check if source(s) already downloaded
    if [ "$SOURCES" = download ]; then
#      echo "single package is ${filesNotPresent[0]}"
      if [ ! -d $SourceDir ]; then install -v -m0755 -d $SourceDir; fi
      if [ "$CLEAN_SRC_DIR" = yes ]; then CleanSourceDir $SourceDir $WgetList; fi
      if [ -e $WgetList ]; then
        ChkSrcPresent $SourceDir $WgetList filesNotPresent[@]
        ret_val=$?
        if [ $ret_val -eq 0 ]; then
          echo "Package ${filesNotPresent[0]} present in $SourceDir"
          echo "Continuing without downloading ${filesNotPresent[0]}"
        else
          echo "Package file ${filesNotPresent[0]} not present in $SourceDir"
          echo "Will download it using $WgetList file"
          if hash wget 2>/dev/null; then
             GetSource $version $SourceDir $WgetList $bookDir filesNotPresent[@] # download LFS sources
          else
             echo "The host does not have wget installed."
             echo "Please install it in order to download the source(s)."
             echo "Exiting now."
             exit 1
          fi
        fi
      else # no wget-list present so need to get it
        if hash wget 2>/dev/null; then
          GetSource $version $SourceDir $WgetList $bookDir filesNotPresent[@] # download LFS sources
        else
           echo "The host does not have wget installed."
           echo "Please install it in order to download the source(s)."
           echo "Exiting now."
           exit 1
        fi
      fi
    elif [ "$SOURCES" != atinstall ]; then # source is local - check it's there
      echo "Checking if source file is in $SourceDir"
      if [ ! -d $SourceDir ]; then
        echo "You have said that the source is local but"
        echo "directory $SourceDir does not exist"
        echo "Change the config file to make SOURCES = 'download'"
        echo "or download it yourself and place in $SourceDir"
        echo "Will continue to write the requested script."
      fi
      if [ ! -e $WgetList ]; then
        echo "No $WgetList file present in $SourceDir"
        echo "Won't be able to check if the source file exists"
      else
        ChkSrcPresent $SourceDir $WgetList filesNotPresent[@] # check for src file present
        ret_val=$?
        if [ $ret_val -eq $RETURN_PARAM ]; then
          echo "Requested file ${filesNotPresent[0]} has not been downloaded"
          echo "Can download it and place in $SourceDir"
          echo "Do you wish to continue? (Y/n)"
          read reply
          case $reply in
            [nN]|[nN][Oo])
              echo "Exiting now"
              exit 1
            ;;
            *)
              echo "okay will download the source file"
# TODO download the single_package file here
            ;;
          esac
        else
          echo "Source file ${filesNotPresent[0]} present in $SourceDir"
        fi
      fi
    else # SOURCES=atinstall
      if $printit; then msg "SOURCES=atinstall Will check that the wget-list and md5sums files are present"; fi
#      msg "filesNotPresent is ${filesNotPresent[0]}"
      if [ ! -d $SourceDir ]; then install -v -m0755 -d $SourceDir; fi
      if [ ! -e $WgetList ]; then
        if $printit; then msg "the wget-list file $WgetList doesn't exist. Will get it from the downloaded book"; fi
        REPODIR="${bookDir}/${trunkDIR}/lfs"
        if $printit; then msg "REPODIR is $REPODIR"; fi
        make -j1 -f ${REPODIR}/Makefile -C $REPODIR BASEDIR=$SourceDir REV="systemd" $WgetList ${SourceDir}/md5sums
        md5sums=${SourceDir}/md5sums
      else
        if $printit; then msg "wget-list file $WgetList is in place"; fi
      fi
      if [ -z "$md5sums" ]; then md5sums=${SourceDir}/md5sums; fi
      if [ ! -e $md5sums ]; then
        if $printit; then msg "the md5sums file $md5sums doesn't exist. Will get it from the downloaded book"; fi
      else
       if $printit; then msg "md5sums file $md5sums is in place"; fi
      fi
    fi
# check if the file is empty
    if [ "$SOURCES" != atinstall ]; then
      ChkEmptySrcFiles $SourceDir ${filesNotPresent[0]} #check for failed downloads
      return_val=$?
      if [ "$return_val" -eq $RETURN_FNF ]; then
        echo "Source file ${filesNotPresent[0]} not found in $SourceDir"
        echo "Check why it's not there"
        exit 1
      elif [ "$return_val" -eq $RETURN_PARAM ]; then
        echo "Source file ${filesNotPresent[0]} is empty."
        echo "You need to download this file and place it in $SourceDir"
        echo "before running the script"
      fi
    fi
  fi
  listPkgs=($SINGLE_PACKAGE)
else # all sources requested
  if $installBinTarfile; then
    : #don't require any source files
  else
    downloadSrc=false
    if [ ! -d $SourceDir ]; then install -v -m0755 -d $SourceDir; fi
    if [ "$SOURCES" = atinstall ]; then # need the wget-list file and the md5sums
      if [ ! -e $WgetList ]; then # wget-list doesn't exist, get it from the book
        REPODIR="${bookDir}/${trunkDIR}/lfs"
        if $printit; then msg "REPODIR is $REPODIR"; fi
        make -j1 -f ${REPODIR}/Makefile -C $REPODIR BASEDIR=$SourceDir REV="systemd" $WgetList ${SourceDir}/md5sums
        md5sums=${SourceDir}/md5sums
      else
        echo "$WgetList file exists"
# make sure the md5sums file is present too
        if [ ! -e  ${SourceDir}/md5sums ]; then # get it from $LFS/lfs-html
          echo "the md5sums file isn't present in $SourceDir"
          echo "will copy it from $LFS/lfs-html"
          cp -v $LFS/lfs-html/md5sums ${SourceDir}/md5sums
          md5sums=${SourceDir}/md5sums
        else
          echo "md5sums file found in $SourceDir"
          md5sums=${SourceDir}/md5sums
        fi
      fi
    elif [ "$SOURCES" = download ]; then
      downloadSrc=true 
      if [ "$CLEAN_SRC_DIR" = yes ]; then CleanSourceDir $SourceDir $WgetList; fi
# check if src dir is not empty and the wgetlist file is already in place
#      if [[ "$(ls -A $SourceDir)" && -e $WgetList ]]; then
      if [ -e $WgetList ]; then
        ChkSrcPresent $SourceDir $WgetList filesNotPresent[@] # check for src files present
        ret_val=$?
        if [ $ret_val -eq 0 ]; then # all files are present
          echo "You requested 'download' for the sources"
          echo "but they are already present in $SourceDir"
          if [ "$UPDATESRCFILES" = yes ]; then
            echo "Will download any more-recent source files and update $WgetList."
          else
            echo "Continuing without updating any source files."
          fi
          downloadSrc=false
        else
          echo "Will download the following files:"
          for (( i=0; i<${#filesNotPresent[@]}; i++ )); do
            echo ${filesNotPresent[i]}
          done
        fi
      fi
      if [ "$UPDATESRCFILES" = yes ]; then
        if [ -e ${WgetList} ]; then
#msg "*** CALLING GetLatestVers CHECK THIS WORKS ***"
          GetLatestVers $WgetList "lfs-systemd" true false # download latest source files and update wget-list
        else
          echo "You've requested an update of the source files but there is no existing file $WgetList"
          echo "Cannot update source versions without this file"
        fi
      fi
      if $downloadSrc; then
        echo "Will use wget to download the sources"
        if hash wget 2>/dev/null; then
           GetSource $version $SourceDir $WgetList $bookDir filesNotPresent[@] # download LFS sources
# now search for any older versions of the downloaded files and offer to delete them
           for chkFiles in ${filesNotPresent[@]}; do
#echo "downloaded file is $chkFiles"
             pkgnmOnly=$(GetPkgName $chkFiles)
#msg "*** CALLING GetPkgVersion, pkgnmOnly is $pkgnmOnly ***"
             GetPkgVersion $SourceDir $pkgnmOnly- ".tar"
             generalfname=${pkgnmOnly}*.tar.?z* # NOTE amend for fname without tar
             olderVers=( $(ls -l ${SourceDir}/${generalfname} | awk -F\/ '{print $NF}') )
             numoldvers=${#olderVers[@]}
             if [ $numoldvers -eq 1 ]; then # only one version present - good, do nothing
               :
             elif [ $numoldvers -gt 1 ]; then
               echo "There is more than one version of package $pkgnmOnly in $SourceDir"
               for (( ik=0; ik < $numoldvers; ik++ )); do
                 if [ "${olderVers[ik]}" != "$chkFiles" ]; then # delete it?
                   echo "Do you want to delete ${olderVers[ik]} (Default is Y)"
                   read reply
                   case $reply in
                      [yY]|[yY][Ee][Ss])
                          rm -v ${SourceDir}/${olderVers[ik]}
                      ;;
                      [nN]|[nN][Oo])
                          echo "okay, ${SourceDir}/${olderVers[ik]} left in place"
                      ;;
                      *)
                          rm -v ${SourceDir}/${olderVers[ik]}
                      ;;
                   esac
                 fi
               done
             elif [ $numoldvers -eq 0 ]; then # HELP something's gone wrong
               echo "ERROR - numoldvers=0 . This should never happen. ABORT"
               exit 1
             fi
           done
        else
           echo "The host does not have wget installed."
           echo "Please install it in order to download the sources."
           echo "Exiting now."
           exit 1
        fi
      fi
      ChkEmptySrcFiles $SourceDir # check for failed downloads
      return_val=$?
      if [ "$return_val" -eq $RETURN_FNF ]; then
        echo "Source file ${filesNotPresent[0]} not found in $SourceDir"
        echo "Check why it's not there"
        exit 1
      elif [ "$return_val" -eq $RETURN_PARAM ]; then
        echo "Empty source files found in $SourceDir"
        echo "You need to download these and place them in $SourceDir"
        echo "before running the scripts"
      fi
    else # sources are local - check if update of source files is requested
      echo "Checking if sources are in $SourceDir"
      if [ ! -d $SourceDir ]; then
        echo "You have said that the sources are local but"
        echo "directory $SourceDir does not exist"
        echo "Change the config file to make SOURCES=download"
        echo "or download them yourself and place in $SourceDir"
        echo "Will continue to write the requested script(s)."
      fi 
      if [ ! -e $WgetList ]; then
        echo "No $WgetList file present in $SourceDir"
        echo "Won't be able to check if LFS sources exist"
        if [ "$UPDATESRCFILES" = yes ]; then
          echo "Won't be able to update the sources files"
        fi
      else # wget-list file exists
        if [ "$UPDATESRCFILES" = yes ]; then
#msg "*** CALLING GetLatestVers CHECK THIS WORKS ***"
          GetLatestVers $WgetList "lfs-systemd" true false # download latest source files and update wget-list
        fi
        ChkSrcPresent $SourceDir $WgetList filesNotPresent[@] # check for src files present
        ret_val=$?
        if [ $ret_val -eq $RETURN_PARAM ]; then 
          echo "Not all requested files in $WgetList have been downloaded"
          echo "You will have to download those that are missing and place them in $SourceDir"
          echo "Do you wish to continue? (Y/n)"
          read reply
          case $reply in
            [yY]|[yY][Ee][Ss])
              echo "okay continue"
            ;;        
            [nN]|[nN][Oo])
              echo "Exiting now"
              exit 1
            ;;        
            *)   
              echo "okay continue"
            ;;        
          esac
        fi
      fi
# check if $SourceDir exists and has files in it
      if [ -d $SourceDir ]; then
        if [ "$(ls -A $SourceDir)" ]; then # has files
          ChkEmptySrcFiles $SourceDir # check for failed downloads
          return_val=$?
          if [ "$return_val" -eq $RETURN_FNF ]; then
            echo "Source file ${filesNotPresent[0]} not found in $SourceDir"
            echo "Check why it's not there"
            exit 1
          elif [ "$return_val" -eq $RETURN_PARAM ]; then
            echo "Empty source files found in $SourceDir"
            echo "You need to download these and place them in $SourceDir"
            echo "before running the scripts"
          fi
        fi
      else
        echo "Source Dir $SourceDir doesn't exist. Will create it"
        mkdir -pv $SourceDir
      fi
    fi
  fi
fi # test if single_package
#
# make sure Chapter is set
Chapter=$WHICH_CHAPTER
if $installBinTarfile; then
  : # continue
else
  if [ -d $SourceDir -a "$(ls -A $SourceDir)" ]; then # source dir exists and has files in it
    if $printit; then msg "source dir $SourceDir exists and contains files"; fi
# get src versions for all the following plus any patch file names
    listPkgs=(bzip2 coreutils dbus elfutils flit gcc glibc gmp installer kbd kernel mpc mpfr ncurses perl python3 readline shadow systemd tcl util-linux xz zstd)
    if [ ! -f $WgetList ]; then
      echo "The required wget-list file does not exist"
      echo "You need the file $WgetList in order to continue"
      echo "Aborting"
      exit 1
    fi
# add the urls for flit and installer if not present
    foundFlit=""
    foundInstaller=""
    foundFlit=$(grep -rn "flit" $WgetList)
    foundInstaller=$(grep -rn "installer" $WgetList)
    if [[ "$Chapter" = chapter08 || "$Chapter" = update ]]; then
      if [ -z "$foundFlit" ]; then
        echo 'https://github.com/pypa/flit/archive/refs/tags/3.7.1.tar.gz' >> $WgetList
        if $printit; then msg "added the URL for flit to the wget-list file"; fi
      else
        if $printit; then msg "The URL for flit is in $WgetList"; fi
      fi
    fi
    if [[ "$Chapter" = chapter08 || "$Chapter" = update ]]; then
      if [ -z "$foundInstaller" ]; then
        echo 'https://github.com/pypa/installer/archive/refs/tags/0.5.1.tar.gz' >> $WgetList
        if $printit; then msg "added the URL for installer to the wget-list file"; fi
      else
        if $printit; then msg "The URL for installer is in $WgetList"; fi
      fi
    fi
# read the contents of the wget-list file into a variable for the src downloads
    sourceURL="$(<"$WgetList")"
#    echo "sourceURL is ${sourceURL[@]}"
    if [[ "$SOURCES" = atinstall ]]; then
      if [ ! -f $md5sums ]; then
        echo "The required md5sums file does not exist"
        echo "You need the file $md5sums in order to continue"
        echo "Aborting"
        exit 1
      fi
# read the contents of the md5sums file into a variable to get pkg versions
      srcFileName="$(<"$md5sums")"
#  echo "srcFileName is ${srcFileName[@]}"
      echo "Requested source files downloaded at install time."
      echo "The src package versions will come from the md5sums file,"
      echo "not from the actual src tarfiles."
    fi
# get the required package versions and patch filenames
    for (( i=0; i<${#listPkgs[@]}; i++ )); do
#msg "listPkgs is ${listPkgs[i]}"
      case ${listPkgs[i]} in
         bash)
           getbashPatch=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = bash ]; then getbashPatch=true; fi
           elif [ "$Chapter" = chapter08 -o "$Chapter" = update ]; then
             getbashPatch=true
           fi
           if $getbashPatch; then
             patchSearch='*bash*.patch*'
             if [ "$SOURCES" = atinstall ]; then # use md5sums
               bashPatch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
             else # use the src dir
               bashPatch=$(getPatchName "" $patchSearch $SourceDir)
               bashPatch=${bashPatch1##*/} # just the filename
             fi
             ret_val=$?
             if [ $ret_val -eq $RETURN_PARAM ]; then
               echo "failed to get bash patch name"
               echo "*** Investigate ***"
             else
               echo "bash patch is $bashPatch"
             fi
           fi
         ;;
         binutils)
           patchSearch='*binutils*.patch*'
           if [ "$SOURCES" = atinstall ]; then # use md5sums
             binutilsPatch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
           else # use the src dir
              binutilsPatch=$(getPatchName "" $patchSearch $SourceDir)
              binutilsPatch=${binutilsPatch##*/} # just the filename
           fi
           ret_val=$?
           if [ $ret_val -eq $RETURN_PARAM ]; then
             echo "failed to get binutils patch name"
             echo "*** Investigate ***"
           else
             echo "binutils patch is $binutilsPatch"
           fi
         ;;
         bzip2)
           getbzip2Patch=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = bzip2 ]; then getbzip2Patch=true; fi
           elif [ "$Chapter" != chapter07 -a "$Chapter" != chapter10 ]; then
             getbzip2Patch=true
           fi
           if $getbzip2Patch; then
             patchSearch='*bzip2*.patch*'
             if [ "$SOURCES" = atinstall ]; then # use md5sums
               bzip2Patch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
             else # use the src dir
               bzip2Patch=$(getPatchName "" $patchSearch $SourceDir)
               bzip2Patch=${bzip2Patch##*/} # just the filename
             fi
             ret_val=$?
             if [ $ret_val -eq $RETURN_PARAM ]; then
               echo "failed to get bzip2 patch name"
               echo "*** Investigate ***"
             else
               echo "bzip2 patch is $bzip2Patch"
             fi
             searchStr="*bzip2-*"
             bzip2vers=""
             if [ "$SOURCES" = atinstall ]; then # use the md5sums file
               bzip2vers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
               if [ ! -z "$bzip2vers" ]; then
                 echo "bzip2 version is $bzip2vers"
               else
                 echo "return value for bzip2 is $?"
                 echo "Investigate why this didn't work"
                 exit 1
               fi
             else
               rtrvers=""
#msg "*** CALLING GetPkgVersion, srcFile is bzip2 ***"
               GetPkgVersion $SourceDir bzip2- ".tar"
               retval=$?
               if [ $retval -eq $RETURN_PARAM ]; then
                 echo "*** Directory $SourceDir doesn't exist ***"
               elif [ $retval -eq $RETURN_FNF ]; then
                 echo "*** No file found containing the name bzip2- and tar found ***"
               elif [ $retval -eq $RETURN_MTOV ]; then
                 echo "*** More than one version of bzip2- found in $SourceDir ***"
               elif [ $retval -eq 0 ]; then
                 bzip2vers=$rtrvers
                 if [ ! -z "$bzip2vers" ]; then echo "bzip2 version is $bzip2vers"; fi
               fi
             fi
           fi
         ;;
         coreutils)
           getcoreutilsPatch=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = coreutils ]; then getcoreutilsPatch=true; fi
           elif [ "$Chapter" != chapter07 -a "$Chapter" != chapter10 ]; then
	     getcoreutilsPatch=true
           fi
           if $getcoreutilsPatch; then
             patchSearch1='*coreutils*i18n*.patch*'
             if [ "$SOURCES" = atinstall ]; then # use md5sums
               coreutilsPatch1=$(getMd5sumInfo "patchName" srcFileName $patchSearch1)
             else # use the src dir
               coreutilsPatch1=$(getPatchName "" $patchSearch1 $SourceDir)
               coreutilsPatch1=${coreutilsPatch1##*/} # just the filename
             fi
             ret_val=$?
             if [ $ret_val -eq $RETURN_PARAM ]; then
               echo "failed to get coreutils patch name"
               echo "*** Investigate ***"
             else
               echo "coreutils patch is $coreutilsPatch1"
             fi
#             patchSearch2='*coreutils*chmod*.patch*' # no longer needed 05/2022
#             if [ "$SOURCES" = atinstall ]; then # use md5sums
#               coreutilsPatch2=$(getMd5sumInfo "patchName" srcFileName $patchSearch2)
#             else # use the src dir
#               coreutilsPatch2=$(getPatchName "" $patchSearch2 $SourceDir)
#               coreutilsPatch2=${coreutilsPatch2##*/} # just the filename
#             fi
#             ret_val=$?
#             if [ $ret_val -eq $RETURN_PARAM ]; then
#               echo "failed to get coreutils patch name"
#               echo "*** Investigate ***"
#             else
#               echo "coreutils patch is $coreutilsPatch2"
#             fi
           fi
         ;;
         dbus)
           getdbusVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = dbus ]; then getdbusVers=true; fi
           elif [ "$Chapter" != chapter07 -a "$Chapter" != chapter10 ]; then
             getdbusVers=true
           fi
           if $getdbusVers; then
             searchStr="*dbus-*"
             dbusvers=""
             if [ "$SOURCES" = atinstall ]; then # use the md5sums file
               dbusvers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
               if [ ! -z "$dbusvers" ]; then
                 echo "dbus version is $dbusvers"
               else
                 echo "return value for dbus is $?"
                 echo "Investigate why this didn't work"
                 exit 1
               fi
             elif [ "$SYSTEMD" = yes ]; then # use the src files in $SourceDir
               rtrvers=""
               for srcFile in ${srcFileName[@]}; do
                 case $srcFile in
                    $searchStr)
                      rtrvers=""
                      dbusvers=""
#msg "*** CALLING GetPkgVersion, srcFile is $srcFile ***"
                      GetPkgVersion "" $srcFile ".tar"
                      if [ "$?" = 0 ]; then
                        dbusvers=$rtrvers
                        if [ ! -z "$dbusvers" ]; then echo "dbus version is $dbusvers"; fi
                      else
                        echo "return value for dbus is $?"
                        echo "Investigate why this didn't work"
                      fi
                      break
                    ;;
                 esac
               done
               dbusvers=""
#msg "*** CALLING GetPkgVersion, srcFile is dbus ***"
               GetPkgVersion $SourceDir dbus- ".tar"
               retval=$?
               if [ $retval -eq $RETURN_PARAM ]; then
                 echo "*** Directory $SourceDir doesn't exist ***"
               elif [ $retval -eq $RETURN_FNF ]; then
                 echo "*** No file found containing the name dbus- and tar found ***"
               elif [ $retval -eq $RETURN_MTOV ]; then
                 echo "*** More than one version of dbus- found in $SourceDir ***"
               elif [ $retval -eq 0 ]; then
                 dbusvers=$rtrvers
                 if [ ! -z "$dbusvers" ]; then echo "dbus version is $dbusvers"; fi
               fi
             fi
           fi
         ;;
         elfutils|libelf)
           getelfutilsVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = elfutils -o "$SINGLE_PACKAGE" = libelf ]; then getelfutilsVers=true; fi
           elif [ "$Chapter" != chapter07 -a "$Chapter" != chapter10 ]; then
             getelfutilsVers=true
           fi
           if $getelfutilsVers; then
             searchStr="*elfutils-*"
             elfutilsvers=""
             if [ "$SOURCES" = atinstall ]; then # use the md5sums file
               elfutilsvers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
               if [ ! -z "$elfutilsvers" ]; then
                 echo "elfutils version is $elfutilsvers"
               else
                 echo "return value for elfutils is $?"
                 echo "Investigate why this didn't work"
                 exit 1
               fi
             else
               rtrvers=""
#msg "*** CALLING GetPkgVersion, srcFile is elfutils- ***"
               GetPkgVersion $SourceDir elfutils- ".tar"
               retval=$?
               if [ $retval -eq $RETURN_PARAM ]; then
                 echo "*** Directory $SourceDir doesn't exist ***"
               elif [ $retval -eq $RETURN_FNF ]; then
                 echo "*** No file found containing the name elfutils- and tar found ***"
               elif [ $retval -eq $RETURN_MTOV ]; then
                 echo "*** More than one version of elfutils- found in $SourceDir ***"
               elif [ $retval -eq 0 ]; then
                 elfutilsvers=$rtrvers
                 if [ ! -z "$elfutilsvers" ]; then echo "elfutils version is $elfutilsvers"; fi
               fi
             fi
           fi
         ;;
         flit|py3-flit-core)
           getflitVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = flit -o "$SINGLE_PACKAGE" = py3-flit-core ]; then getflitVers=true; fi
           elif [ "$Chapter" = chapter08 -o "$Chapter" = update ]; then
             getflitVers=true
           fi
           if $getflitVers; then
             if [ "$SOURCES" = atinstall ]; then # use the wget-list file
               flitUrl=$(grep -rn "flit" $WgetList)
               flitFile=${flitUrl##*/}
               trimto=".tar"
               flitVers="${flitFile%${trimto}*}"
               echo "flit version is $flitVers"
             fi
           fi
         ;;
         gcc)
           getgccVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = gcc ]; then getgccVers=true; fi
           elif [ "$Chapter" != chapter07 -a "$Chapter" != chapter10 ]; then
             getgccVers=true
           fi
           if $getgccVers; then
             searchStr="*gcc-*"
             gccvers=""
             if [ "$SOURCES" = atinstall ]; then # use the md5sums file
               gccvers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
               if [ ! -z "$gccvers" ]; then
                 echo "gcc version is $gccvers"
               else
                 echo "return value for gcc is $?"
                 echo "Investigate why this didn't work"
                 exit 1
               fi
             else
               rtrvers=""
#msg "*** CALLING GetPkgVersion, srcFile is gcc- ***"
               GetPkgVersion $SourceDir gcc- ".tar"
               retval=$?
               if [ $retval -eq $RETURN_PARAM ]; then
                 echo "*** Directory $SourceDir doesn't exist ***"
               elif [ $retval -eq $RETURN_FNF ]; then
                 echo "*** No file found containing the name gcc- and tar found ***"
               elif [ $retval -eq $RETURN_MTOV ]; then
                 echo "*** More than one version of gcc- found in $SourceDir ***"
               elif [ $retval -eq 0 ]; then
                 gccvers=$rtrvers
                 if [ ! -z "$gccvers" ]; then echo "gcc version is $gccvers"; fi
               fi
             fi
           fi
         ;;
         glibc) # needs a patch
           getglibcVers=false 
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = glibc ]; then getglibcVers=true; fi
           elif [ "$Chapter" != chapter07 -a "$Chapter" != chapter10 ]; then
             getglibcVers=true
           fi
           if $getglibcVers; then
             patchSearch='*glibc*.patch*'
             if [ "$SOURCES" = atinstall ]; then # use md5sums
               glibcPatch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
               ret_val=$?
               if [ $ret_val -eq $RETURN_PARAM ]; then
                 echo "failed to get glibc patch name"
                 echo "*** Investigate ***"
               else
                 echo "glibc patch is $glibcPatch"
               fi
# get the glibc pkg version
               searchStr="*glibc-*"
               glibcvers=""
               glibcvers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
               if [ ! -z "$glibcvers" ]; then
                 echo "glibc version is $glibcvers"
               else
                 echo "return value for glibc is $?"
                 echo "Investigate why this didn't work"
                 exit 1
               fi
             else # use the source dir to get the pkg version and patch name
               glibcPatch=$(getPatchName "" $patchSearch $SourceDir)
               glibcPatch=${glibcPatch##*/} # just the filename
               ret_val=$?
               if [ $ret_val -eq $RETURN_PARAM ]; then
                 echo "failed to get glibc patch name"
                 echo "*** Investigate ***"
               else
                 echo "glibc patch is $glibcPatch"
               fi
               rtrvers=""
               glibcvers=""
#msg "*** CALLING GetPkgVersion, srcFile is glibc ***"
               GetPkgVersion $SourceDir glibc- ".tar"
               retval=$?
               if [ $retval -eq $RETURN_PARAM ]; then
                 echo "*** Directory $SourceDir doesn't exist ***"
               elif [ $retval -eq $RETURN_FNF ]; then
                 echo "*** No file found containing the name glibc- and tar found ***"
               elif [ $retval -eq $RETURN_MTOV ]; then
                 echo "*** More than one version of glibc- found in $SourceDir ***"
               elif [ $retval -eq 0 ]; then
                 glibcvers=$rtrvers
                 if [ ! -z "$glibcvers" ]; then
                   echo "glibc version is $glibcvers"
                 else
                   echo "Failed to get glibc version"
                   echo "You'll need to rectify this or manually edit the script."
                 fi
               fi
             fi
# need to know the name of the tzdata file from the commands
             tzdataFile=$(GetLinuxCommandVersion "${LFS}/${lfscommands}/chapter08" "glibc" "tzdata")
             echo "tzdata file is $tzdataFile"
           fi
         ;;
         gmp) # need the version if downloading at install time
           getgmpVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = gmp ]; then getgmpVers=true; fi
           elif [ "$Chapter" != chapter07 -a "$Chapter" != chapter10 ]; then
             getgmpVers=true
           fi
           if $getgmpVers; then
             searchStr="*gmp-*"
             gmpvers=""
             if [ "$SOURCES" = atinstall ]; then # use the md5sums file
               gmpvers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
               if [ ! -z "$gmpvers" ]; then
                 echo "gmp version is $gmpvers"
               else
                 echo "return value for gmp is $?"
                 echo "Investigate why this didn't work"
                 exit 1
               fi
             else # use source dir
               rtrvers=""
#msg "*** CALLING GetPkgVersion, srcFile is gmp- ***"
               GetPkgVersion $SourceDir gmp- ".tar"
               retval=$?
               if [ $retval -eq $RETURN_PARAM ]; then
                 echo "*** Directory $SourceDir doesn't exist ***"
               elif [ $retval -eq $RETURN_FNF ]; then
                 echo "*** No file found containing the name gmp- and tar found ***"
               elif [ $retval -eq $RETURN_MTOV ]; then
                 echo "*** More than one version of gmp- found in $SourceDir ***"
               elif [ $retval -eq 0 ]; then
                 gmpvers=$rtrvers
                 if [ ! -z "$gmpvers" ]; then echo "gmp version is $gmpvers"; fi
               fi
             fi
           fi
         ;;
         installer|py3-installer)
           getinstallerVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = installer -o "$SINGLE_PACKAGE" = py3-installer ]; then getinstallerVers=true; fi
           elif [ "$Chapter" = chapter08 -o "$Chapter" = update ]; then
             getinstallerVers=true
           fi
           if $getinstallerVers; then
             if [ "$SOURCES" = atinstall ]; then # use the wget-list file
               installerUrl=$(grep -rn "installer" $WgetList)
               installerFile=${installerUrl##*/}
               trimto=".tar"
               installerVers="${installerFile%${trimto}*}"
               echo "installer version is $installerVers"
             fi
           fi
         ;;
         kbd) # get a patch
           getkbdVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = kbd ]; then getkbdVers=true; fi
           elif [ "$Chapter" != chapter07 -a "$Chapter" != chapter10 ]; then
             getkbdVers=true
           fi
           if $getkbdVers; then
             patchSearch='*kbd*.patch*'
             if [ "$SOURCES" = atinstall ]; then # use md5sums
               kbdPatch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
             else # use the src dir
               kbdPatch=$(getPatchName "" $patchSearch $SourceDir)
               kbdPatch=${kbdPatch##*/} # just the filename
             fi
             ret_val=$?
             if [ $ret_val -eq $RETURN_PARAM ]; then
               echo "failed to get kbd patch name"
               echo "*** Investigate ***"
             else
               echo "kbd patch is $kbdPatch"
             fi
           fi
         ;;
         kernel|linux-headers)
           getlinuxVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = kernel -o "$SINGLE_PACKAGE" = "linux-headers" ]; then getlinuxVers=true; fi
           elif [ "$Chapter" = chapter05 -o "$Chapter" = chapter10 ]; then
             getlinuxVers=true
           fi
           if $getlinuxVers; then
             searchStr="*linux-*"
             linuxvers=""
             if [ "$SOURCES" = atinstall ]; then # use the md5sums file
               linuxvers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
               if [ ! -z "$linuxvers" ]; then
                 echo "kernel version from md5sum is $linuxvers"
               else
                 echo "return value for kernel is $?"
                 echo "Investigate why this didn't work"
                 exit 1
               fi
             else
               GetLinuxVersion $SourceDir
               retval=$?
               if [ $retval -eq $RETURN_PARAM ]; then
                 echo "Unable to get Linux source version."
                 echo "No source file found in $SourceDir"
                 echo "**Warning** - value of kernel Src version is not set"
               else
                 echo "kernel version from src dir is $linuxvers"
               fi
             fi
# get the kernel version if one is installed
             rtrvers=""
             linuxInstallVers=""
             linuxInstalled=false
#msg "*** CALLING GetPkgVersion, srcFile is linux-*.tar.?z* ***"
             installCode=".ch10kernel"
             if [ -e "${LFS}${PkgUserDir}/kernel/${installCode}" ]; then
               GetPkgVersion "${LFS}${PkgUserDir}/kernel" "linux-*.tar.?z*" ".tar"
               retval=$?
               if [ $retval -eq $RETURN_FNF ]; then
                 echo "*** No linux src file found in ${LFS}${PkgUserDir}/kernel ***"
                 echo "The installed kernel version is NULL"
               elif [ $retval -eq $RETURN_MTOV ]; then
                 echo "*** More than one version of linux- found in ${LFS}${PkgUserDir}/kernel ***"
                 echo "delete all but one in order to continue"
                 echo "Aborting"
                 exit 1
               elif [ $retval -eq 0 ]; then
                 linuxInstallVers=$rtrvers
                 if [ ! -z "$linuxInstallVers" ]; then
                   echo "kernel version installed is $linuxInstallVers"
                   linuxInstalled=true
                 else
                   echo "linuxInstallVers is NULL"
                   echo "Investigate why this failed"
                 fi
               fi
             else
               echo "The kernel has not been installed yet"
             fi
# get the linux version from the book commands in chapter10
             linuxcomfnd=$(GetLinuxCommandVersion ${LFS}/${lfscommands}/chapter10 "kernel" "vmlinuz")
             retval=$?
             if [ $retval -eq $RETURN_PARAM ]; then
               echo "vmlinuz command not found in ${LFS}/${lfscommands}/chapter10"
               echo "Cannot get the kernel version in the book."
               echo "Will not be able to compare the source version and the book version"
             else
               linuxcomExt="${linuxcomfnd#*-}"
               linuxcomvers="${linuxcomExt%-lfs*}"
               echo "kernel version from the commands is $linuxcomvers"
             fi
             if [ "$linuxvers" != "$linuxcomvers" ]; then
               if $printit; then msg "*** WARNING *** Linux version from the srcfile is different from the book"; fi
             fi
           fi
         ;;
         mpc) # need the version if downloading at install time
           getmpcVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = mpc ]; then getmpcVers=true; fi
           elif [ "$Chapter" != chapter07 -a "$Chapter" != chapter10 ]; then
             getmpcVers=true
           fi
           if $getmpcVers; then
             searchStr="*mpc-*"
             mpcvers=""
             if [ "$SOURCES" = atinstall ]; then # use the md5sums file
               mpcvers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
               if [ ! -z "$mpcvers" ]; then
                 echo "mpc version is $mpcvers"
               else
                 echo "return value for mpc is $?"
                 echo "Investigate why this didn't work"
                 exit 1
               fi
             else # use source dir
               rtrvers=""
#msg "*** CALLING GetPkgVersion, srcFile is mpc- ***"
               GetPkgVersion $SourceDir mpc- ".tar"
               retval=$?
               if [ $retval -eq $RETURN_PARAM ]; then
                 echo "*** Directory $SourceDir doesn't exist ***"
               elif [ $retval -eq $RETURN_FNF ]; then
                 echo "*** No file found containing the name mpc- and tar found ***"
               elif [ $retval -eq $RETURN_MTOV ]; then
                 echo "*** More than one version of mpc- found in $SourceDir ***"
               elif [ $retval -eq 0 ]; then
                 mpcvers=$rtrvers
                 if [ ! -z "$mpcvers" ]; then echo "mpc version is $mpcvers"; fi
               fi
             fi
           fi
         ;;
         mpfr) # need the version if downloading at install time
           getmpfrVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = mpfr ]; then getmpfrVers=true; fi
           elif [ "$Chapter" != chapter07 -a "$Chapter" != chapter10 ]; then
             getmpfrVers=true
           fi
           if $getmpfrVers; then
             searchStr="*mpfr-*"
             mpfrvers=""
             if [ "$SOURCES" = atinstall ]; then # use the md5sums file
               mpfrvers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
               if [ ! -z "$mpfrvers" ]; then
                 echo "mpfr version is $mpfrvers"
               else
                 echo "return value for mpfr is $?"
                 echo "Investigate why this didn't work"
                 exit 1
               fi
             else # use source dir
               rtrvers=""
#msg "*** CALLING GetPkgVersion, srcFile is mpfr- ***"
               GetPkgVersion $SourceDir mpfr- ".tar"
               retval=$?
               if [ $retval -eq $RETURN_PARAM ]; then
                 echo "*** Directory $SourceDir doesn't exist ***"
               elif [ $retval -eq $RETURN_FNF ]; then
                 echo "*** No file found containing the name mpfr- and tar found ***"
               elif [ $retval -eq $RETURN_MTOV ]; then
                 echo "*** More than one version of mpfr- found in $SourceDir ***"
               elif [ $retval -eq 0 ]; then
                 mpfrvers=$rtrvers
                 if [ ! -z "$mpfrvers" ]; then echo "mpfr version is $mpfrvers"; fi
               fi
             fi
           fi
         ;;
         ncurses) # need the version
           getncursesVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = ncurses ]; then getncursesVers=true; fi
           elif [ "$Chapter" != chapter07 -a "$Chapter" != chapter10 ]; then
             getncursesVers=true
           fi
           if $getncursesVers; then
             searchStr="*ncurses-*"
             ncursesvers=""
             if [ "$SOURCES" = atinstall ]; then # use the md5sums file
               ncursesvers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
               if [ ! -z "$ncursesvers" ]; then
                 echo "ncurses version is $ncursesvers"
               else
                 echo "return value for ncurses is $?"
                 echo "Investigate why this didn't work"
                 exit 1
               fi
             else # use source dir
               rtrvers=""
#msg "*** CALLING GetPkgVersion, srcFile is ncurses- ***"
               GetPkgVersion $SourceDir ncurses- ".tar"
               retval=$?
               if [ $retval -eq $RETURN_PARAM ]; then
                 echo "*** Directory $SourceDir doesn't exist ***"
               elif [ $retval -eq $RETURN_FNF ]; then
                 echo "*** No file found containing the name ncurses- and tar found ***"
               elif [ $retval -eq $RETURN_MTOV ]; then
                 echo "*** More than one version of ncurses- found in $SourceDir ***"
               elif [ $retval -eq 0 ]; then
                 ncursesvers=$rtrvers
                 if [ ! -z "$ncursesvers" ]; then echo "ncurses version is $ncursesvers"; fi
               fi
             fi
           fi
         ;;
         perl) # no patch currently (03/2022)
           getperlVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = perl ]; then getperlVers=true; fi
           elif [ "$Chapter" = chapter07 -o "$Chapter" = chapter08 -o "$Chapter" = update ]; then
             getperlVers=true
           fi
           if $getperlVers; then
             patchSearch='*perl*.patch*'
             if [ "$SOURCES" = atinstall ]; then # use md5sums
#               perlPatch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
#               ret_val=$?
#               if [ $ret_val -eq $RETURN_PARAM ]; then
#                 echo "failed to get perl patch name"
#                 echo "*** Investigate ***"
#               else
#                 echo "perl patch is $perlPatch"
#               fi
# get the pkg version
               searchStr="*perl-*"
               perlvers=""
               perlvers=$(getMd5sumInfo "pkgVers" srcFileName $searchStr)
               if [ ! -z "$perlvers" ]; then
                 echo "perl version is $perlvers"
                 GetSeriesNum $perlvers
                 perlseries=$rtrseries
                 echo "perl series is $perlseries"
               else
                 echo "return value for perl is $?"
                 echo "Investigate why this didn't work"
                 exit 1
               fi
             else # use the source dir to get the patch name
#               perlPatch=$(getPatchName "" $patchSearch $SourceDir)
#               perlPatch=${perlPatch##*/} # just the filename
#               ret_val=$?
#               if [ $ret_val -eq $RETURN_PARAM ]; then
#                 echo "failed to get perl patch name"
#                 echo "*** Investigate ***"
#               else
#                 echo "perl patch is $perlPatch"
#               fi
               rtrvers=""
#msg "*** CALLING GetPkgVersion, srcFile is perl- ***"
               GetPkgVersion $SourceDir perl- ".tar"
               retval=$?
               if [ $retval -eq $RETURN_PARAM ]; then
                 echo "*** Directory $SourceDir doesn't exist ***"
               elif [ $retval -eq $RETURN_FNF ]; then
                 echo "*** No file found containing the name perl- and tar found ***"
               elif [ $retval -eq $RETURN_MTOV ]; then
                 echo "*** More than one version of perl- found in $SourceDir ***"
               elif [ $retval -eq 0 ]; then
                 perlvers=$rtrvers
                 if [ ! -z "$perlvers" ]; then
                   echo "perl version is $perlvers"
                   GetSeriesNum $perlvers
                   perlseries=$rtrseries
                   echo "perl series is $perlseries"
                 else # try a different source loc
                   if [ -d $LFS/sources/${trunkDIR} ]; then
#msg "*** CALLING GetPkgVersion, srcFile is perl- ***"
                     GetPkgVersion $LFS/sources/${trunkDIR} perl- "tar"
                     perlvers=$rtrvers
                     if [ ! -z "$perlvers" ]; then
                       echo "perl version is $perlvers"
                       GetSeriesNum $perlvers
                       perlseries=$rtrseries
                       echo "perl series is $perlseries"
                     fi
                   fi
                 fi
               fi
             fi
           fi
         ;;
         python3)
           getpythonVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = python3 ]; then getpythonVers=true; fi
           elif [ "$Chapter" = chapter07 -o "$Chapter" = chapter08 -o "$Chapter" = update ]; then
             getpythonVers=true
           fi
           if $getpythonVers; then
             if [ "$SOURCES" = atinstall ]; then # use the md5sums file
               for srcFile in ${srcFileName[@]}; do
                 case $srcFile in
                    *Python-*)
                      rtrvers=""
                      pythonvers=""
#msg "*** CALLING GetPkgVersion, srcFile is $srcFile ***"
                      GetPkgVersion "" $srcFile ".tar"
                      if [ "$?" = 0 ]; then
                        pythonvers=$rtrvers
                        if [ ! -z "$pythonvers" ]; then echo "python3 version is $pythonvers"; fi
                        GetSeriesNum $pythonvers
                        pythonseries=$rtrseries
                        echo "python3 series is $pythonseries"
                      else
                        echo "return value from GetPkgVersion for python3 is $?"
                        echo "Investigate why this didn't work"
                      fi
                      break
                    ;;
                 esac
               done
             else
               rtrvers=""
#msg "*** CALLING GetPkgVersion, srcFile is Python- ***"
               GetPkgVersion $SourceDir Python- ".tar"
               retval=$?
               if [ $retval -eq $RETURN_PARAM ]; then
                 echo "*** Directory $SourceDir doesn't exist ***"
               elif [ $retval -eq $RETURN_FNF ]; then
                 echo "*** No file found containing the name python- and tar found ***"
               elif [ $retval -eq $RETURN_MTOV ]; then
                 echo "*** More than one version of python- found in $SourceDir ***"
               elif [ $retval -eq 0 ]; then
                 pythonvers=$rtrvers
                 if [ ! -z "$pythonvers" ]; then
                   echo "python3 version is $pythonvers"
                   GetSeriesNum $pythonvers
                   pythonseries=$rtrseries
                   echo "python3 series is $pythonseries"
                 else # try a different source loc
                   if [ -d $LFS/sources/${trunkDIR} ]; then
#msg "*** CALLING GetPkgVersion, srcFile is Python- differnet src loc***"
                     GetPkgVersion $LFS/sources/${trunkDIR} Python- ".tar"
                     pythonvers=$rtrvers
                     if [ ! -z "$pythonvers" ]; then echo "python version is $pythonvers"; fi
                     GetSeriesNum $pythonvers
                     pythonseries=$rtrseries
                     echo "python3 series is $pythonseries"
                   else
                     echo "*** Warning - unable to get python version. No source found."
                   fi
                 fi
               fi
             fi
           fi
         ;;
         readline) # need a patch
           getreadlineVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = readline ]; then getreadlineVers=true; fi
           elif [ "$Chapter" = chapter08 -o "$Chapter" = update ]; then
             getreadlineVers=true
           fi
           if $getreadlineVers; then
             patchSearch='*readline*.patch*'
             if [ "$SOURCES" = atinstall ]; then # use md5sums
               readlinePatch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
             else # use the src dir
               readlinePatch=$(getPatchName "" $patchSearch $SourceDir)
               readlinePatch=${readlinePatch##*/} # just the filename
             fi
             ret_val=$?
             if [ $ret_val -eq $RETURN_PARAM ]; then
               echo "failed to get readline patch name"
               echo "*** Investigate ***"
             else
               echo "readline patch is $readlinePatch"
             fi
           fi
         ;;
         shadow) # currently (09/22) no shadow patch
           getshadowVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = shadow ]; then getshadowVers=true; fi
           elif [ "$Chapter" = chapter08 -o "$Chapter" = update ]; then
             getshadowVers=true
           fi
           if $getshadowVers; then
             patchSearch='*shadow*.patch*'
             if [ "$SOURCES" = atinstall ]; then # use md5sums
               shadowPatch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
             else # use the src dir
               shadowPatch=$(getPatchName "" $patchSearch $SourceDir)
               shadowPatch=${shadowPatch##*/} # just the filename
             fi
             ret_val=$?
             if [ $ret_val -eq $RETURN_PARAM ]; then
               echo "failed to get shadow patch name"
               echo "*** Investigate ***"
             else
               echo "shadow patch is $shadowPatch"
             fi
           fi
         ;;
         systemd) # need the man-pages and a patch
           getsystemdVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = systemd ]; then getsystemdVers=true; fi
           elif [ "$Chapter" = chapter08 -o "$Chapter" = update ]; then
             getsystemdVers=true
           fi
           if $getsystemdVers; then
             patchSearch='*systemd*.patch*'
             if [ "$SOURCES" = atinstall ]; then # use the md5sums file
               systemdPatch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
             else # use the src dir
               systemdPatch=$(getPatchName "" $patchSearch $SourceDir)
               systemdPatch=${systemdPatch##*/} # just the filename
             fi
             ret_val=$?
             if [ $ret_val -eq $RETURN_PARAM ]; then
               echo "failed to get systemd patch name"
               echo "*** Investigate ***"
             else
               echo "systemd patch is $systemdPatch"
             fi
             if [ "$SOURCES" = atinstall ]; then # use the md5sums file
               for srcFile in ${srcFileName[@]}; do
                 case $srcFile in
                    *systemd-[0-9]*.tar.?z*)
                      rtrvers=""
                      systemdvers=""
#msg "*** CALLING GetPkgVersion, srcFile is $srcFile ***"
                      GetPkgVersion "" $srcFile ".tar"
                      if [ "$?" = 0 ]; then
                        systemdvers=$rtrvers
                        if [ ! -z "$systemdvers" ]; then echo "systemd version is $systemdvers"; fi
                      else
                        echo "return value from GetPkgVersion for systemd is $?"
                        echo "Investigate why this didn't work"
                      fi
                    ;;
                    *systemd-man-pages-*) # need the name of the man-pages file
                      systemdManPages=$srcFile
                      echo "systemd man-pages file is $systemdManPages"
                    ;;
                 esac
               done
             else
               rtrvers=""
#msg "*** CALLING GetPkgVersion, srcFile is systemd-[0-9] ***"
               GetPkgVersion $SourceDir "systemd-[0-9]" ".tar"
               retval=$?
               if [ $retval -eq $RETURN_PARAM ]; then
                 echo "*** Directory $SourceDir doesn't exist ***"
               elif [ $retval -eq $RETURN_FNF ]; then
                 echo "*** No file found containing the name systemd- and tar found ***"
               elif [ $retval -eq $RETURN_MTOV ]; then
                 echo "*** More than one version of systemd- found in $SourceDir ***"
               elif [ $retval -eq 0 ]; then
                 systemdvers=$rtrvers
                 if [ ! -z "$systemdvers" ]; then echo "systemd version is $systemdvers"; fi
               fi
               rtrvers="" # get the systemd man-pages version from the source directory
#msg "*** CALLING GetPkgVersion, srcFile is systemd-man-pages- ***"
               GetPkgVersion $SourceDir "systemd-man-pages-" ".tar"
               systemdManPages=$rtrvers
               echo "systemd man-pages is $systemdManPages"
             fi
           fi
         ;;
         tcl)
           gettclVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = tcl ]; then gettclVers=true; fi
           elif [ "$Chapter" = chapter08 -o "$Chapter" = update ]; then
             gettclVers=true
           fi
           if $gettclVers; then
             if [ "$SOURCES" = atinstall ]; then # use the md5sums file
               for srcFile in ${srcFileName[@]}; do
                 case $srcFile in
                    *tcl8.*)
                      rtrvers=""
                      tclvers=""
#msg "*** CALLING GetPkgVersion, srcFile is $srcFile ***"
                      GetPkgVersion "" $srcFile "-src" "."
                      if [ "$?" = 0 ]; then
                        tclvers=$rtrvers
                        if [ ! -z "$tclvers" ]; then echo "tcl version is $tclvers"; fi
                      else
                        echo "return value from GetPkgVersion for tcl8 is $?"
                        echo "Investigate why this didn't work"
                      fi
                      break
                     ;;
                 esac
               done
             else
               rtrvers=""
#msg "*** CALLING GetPkgVersion, srcFile is tcl8. ***"
               GetPkgVersion $SourceDir tcl8. "-src.tar"
               retval=$?
               if [ $retval -eq $RETURN_PARAM ]; then
                 echo "*** Directory $SourceDir doesn't exist ***"
               elif [ $retval -eq $RETURN_FNF ]; then
                 echo "*** No file found containing the name tcl8. and tar found ***"
               elif [ $retval -eq $RETURN_MTOV ]; then
                 echo "*** More than one version of tcl8. found in $SourceDir ***"
               elif [ $retval -eq 0 ]; then
                 tclvers=$rtrvers
                 if [ ! -z "$tclvers" ]; then echo "tcl version is $tclvers"; fi
               fi
             fi
           fi
         ;;
         util-linux)
           getutillinuxVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = util-linux ]; then getutillinuxVers=true; fi
           elif [ "$Chapter" = chapter07 -o "$Chapter" = chapter08 -o "$Chapter" = update ]; then
             getutillinuxVers=true
           fi
           if $getutillinuxVers; then
             if [ "$SOURCES" = atinstall ]; then # use the md5sums file
               for srcFile in ${srcFileName[@]}; do
                 case $srcFile in
                    *util-linux-*)
                      rtrvers=""
                      utillinuxvers=""
#msg "*** CALLING GetPkgVersion, srcFile is $srcFile ***"
                      GetPkgVersion "" $srcFile ".tar"
                      if [ "$?" = 0 ]; then
                        utillinuxvers=$rtrvers
                        if [ ! -z "$utillinuxvers" ]; then echo "util-linux version is $utillinuxvers"; fi
                      else
                        echo "return value from GetPkgVersion for util-linux is $?"
                        echo "Investigate why this didn't work"
                      fi
                      break
                     ;;
                 esac
               done
             else
               rtrvers=""
#msg "*** CALLING GetPkgVersion, srcFile is util-linux- ***"
               GetPkgVersion $SourceDir util-linux- ".tar"
               retval=$?
               if [ $retval -eq $RETURN_PARAM ]; then
                 echo "*** Directory $SourceDir doesn't exist ***"
               elif [ $retval -eq $RETURN_FNF ]; then
                 echo "*** No file found containing the name util-linux- and tar found ***"
               elif [ $retval -eq $RETURN_MTOV ]; then
                 echo "*** More than one version of $util-linux found in $SourceDir ***"
               elif [ $retval -eq 0 ]; then
                 utillinuxvers=$rtrvers
                 if [ ! -z "$utillinuxvers" ]; then echo "util-linux version is $utillinuxvers"; fi
               fi
	     fi
           fi
         ;;
         xz) # currently (09/22) no patch for xz
           getxzVers=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = xz ]; then getxzVers=true; fi
           elif [ "$Chapter" != chapter07 -a "$Chapter" != chapter10 ]; then
             getxzVers=true
           fi
#           if $getmpfrVers; then
#             patchSearch='*xz*.patch*'
#             if [ "$SOURCES" = atinstall ]; then # use md5sums
#               xzPatch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
#             else # use the src dir
#               xzPatch=$(getPatchName "" $patchSearch $SourceDir)
#               xzPatch=${zstdPatch##*/} # just the filename
#             fi
#             ret_val=$?
#             if [ $ret_val -eq $RETURN_PARAM ]; then
#               echo "failed to get xz patch name"
#               echo "*** Investigate ***"
#             else
#               echo "xz patch is $xzPatch"
#             fi
#           fi
         ;;
         zstd) # need a patch
           getzstdPatch=false
           if $single_package; then
             if [ "$SINGLE_PACKAGE" = zstd ]; then getzstdPatch=true; fi
           elif [ "$Chapter" = chapter08 -o "$Chapter" = update ]; then
             getzstdPatch=true
           fi
           if $getzstdPatch; then
             patchSearch='*zstd*.patch*'
             if [ "$SOURCES" = atinstall ]; then # use md5sums
               zstdPatch=$(getMd5sumInfo "patchName" srcFileName $patchSearch)
             else # use the src dir
               zstdPatch=$(getPatchName "" $patchSearch $SourceDir)
               zstdPatch=${zstdPatch##*/} # just the filename
             fi
             ret_val=$?
             if [ $ret_val -eq $RETURN_PARAM ]; then
               echo "failed to get zstd patch name"
               echo "*** Investigate ***"
             else
               echo "zstd patch is $zstdPatch"
             fi
           fi
         ;;
      esac
    done
  elif [ ! -d $SourceDir ]; then
    echo "The source dir $SourceDir doesn't exist. Can't get package versions"
  else
    echo "The source dir $SourceDir exists but is empty. Can't get package versions"
  fi
fi # test installBinTarfile
#
if $single_package; then
  if [[ "$SINGLE_PACKAGE" = kernel || "$SINGLE_PACKAGE" = "linux-headers" ]]; then # get the latest kernel from the website
    if $printit; then msg "getting the latest kernel source version from kernel.org"; fi
    if $printit; then msg "Please wait ..."; fi
    getLatestKernel
    retval=$?
    if [ $retval -eq $RETURN_PARAM ]; then
      echo "return from getLatestKernel is $retval"
      echo "Is python beautifulsoup4 installed on the host?"
      echo "Aborting"
      exit 1
    elif [ $retval -eq $RETURN_OTHER_ERR ]; then
      echo "error return from getLatestKernel"
      echo "Investigate"
    elif [ $retval -eq 0 ]; then
      echo "the latest kernel src file from kernel.org is $kernSrcFile"
      echo "If installing a fresh version of the kernel or linux-headers, then"
      echo "will use the latest kernel version which is $kernLatestVers"
    fi
  fi
else # all packages in a chapter, get the latest kernel version
  if ! $installBinTarfile; then
    useKernLatest=false
    if $printit; then msg "getting the latest kernel source version from kernel.org"; fi
    if $printit; then msg "Please wait ..."; fi
# if kernel.org is slow, uncomment the next 3 lines and comment getLatestKernel and the 3 retval tests
#    kernSrcFile="linux-6.1.tar.xz"
#    kernLatestVers="6.1"
#    msg "*** Warning kernel version fixed at 6.1 ***"
    getLatestKernel
    retval=$?
    if [ $retval -eq $RETURN_PARAM ]; then
      echo "return from getLatestKernel is $retval"
      echo "Is python beautifulsoup4 installed on the host?"
      echo "Aborting"
      exit 1
    elif [ $retval -eq $RETURN_OTHER_ERR ]; then
      echo "error return from getLatestKernel"
      echo "Investigate"
    elif [ $retval -eq 0 ]; then
      echo "the latest kernel src file from kernel.org is $kernSrcFile"
    fi
# check if the linux-headers file is in the /build dir
    linuxHeadersFile=$(getLinuxFile)
    retval=$?
    if [ $retval -eq $RETURN_PARAM ]; then
      echo "The build directory for linux-headers doesn't exist"
      echo "If installing the kernel or linux-headers, then"
      echo "will use the latest kernel version which is $kernLatestVers"
      useKernLatest=true
    elif [ $retval -eq 0 ]; then
      echo "The installed linux-headers file is $linuxHeadersFile"
      rtrvers=""
      kernLatestVers=""
      GetPkgVersion "" $linuxHeadersFile ".tar"
      if [ "$?" = 0 ]; then
        if [ ! -z "$rtrvers" ]; then
          kernLatestVers=$rtrvers # global
          echo "If installing the kernel or linux-headers, then"
          echo "will use the latest linux headers version which is $kernLatestVers"
          useKernLatest=true
        else
          echo "rtrvers is NULL. Can't get the kernel version"
          echo "Investigate why this failed"
        fi
      else
        echo "return value for kernel vers from GetPkgVersion is $? It should be zero"
        echo "Investigate why this didn't work"
      fi
    fi
  fi
fi
#
Start $bookDir $version $SINGLE_PACKAGE # build the scripts
# if installing as root and chapter 5 and 6, set script owner to lfs
if $as_root; then
  case $Chapter in
     chapter05)
       chown lfs ${LFS}/${ch5script}
       chown lfs ${LFS}/${BuildLog}
     ;;
     chapter06)
       chown lfs ${LFS}/${ch6script}
       chown lfs ${LFS}/${BuildLog}
     ;;
  esac
fi
