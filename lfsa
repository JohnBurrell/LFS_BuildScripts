#!/bin/bash
#
if [ $UID -ne 0 ]; then echo Please run this script as root; exit 1; fi
LFS=$LFS
echo "LFS is set to $LFS"
if [ "$LFS" = "" ]; then
  echo "The LFS variable is not set"
  echo "do: export LFS=/mnt/lfs to install LFS on a target machine"
  echo "    export LFS=local to install LFS on this (local) machine"
  echo  
  exit 1
fi
# repository will be for LFS
REPO="LFS"
#
if [ "$LFS" = /mnt/lfs ]; then # check for the directory
  if [ ! -d $LFS ]; then
    echo "Directory $LFS doesn't exist"
    echo "Create it to continue"
    exit 1
  fi
elif [ "$LFS" = local ]; then
  LFS="/" # local machine
else
  echo "Don't recognise $LFS. Edit this script to respond to $LFS."
  exit 1
fi
#
if [ -e $LFS/tools ]; then
  if [ ! -d $LFS/tools ]; then
    echo "$LFS/tools is not a directory"
    mv -v $LFS/tools $LFS/tools.backup
    echo "file $LFS/tools moved to $LFS/tools.backup"
    echo "create directory $LFS/tools"
    install -vdm755 $LFS/tools
    if [ "$LFS/tools" != "$( ls -l /tools | awk '{print $NF}' )" ]; then
      echo "/tools is not a symlink to $LFS/tools"
      echo ""
      echo "as root, do:"
      echo ""
      echo " ln -s $LFS/tools /tools"
      exit 1
    fi
  else
    echo "tools dir ${LFS}/tools exists"
  fi
else
  install -vdm755 ${LFS}/tools
fi
#
#display_menu=true # by default, edit the config file
# set up default config filename
if [ "$LFS" = /mnt/lfs -o "$LFS" = "/" ]; then
  lfs="lfs"
  lfsUC=${lfs^^} # uppercase version of $lfs
  cfg=~/${lfsUC}.conf
else
  echo "*** Don't recognise $LFS. Make sure this script will work with that. ***"
fi
# this following bit allows you to give a config filename as $1 and use it unedited
#if [ ! -z "$1" ]; then # config filename given - use it unedited
#  cfg=$1 # full name of the config file
# check it exists
#  if [ ! -e $cfg ]; then # doesn't exist - exit
#    echo "If you give the config filename it must exist"
#    echo "Exiting now"
#    exit 1
#  else
#    display_menu=false # do not change the config file
#  fi
#fi
# output the env var LFS in a file in /home/lfs so can source it in chapter05
if [ -d /home/lfs ]; then
  if [ -e /home/lfs/defineLFS ]; then rm /home/lfs/defineLFS; fi
# remove LFS env variable in .bashrc in case LFS=local
  sed -e '/LFS=\/mnt\/lfs/d' \
      -e 's/LFS LC_ALL/LC_ALL/' \
      -i /home/lfs/.bashrc
  cat > /home/lfs/defineLFS << "EOF"
# this is sourced by .bashrc when su - lfs is done in chapter05
EOF
  echo export LFS=\"$LFS\" >> /home/lfs/defineLFS
#  chown lfs:lfs /home/lfs/defineLFS
# does the .bashrc file contain the source defineLFS line?
sourcePres=$(egrep -w 'source|defineLFS' /home/lfs/.bashrc)
  if [ "$sourcePres" != "source /home/lfs/defineLFS" ]; then
    sed -i '/export/a source \/home\/lfs\/defineLFS' /home/lfs/.bashrc
  fi
else
  echo "user lfs doesn't exist - will create the group and user lfs"
  groupadd lfs
  useradd -s /bin/bash -g lfs -m -k /dev/null lfs
  chown -v lfs ${LFS}/tools
  if [ ! -d ${LFS}/sources ]; then mkdir -v ${LFS}/sources; fi
  chown -v lfs $LFS/sources
  cat > /home/lfs/.bash_profile << "EOF"
exec env -i HOME=$HOME TERM=$TERM PS1='\u:\w\$ ' /bin/bash
EOF
cat > /home/lfs/.bashrc << "EOF"
set +h
umask 022
LC_ALL=POSIX
LFS_TGT=$(uname -m)-lfs-linux-gnu
PATH=/usr/bin
if [ ! -L /bin ]; then PATH=/bin:$PATH; fi
PATH=$LFS/tools/bin:$PATH
CONFIG_SITE=$LFS/usr/share/config.site
export LFS LC_ALL LFS_TGT PATH CONFIG_SITE
EOF
  cat > /home/lfs/defineLFS << "EOF"
# this is sourced by .bashrc when su - lfs is done in chapter05
EOF
  echo export LFS=\"$LFS\" >> /home/lfs/defineLFS
#  chown lfs:lfs /home/lfs/{.bash_profile,.bashrc,defineLFS}
  echo "*** NOTE - You need to set a password for user lfs ***"
fi
lfscommands=${lfs}-commands # the dir containing the lfs-commands
lfshtml=${lfs}-html # the dir containing the lfs html
DumpedCommands=${LFS}/${lfscommands}
Dumpedhtml=${LFS}/${lfshtml}
if [ "$LFS" = "/" ]; then # need to remove the // to get the Makefile to work
  DumpedCommands="/${lfscommands}"
  Dumpedhtml="/${lfshtml}"
fi
wgetopts="" # Options for wget, e.g. proxy settings etc
RETURN_GT=239 # used in test of which version is later. returned if $1 > $2
RETURN_EQ=241 # used in compare_versions - returned if versions are equal
RETURN_FNF=243 # file not found
RETURN_MTOV=245 # more than one version of file present
RETURN_NO_CMNDS=247 # not commands found for specified package
RETURN_FNF=249 # return file not found
RETURN_PARAM=251  # return parameter from a function on error
#
# these are relative to newly installed lfs ( i.e. without $LFS prefix )
sourcedir=/sources # as given in the book
PkgUserDir=/usr/src/core # all package src files sit under here. Make sure blfsa is consistent with this.
buildDir=${LFS}/build # chapter05 and 06 build directory
BuildLog=${lfsUC}-build.log # keep a record of packages and times
echo "BuildLog set to $BuildLog"
if [ ! -e ${LFS}/${BuildLog} ]; then
  if [ -d /home/lfs ]; then # user lfs exists
    touch ${LFS}/${BuildLog}
  else
    echo "user lfs doesn't exist. You should create it now - section 4.3 in the book"
    exit 1
  fi
fi
SOURCEDIR=${LFS}${sourcedir}
if [ ! -d "$SOURCEDIR" ]; then install -vdm755 $SOURCEDIR; fi
allChaps="chapter05 chapter06 chapter07 chapter08 chapter10"
build="build" # name of the build file for each package
ncc="--no-check-certificate" # options for wget
#initialize the config variables
TZ=$TZ
PAPER_SIZE=$PAPER_SIZE
LFS_BOOK_LOC_DIR=$HOME/LFS_SVN/$REPO # def local dir for the downloaded book xml
SVN_URL="svn://svn.linuxfromscratch.org/lfs/" #svn url
BOOK_VERSION=$BOOK_VERSION
SOURCES=$SOURCES
CLEAN_SRC_DIR=$CLEAN_SRC_DIR
WGETLISTNAME=$WGETLISTNAME
UPDATESRCFILES=$UPDATESRCFILES
BOOK=$BOOK
WHICH_CHAPTER=$WHICH_CHAPTER
PKGUSERFILE=$PKGUSERFILE
TESTS=$TESTS
MAKE_KERNEL=$MAKE_KERNEL # "no" -  stop at make mrproper, "yes" - use a .config and make
AS_ROOT=$AS_ROOT # 'no' install as package user, 'yes' install as root
SYSTEMD=$SYSTEMD # 'yes' use systemd, 'no' use sysvinit for control
DESTDIR=$DESTDIR
USEPROXY=$USEPROXY
SINGLE_PACKAGE=$SINGLE_PACKAGE
if [ -e $cfg ]; then
  source $cfg # exists so source it
else
  touch $cfg #cfg is new
  if [ -z "$TZ" ]; then #null
    TZ="Europe/London"
  fi
  if [ -z "$PAPER_SIZE" ]; then #null
    PAPER_SIZE="A4"
  fi
  if [ -z "$BOOK" ]; then
    BOOK="svn"
  fi
  if [ -z "$BOOK_VERSION" ]; then
    BOOK_VERSION="BOOK"
  fi
  if [ -z "$SOURCES" ]; then
    SOURCES="atinstall"
  fi
  if [ -z "$CLEAN_SRC_DIR" ]; then
    CLEAN_SRC_DIR="no"
  fi
  if [ -z "$WGETLISTNAME" ]; then
    WGETLISTNAME="wget-list"
  fi
  if [ -z "$UPDATESRCFILES" ]; then
    UPDATESRCFILES="no"
  fi
  if [ -z "$WHICH_CHAPTER" ]; then
    WHICH_CHAPTER="chapter05"
  fi
  if [ -z "$PKGUSERFILE" ]; then
    PKGUSERFILE="pkguser.tar.xz"
  fi
  if [ -z "$TESTS" ]; then #null
    TESTS="no"
  fi
  if [ -z "$MAKE_KERNEL" ]; then #null
    MAKE_KERNEL="no"
  fi
  if [ -z "$AS_ROOT" ]; then #null
    AS_ROOT="no"
  fi
  if [ -z "$SYSTEMD" ]; then #null
    SYSTEMD="yes"
  fi
  if [ -z "$DESTDIR" ]; then
    DESTDIR="no"
  fi
  if [ -z "$USEPROXY" ]; then
    USEPROXY="no"
  fi
  if [ -z "$SINGLE_PACKAGE" ]; then
    SINGLE_PACKAGE="no"
  fi
# store the values in the new config file
  echo "TZ=$TZ" | tee $cfg 
  echo "PAPER_SIZE=$PAPER_SIZE" | tee -a $cfg
  echo "LFS_BOOK_LOC_DIR=$HOME/LFS_SVN/$REPO" | tee -a $cfg
  echo "SVN_URL=svn://svn.linuxfromscratch.org/lfs/" | tee -a $cfg
  echo "BOOK_VERSION=$BOOK_VERSION" | tee -a $cfg
  echo "SOURCES=$SOURCES" | tee -a $cfg
  echo "CLEAN_SRC_DIR=$CLEAN_SRC_DIR" | tee -a $cfg
  echo "WGETLISTNAME=$WGETLISTNAME" | tee -a $cfg
  echo "UPDATESRCFILES=$UPDATESRCFILES" | tee -a $cfg
  echo "BOOK=$BOOK" | tee -a $cfg
  echo "WHICH_CHAPTER=$WHICH_CHAPTER" | tee -a $cfg
  echo "PKGUSERFILE=$PKGUSERFILE" | tee -a $cfg
  echo "TESTS=$TESTS" | tee -a $cfg
  echo "MAKE_KERNEL=$MAKE_KERNEL" | tee -a $cfg
  echo "AS_ROOT=$AS_ROOT" | tee -a $cfg
  echo "SYSTEMD=$SYSTEMD" | tee -a $cfg
  echo "DESTDIR=$DESTDIR" | tee -a $cfg
  echo "USEPROXY=$USEPROXY" | tee -a $cfg
  echo "SINGLE_PACKAGE=$SINGLE_PACKAGE" | tee -a $cfg
fi
# functions
#
configEdit () {
local DIALOG_OK=0
local DIALOG_CANCEL=1
local DIALOG_HELP=2
local DIALOG_EXTRA=3
local DIALOG_ITEM_HELP=4
local DIALOG_ESC=255
local HEIGHT=0
local WIDTH=0

display_configFile () {
  dialog --textbox "$1" $HEIGHT $WIDTH
}
#
_edit () {
local value
local newval
local exit_status
local tochange
local display
#
itemMenu=$(awk -F\= '{print $1,$2}' $cfg)
exec 3>&1
tochange=$(dialog --menu "Select item to edit" 0 0 0 $itemMenu 2>&1 1>&3)
exit_status=$?
exec 3>&-
case $exit_status in
  $DIALOG_CANCEL)
    return 0
  ;;
  $DIALOG_ESC)
    echo "Program aborted." >&2
    exit 1
  ;;
  $DIALOG_OK)
    case $tochange in
       TZ)
         display="Enter your local time zone. (If not known, run tzselect)"
       ;;
       PAPER_SIZE)
         display="Probably either letter or A4"
       ;;
       LFS_BOOK_LOC_DIR)
         display="Enter the local directory to store the LFS Book"
       ;;
       SVN_URL)
         display="Enter the svn url of the LFS book"
       ;;
       BOOK_VERSION)
         display="LFS book version you want. Type BOOK to get the svn version. To use systemd, set SYSTEMD=yes in the menu. Type blank to choose from a list."
       ;;
       BOOK)
         display="Enter either svn or local (if local the book must be in $LFS_BOOK_LOC_DIR)"
       ;;
       WHICH_CHAPTER)
         display="Enter chapter 5, 6, 7, 8 or 10, e.g. chapter05. Enter all to build them all. Enter update to update the core lfs packages or if using DESTDIR."
       ;;
       SOURCES)
	       display="atinstall, download or local. atinstall means download to the install dir at install time (default). (if local, source files must be in ${SOURCEDIR}/<book_version>)"
       ;;
       CLEAN_SRC_DIR)
         display="If yes, all files in $WgetList in ${SOURCEDIR}/<book_version> will be deleted. Default is no"
       ;;
       WGETLISTNAME)
         display="The name of the wget-list file. Default is wget-list"
       ;;
       UPDATESRCFILES)
           display="If yes, the source files are updated from the lfs sources page in the book.
The wget-list file is made consistent with these updates. Default is no"
       ;;
       PKGUSERFILE)
         display="tar file containing the package user build files. Default is pkguser.tar.xz. Place the file in $LFS/sources"
       ;;
       TESTS)
         display="Chapter 6 tests? Type eithe yes or no"
       ;;
       MAKE_KERNEL)
         display="If no, kernel will stop at makeproper. If you want to use a .config, type yes, place the .config file in \$LFS/sources and the kernel will be compiled and installed."
       ;;
       AS_ROOT)
         display="If yes, install packages as root. If no, install as package user"
       ;;
       SYSTEMD)
         display="If yes, systemd will control start-up, running and shutdown of the system. If no, will use sysvinit."
       ;;
       DESTDIR)
         display="If yes, a DESTDIR install of a package will be done. Note - no binary package file is created unless the package name is given in the SINGLE_PACKAGE option. Default is no"
       ;;
       USEPROXY)
           display="Set to yes if a proxy server is running on the host. Default is no."
       ;;
       SINGLE_PACKAGE)
         display="Install a single package. Use with DESTDIR to create a binary package file. The package name must be in the wget-list file (linux-headers and kernel are okay names). Default is no"
       ;;
    esac
    value=$(awk -F\= -v x=$tochange '$1==x {print $2}' $cfg)
  ;;
esac
exec 3>&1
newval=$(dialog --clear --title "Change value" --inputbox "$display" 0 0 $value 2>&1 1>&3)
case ${newval+x$newval} in
  (x)
     dialog --infobox "Value can't be empty" 0 0
     sleep 2
     exit_status=1
  ;;
  ("")
     dialog --infobox "Value can't be unset" 0 0
     sleep 2
     exit_status=1
  ;;
  (x*[![:blank:]]*)
     exit_status=$? # non blank
  ;;
  (*)
     dialog --infobox "Value can't be blank" 0 0
     sleep 2
     exit_status=1
  ;;
esac
exec 3>&-
case $exit_status in
  $DIALOG_CANCEL)
    return 0
  ;;
  $DIALOG_ESC)
    echo "Program aborted." >&2
    exit 1
  ;;
  $DIALOG_OK)
    dialog --title "Confirmation"  --yesno "Commit ?" 0 0
    exit_status=$?
    case $exit_status in
       1)
          dialog --infobox "Value not changed" 0 0
          sleep 1
       ;;
       0)
          awk -v x=$tochange -v n=$newval '
               BEGIN {FS=OFS="="}$1==x {$2=n} {print}
               ' $cfg > $cfg.tmp
          mv $cfg.tmp $cfg
       ;;
    esac
  ;;
esac
return 0
} # end _edit
#
_main () {
while true; do
  exec 3>&1
  selection=$(dialog \
    --backtitle "LFS config file editor" \
    --title "Menu" \
    --clear \
    --cancel-label "Cancel" \
    --menu "Please choose an option:" $HEIGHT $WIDTH 4 \
            1 "View the config file" \
            2 "Edit config file" \
            3 "Exit from this menu" 2>&1 1>&3)
  exit_status=$?
  exec 3>&-
  case $exit_status in
    $DIALOG_CANCEL)
      echo "Cancel pressed. Exit program"
      exit 1
    ;;
    $DIALOG_ESC)
      echo "Program aborted."
      exit 1
    ;;
    $DIALOG_OK)
      case $selection in
        1)
           display_configFile $cfg
        ;;
        2)
           _edit
           display_configFile $cfg
        ;;
        3)
          echo "Exit and process config file"
          return
        ;;
      esac
  esac
done
#
} # end _main
_main
} #end configEdit
#
ChkLocalBook () {
# $1 is the dir of the book
# $2 is the book version
local localbookdir=$1
local version=$2
ChkLocalBookExists $localbookdir $version
    return_val=$?
    if [ "$return_val" -eq $RETURN_PARAM ]; then # requested book not present
      echo "Requested book not present locally. Will need svn it"
      return $RETURN_PARAM
    else # book present, test if need to svn an update
      ChkLocalBookDetails $localbookdir $version
      return_val=$?
      if [ "$return_val" -eq $RETURN_PARAM ]; then
        exit 1
      else
        echo "Book version $version present in $localbookdir"
        echo "Will use that one."
        return 0
      fi
    fi
} # end ChkLocalBook
#
ChkLocalBookExists () {
# $1 is the dir of the book
# $2 is the book version
local bookdir=$1
local version=$2
#
unset BookPath
for BookPath in $( find $bookdir -name index.xml -exec dirname {} ';' )
do
  if [ -e $BookPath/.svn ]; then # a book exists, check the version
    if [ "$BookPath" == "${bookdir}/${version}" ]; then
      return 0 #requested version is present locally
    fi
  fi
done
return $RETURN_PARAM #requested book not present locally
} #end ChkLocalBookExists
#
ChkLocalBookDetails () {
local bookdir=$1
local book_version=$2
#
if [ "$book_version" = BOOK ]; then
  # check the last svn date
  returned_array=( $(LastAccessSvn) )
  retval=$?
  if [ $retval -eq 0 ]; then # compare last svn date with today's date
    if [ ${returned_array[0]} -eq ${returned_array[1]} ]; then
      echo "The same book has already been downloaded today"
      echo "To use it, set BOOK=local in the config file."
      echo "To download it again, delete ${bookdir}/${book_version}"
      return $RETURN_PARAM
    else
      return 0
    fi
  else
    echo "Could not retrieve date of last svn - no entries file found."
    echo "Will svn it"
    return 0
  fi
else # book is a release version so don't update it
  echo "Requested book is present locally so will use it."
  echo "It is a release version so no update necessary."
  return $RETURN_PARAM
fi
} # end ChkLocalBookDetails
#
CleanLocalREPO () { # delete any files in the local directory
local bookdir=$1
local book_version=$2
if [ -d ${bookdir}/${book_version} ]; then #local dir exists
  if [ "$(ls -A ${bookdir}/${book_version})" ]; then
    rm -rf ${bookdir}/${book_version} # delete contents of local book dir
  fi
else  # create it
  install -v -m0755 -d ${bookdir}/${book_version}
fi
} # end CleanLocalREPO
#
SetSvnUrl () {
# set the svn url to $1
SVN_URL=$1
} # end SetSvnUrl
#
WhichLFSBook () {
local Ignore="bootscripts"
local lfsVers=$(svn ls ${SVN_URL}tags | grep -vE "$Ignore")
PS3="Please select the book version : "
select TAG in 'Current Development' $lfsVers
do
  case $TAG in
    '') echo >&2 "Please select a numbered option";;
    Current*)
      type=trunk
      version=BOOK
      BOOK_VERSION="Current_Development"
    ;;
    ?*)
      type=tags
      version=$TAG
      BOOK_VERSION=$TAG
    ;;
  esac
  BOOK_SVN_URL="${SVN_URL}$type/$version"
  echo >&2 "You have selected '$TAG'"
  echo >&2 "$BOOK_SVN_URL"
  PS3="Is this correct? : "
  select confirm in Yes No
  do
    case $confirm in
      '') echo >&2 "Please enter 1 for Yes or 2 for No"
      ;;
      ?*) break
      ;;
    esac
  done
  case $confirm in
    No) PS3="Please select the book version : "
    ;;
# update the config file with the book version
    Yes) awk -v x=BOOK_VERSION -v n=$BOOK_VERSION '
             BEGIN {FS=OFS="="}$1==x {$2=n} {print}
             ' $cfg > $cfg.tmp
             mv $cfg.tmp $cfg
         break
    ;;
  esac
done
} #end WhichLFSBook
#
SetLFSBook () {
# note - type and version are global variables
# $1 is the book version
local book_version=$1
case $book_version in
   Current_Development|BOOK)
         type=trunk
         version=BOOK
   ;;
   *)
         type=tags
         version=$book_version
   ;;
esac
} #end SetLFSBook
#
LastAccessSvn () {
local passed_array   # Local variable
local bookdir=$LFS_BOOK_LOC_DIR
BookLoc=${bookdir}/${version}
if [ -e ${BookLoc}/.svn/entries ]; then #check time of last svn
  EntriesDate=$( stat --printf=%y ${BookLoc}/.svn/entries | awk 'gsub(/-/,"") {printf $1}' )
  date=$(date +'%Y-%m-%d %H:%M:%S') # today's date
  read Y M D h m s <<< ${date//[-: ]/ }
  today=$Y$M$D
  passed_array=( $EntriesDate $today ) # return the last svn date and today
  echo "${passed_array[@]}"
  return 0
else
  return $RETURN_PARAM # no entries file found
fi
} # end LastAccessSvn
#
CheckoutSVN () {
local bookdir=$1
local book_version=$2
#
Url="${SVN_URL}${type}/${book_version}"
#
echo "Will svn the LFS book at $Url"
echo "and place it in ${bookdir}/${book_version}"
svn co $Url ${bookdir}/${book_version} # get the requested book
# add lfs: to the Makefile
sed -i '/book:/i lfs: book wget-list\n' ${bookdir}/${book_version}/Makefile
#
} # end CheckoutSVN
#
LocalBookFound () {
# $1 is the book version
local version=$1
# note - type is a global variable
case $version in
   BOOK)
     type="trunk"
   ;;
   *)
     type="tags"
   ;;
esac
} # end LocalBookFound
#
DumpCommands () {
# $1 is the Repository - LFS in this case
# $2 is the dir containing the book
# $3 is the book version
local bookdir=$2
local book_version=$3
local rev="systemd" # default
if [ "$SYSTEMD" = no ]; then rev="sysv"; fi
#
REPODIR=${bookdir}/${book_version}
local target=$( echo $1 | awk '{print tolower($1)}')
SVNINFO="$(svn info $REPODIR | awk '{printf $0"|"}')"
# Note, tagged | on the end so it can be used as a record separator later
# e.g.
# echo $SVNINFO | awk 'BEGIN{ RS = "|" }; {print $0}'
# will 'reconstitute it
SVNrevision=$( echo $SVNINFO | awk 'BEGIN{ RS = "|" };/Revision/ {print $0}' )
#DumpedCommands="/lfs-commands"
#Dumpedhtml="/lfs-html"
if [ ! -d $DumpedCommands ]; then install -vdm755 $DumpedCommands; fi
if [ ! -d $Dumpedhtml ]; then install -vdm755 $Dumpedhtml; fi
if [ ! -e ${DumpedCommands}/.revision ]; then touch ${DumpedCommands}/.revision; fi # suppress a 'No such file' warning
commandRevision=$( cat $DumpedCommands/.revision | awk '/Revision/ {print $0}')
if [ "$commandRevision" != "$SVNrevision" ]; then # dump the new commands
  rm -rf $DumpedCommands
  rm -rf $Dumpedhtml
  install -vdm755 $DumpedCommands
  install -vdm755 $Dumpedhtml
  pushd $REPODIR
    make -j1 DUMPDIR=$DumpedCommands BASEDIR=$Dumpedhtml REV=$rev $target dump-commands
    for dir in $DumpedCommands $Dumpedhtml; do
      echo $SVNINFO | awk 'BEGIN{ RS = "|" }; {print $0}' > ${dir}/.revision
    done
  popd
  mkdir -pv ${SOURCEDIR}/${book_version}
  if [ ! -e ${SOURCEDIR}/${book_version}/wget-list ]; then
    mv ${Dumpedhtml}/wget-list ${SOURCEDIR}/${book_version}/
    mv ${Dumpedhtml}/md5sums ${SOURCEDIR}/${book_version}/
  fi
fi
} # end of DumpCommands
#
CleanSourceDir () {
local srcdir=$1
local wgetlistFile=$2
if [ -d $srcdir ]; then
# delete any file in $srcdir that is in $wgetlistFile
  if [ -e $wgetlistFile ]; then
    while read FUrl; do
      if [[ ${FUrl:0:1} != '#' ]]; then # ignore file if it has a hash at the start
        fileinlist=$( echo $FUrl | awk -F\/ '{print $NF}' )
        [ -e ${srcdir}/${fileinlist} ] && rm -rf ${srcdir}/${fileinlist}
      fi
    done < $wgetlistFile
  fi
else
  rm -rf $srcdir # remove any file called $srcdir - it needs to be a dir
  install -v -m0755 -d $srcdir
fi
} #end CleanSourceDir
#
ChkPkgExists () {
# Used with the SINGLE_PACKAGE option.
# checks that the requested package is in the wgetlist file
local wgetlistFile=$1
local packageName=("${!2}")
local pkgURL
local fileinURL=""
#
echo "in ChkPkgExists"
echo "packageName is ${packageName[@]}"
if [ -e $wgetlistFile ]; then
  while read pkgURL; do
    fileinURL=$( echo $pkgURL | awk -F\/ '{print $NF}' )
    if [[ "$fileinURL" == ${packageName[0]}*.tar.*z* ]]; then
      fileinURL=$( echo $fileinURL | awk -F\/ '{print $NF}' )
      rtrnName=($fileinURL)
      return 0
    fi
  done < $wgetlistFile
return $RETURN_FNF
else
  return $RETURN_PARAM
fi
} # end ChkPkgExists
#
GetPkgName () {
# given a source file name, returns the package name for LFS packages
# $1 is the name of the src file
local pkgvers
local srcfile=$1
local pkgnm=$(echo $srcfile | awk -F\- '{print $1}')- # assumes the separator is -
case $srcfile in
   expect*|tcl8*) # separator is .
        pkgnm=$(echo $srcfile | awk -F\. '{print $1}')
        pkgnm=${pkgnm%?} # remove trailing numeric
   ;;
   iana-etc*|man-db*|man-pages*|pkg-config*|procps-ng*|util-linux*|XML-Parser*) # need $1 and $2 from awk
        pkgnm=$(echo $srcfile | awk -F\- '{print $1"-"$2}')-
   ;;
   tzdata*)
        pkgnm=$(echo $srcfile | awk -F\. '{print $1}') # separator is .
        pkgvers="${pkgnm#*tzdata}"
        pkgnm="${pkgnm%${pkgvers}*}"
   ;;
esac
echo $pkgnm
return 0
} # end GetPkgName
#
uniqueArray () {
# $1 is the array to sort
local unsorted_array=("${!1}")
local ip
local IFS=$'\n'
local sorted_array=( $(printf "%s\n" "${unsorted_array[@]}" | sort -u) )
rtrnSorted=(${sorted_array[@]})
} # end uniqueArray
#
get_crtime() {
# get the creation time (crtime) of a file
# $1 is the filename
# $2 is the file location - no final /
# NOTE need the -P option for grep implemented (if necessary recompile grep with pcre support)
#
local target=${2}/${1}
local inode=$(stat -c %i "${target}")
local fs=$(df "${target}"  | tail -1 | awk '{print $1}')
local crtime=$(sudo debugfs -R 'stat <'"${inode}"'>' "${fs}" 2>/dev/null | grep -oP 'crtime.*--\s*\K.*')
echo $crtime
}
#
detExtType () {
# determine the extension type of a tar file
# the hierarchy is xz, bz2, gz, tgz and zip
local sortedVers=("${!1}")
local isXZ=false
local isLZMA=false
local isBZ2=false
local isGZ=false
local isGZ2=false
local ispatchGZ=false
local isTGZ=false
local isZIP=false
local isTAR=false
local extType
#
for ((in=0; in<${#sortedVers[@]}; in++)); do # decide which files to test, .xz, .bz2, .gz, .tgz or zip
  case ${sortedVers[in]} in
     *tar.xz*)
        isXZ=true # if .xz file present, don't need to continue searching
        break
     ;;
     *.tar.lzma*) # e.g. curl
        isLZMA=true
     ;;
     *tar.bz2*)
        isBZ2=true
     ;;
     *tar.gz*)
        isGZ=true
     ;;
     *.patch.gz*) # for a gz patch file
        ispatchGZ=true
        break
     ;;
     *[0-9].gz*) # if no tar in name
        isGZ2=true
        trimto=".gz"
     ;;
     *.tgz*)
        isTGZ=true
     ;;
     *.zip*)
        isZIP=true
     ;;
     *-signed.tar) # for any signed file
        isTAR=true
        break
     ;;
  esac
done
# Set extension type to use, based on the hierarchy of tar files
if $isXZ; then
  extType="xz"
elif $isLZMA; then
  extType="lzma"
elif $isBZ2; then
  extType="bz2"
elif $isGZ; then
  extType="gz"
elif $ispatchGZ; then
  extType="patch.gz"
elif $isGZ2; then
  extType="gz2"
elif $isTGZ; then
  extType="tgz"
elif $isZIP; then
  extType="zip"
elif $isTAR; then
  extType="tar"
else
  return $RETURN_PARAM
fi
echo $extType
return 0
} # end detExtType
#
compare_versions () {
#
# compares two version numbers
# returns $RETURN_GT if $1 > $2 
# return $RETURN_EQ if $1 = $2
# otherwise returns 0
# $3 is the separator to parse the version number, usually .
#
local IFS="$3"
local a1=( $1 )
local a2=( $2 )
# some versions have a - in them, e.g. ImageMagick
local b1=$(IFS='-'; echo "${a1[*]}") # string b1 is now - delimited
local b2=$(IFS='-'; echo "${a2[*]}")
IFS='-' read -ra a1 <<< "$b1" # put delimited string back into array
IFS='-' read -ra a2 <<< "$b2"
#echo "a1 is ${a1[@]}"
#echo "a2 is ${a2[@]}"
local num_a1=${#a1[@]}
local num_a2=${#a2[@]}
#echo "numa1, numa2 are $num_a1 $num_a2"
local max=$(( $num_a1 > $num_a2 ? $num_a1 : $num_a2 ))
local im
for (( im=0; im<$max; im++ )); do
# deal with invalid octal. usbutils uses 00 type versioning.
  if [ "${a1[im]}" = "08" -o "${a1[im]}" = "09" ]; then a1[im]=${a1[im]#?}; fi
  if [ "${a2[im]}" = "08" -o "${a2[im]}" = "09" ]; then a2[im]=${a2[im]#?}; fi
  if [ "${a1[im]}" = "008" -o "${a1[im]}" = "009" ]; then a1[im]=${a1[im]#??}; fi
  if [ "${a2[im]}" = "008" -o "${a2[im]}" = "009" ]; then a2[im]=${a2[im]#??}; fi
#echo "a1 is ${a1[im]}"
#echo "a2 is ${a2[im]}"
  if [ "${a1[im]}" -eq "${a1[im]}" ] 2>/dev/null; then # is integer
    if [ "${a2[im]}" -eq "${a2[im]}" ] 2>/dev/null; then # can compare
      (("${a1[im]}" > "${a2[im]}")) && return $RETURN_GT
      (("${a2[im]}" > "${a1[im]}")) && return 0
    else
         return $RETURN_GT # a2 missing so a1 greater
    fi
  else
         return 0 # a2 greater
  fi
done
# if got here then a1 and a2 are equal
return $RETURN_EQ
} # end compare_versions
#
updateSorted () {
# $1 is the array holding the list of "Click to enter 'version' strings"
# $2 is the url
# $3 is the package name, no version num but include the - after the name
# $4 is the file extension, .tar.xz, .tar.bz2, .tar.gz, .tgz or .zip
# $5 is the index number in ClickToDnld containing the filename
local ClickToEnter=("${!1}")
#echo "in updateSorted"
local ClickToDnld # array containing list of "Click to download 'filename' strings"
local latestVer=${ClickToEnter[1]} # assumes the first one is the latest - note [0] is empty
latestVer=${latestVer#"Click to enter "} # version number
local url="${2}${latestVer}/" # new url for page to search
local pattern
case $3 in
   boost_)
     latestVer="${latestVer//./_}" # version is _
     pattern="${3}${latestVer}${4}"
   ;;
   cracklib-words-)
     latestVer=${latestVer//-/}
     pattern="${3}${latestVer}${4}"
   ;;
   faad2-)
     pattern="${latestVer}/${latestVer}${4}"
   ;;
   libusb-)
     pattern="${latestVer}${4}"
   ;;
   sqlite-*)
     pattern=$3
     url=${url/e 3/e%203} # fix the space in the version number
   ;;
   tcl8.)
     pattern="${3}${latestVer}-src.tar.gz"
   ;;
   tk8.)
     pattern="${fnameonly}${latestVer}-src.tar.gz"
   ;;
   *)
     pattern="${3}${latestVer}${4}"
   ;;
esac
#echo "url is $url"
#echo "pattern is $pattern"
local foundPat=$(/usr/bin/php srcFileVers.php -- $pattern $url $3)
if [ "$foundPat" = "" ]; then
  return $RETURN_PARAM
fi
# page found so update array
readarray -t ClickToDnld <<< "$foundPat"
#echo "ClickToDnld is ${ClickToDnld[@]}"
local indexnum=$5
local filename=${ClickToDnld[indexnum]} #  [0] is empty
#echo "filename is $filename"
filename=${filename#*"Click to download "}
#echo "filename is $filename"
rtrnFname=$filename
#echo "exit updateSorted"
return 0
} # end updateSorted
#
findMaxVers () {
# $1 is the array holding the filenames
# $2 is the extension of the file - xz, bz2, gz, patch.gz, tgz or zip
# $3 is the pattern to trim to
# $4 is the current version in the wget-list file
# $5 is the package tar filename
# $6 - only used for grub and is $trimfname
local filesArray=("${!1}")
local extType=$2
local trimto=$3
local extension
local CurrentMaxVers=$4
local fname=$5
local instor=0 # the index of the max version file in the filesArray array
local foundit=false # true if $maxVers found in filesArray
local maxVers=$CurrentMaxVers # this will change if there is a later version
local trimfname=$6
#
case $extType in
   xz)
     extension="tar.xz"
   ;;
   bz2)
     extension="tar.bz2"
   ;;
   gz)
     extension="tar.gz"
   ;;
   gz2)
     extension=".gz"
   ;;
   patch.gz)
     extension="patch.gz"
   ;;
   tgz)
     extension=".tgz"
   ;;
   zip)
     extension=".zip"
   ;;
   tar)
     extension=".tar"
   ;;
   lzma)
    extension="tar.lzma"
   ;;
esac
for ((in=0; in<${#filesArray[@]}; in++)); do
  case ${filesArray[in]} in
     *$extension) # parse the version number of all files of type $extension
             namePlusVer="${filesArray[in]%${trimto}*}" # name plus version
#echo "namePlusVer is $namePlusVer"
             case $namePlusVer in
                expect*) # use . as the separator
                  justVers=$(echo $namePlusVer | awk -F\. '{print $NF}')
                ;;
                grub-*)
                  justVers=${namePlusVer#*${trimfname}} # the numeric after beta
                ;;
                tcl8.*)
                  justVers=${namePlusVer#"tcl8."}
                ;;
                *)
                  justVers=$(echo $namePlusVer | awk -F\- '{print $NF}')
                ;;
              esac
              case $justVers in
                 *rc*|*RC*|*c1*) # release candidate - ignore.
                   ret_val=0
                 ;;
                 *)
#echo "justVers is $justVers"
#echo "maxVers is $maxVers"
                  compare_versions $justVers $maxVers "."
                  ret_val=$?
                ;;
             esac
        if [ $ret_val -eq $RETURN_GT ]; then # justVers is >
          maxVers=$justVers
          foundit=true
          instor=$in # store the index of current max version
        elif [ $ret_val -eq $RETURN_EQ ]; then
          foundit=true
          instor=$in # versions are the same so store the index
        fi
     ;;
  esac
done
if [ "$maxVers" = "$CurrentMaxVers" ]; then # CurrentmaxVers unchanged
  if ! $foundit; then
    return $RETURN_PARAM
  else
    echo $instor # array index of the max version
    return $RETURN_EQ
  fi
else
  echo $instor # return the array index of the max version
  return 0
fi
} # end findMaxVers
#

GetLatestVers () {
# $1 is the wget-list file
# $2 is the book version, either lfs-sysv or lfs-systemd. Default is the latter.
# if present, $3 is runit, set to false to see result of a dummy run. Default is true.
# if present, $4 is printit. Set to true to see printout of variables' values. Default is false.
local wgetlist=$1
local bookvers
if [ ! -z "$2" ]; then
  if [ "$2" = "lfs-sysv" ]; then
    bookvers="development"
    echo "Using the sysv version of the book"
  elif [ "$2" = "lfs-systemd" ]; then
    bookvers="systemd"
    echo "Using the systemd version of the book"
  else
    echo "Didn't recognise $2. It should either be lfs-sysv or lfs-systemd."
    exit 1
  fi
else
  echo "Using the systemd version of the book"
  bookvers="systemd"
fi
local runit=${3:-true}
local printit=${4:-false}
#use a tmp file to store the latest urls for each source package
local latest_tmpfile=$(date +%d%B%Y_%H:%M:%S)tmp.file
local SrcURLtoUse="http://www.linuxfromscratch.org/lfs/view/${bookvers}/chapter03/packages.html"
local PatchURLtoUse="http://www.linuxfromscratch.org/lfs/view/${bookvers}/chapter03/patches.html"
# scrape the LFS website for the latest sources
local -a lines=($(python3 BShref.py $SrcURLtoUse))
local newURL=""
local i k
local src latestvers trimto
local fileExists useThisOne
local numFiles reply
local latestSrc
# remove the existing wget-list file so can be updated
if $runit; then rm -rf $wgetlist; fi # remove the old wgetlist file
for ((i=0; i<${#lines[@]}; i++)); do # get the src tarfile name
#  echo "from lfs website: ${lines[i]}"
# assumes all files in LFS have extensions .xz, .bz2 or .gz
  src=$(echo ${lines[i]} | awk -F\/ '{print $NF}' | grep -E ".tar.xz|.tar.bz2|.tar.gz")
  if $printit; then echo "src is $src"; fi
  if [ ! -z "$src" ]; then
# is this file already in $SourceDir
    if [ ! -e ${SourceDir}/${src} ]; then
      case $src in
          lfs-bootscripts*)
              echo "Don't need $src"
          ;;
          *)
              if ! $runit; then
                echo "Could download $src and place in $sourceLoc if runit were true"
              else
                echo "Will download $src and place in $SourceDir"
                trimto=".tar"
                case $src in
                   "tcl8."*) # trimto is -src
                     trimto="-src"
                   ;;
                   "python-"*"-docs-html.tar"*)
                     trimto="-docs"
                     tailbit="-docs-html" # might need this to find existing files
                   ;;
                esac
                pkgnm=$(GetPkgName $src)
                rtrvers=""
                GetVersionNum "" $src $trimto
                pkgvers=$rtrvers
                fileExists=($(find $SourceDir -type f -name "$pkgnm*"))
                numFiles=${#fileExists[@]}
                if [ $numFiles -gt 1 ]; then # probably src and patch file found for this package
                  echo "Files:"
                  for (( k=0; k<$numFiles; k++ )); do
                    echo "${fileExists[k]}"
                    case ${fileExists[k]} in
                       *tar.*z*) # use the tar file
                           useThisOne=${fileExists[k]}
                       ;;
                    esac
                  done
                  echo "found for package $pkgnm"
                elif [ $numFiles -eq 1 ]; then
                  useThisOne=${fileExists[0]}
                else # numFiles is zero, no package with this name found
                  echo "No package with name $pkgnm found in $sourceLoc"
                  echo "No source file to delete - continue with download"
                  useThisOne=$src
                fi
                if $printit; then echo "useThisOne is $useThisOne"; fi
                if [ "$useThisOne" = "$src" ]; then # only one file, download it
                  wget -O ${sourceLoc}/${src} ${lines[i]}
                  chown john:john ${sourceLoc}/${src}
                elif [ ! -z "$useThisOne" ]; then # a file with this pkgnm is present - compare versions
                  latestvers=$pkgvers # version of file to download
                  if $printit; then echo "latestvers is $latestvers"; fi
                  latestSrc=$(echo $useThisOne | awk -F\/ '{print $NF}') # remove SourceDir
                  if $printit; then echo "latestSrc is $latestSrc"; fi
                  pkgnm=$(GetPkgName $latestSrc)
                  rtrvers=""
                  GetVersionNum $SourceDir $pkgnm $trimto
                  retval=$?
                  if [ $retval -ne 0 ]; then
                    echo "Return from GetVersionNum is $retval"
                    echo "It should be 0. Investigate!"
                    exit 1
                  else
                    pkgvers=$rtrvers
                  fi
                  if [ "$pkgvers" = "$latestvers" ]; then
                    echo "Same version already downloaded but different extension"
                  else
                    for (( k=0; k<$numFiles; k++ )); do
                      echo "delete ${fileExists[k]} (Y/n)"
                      read replyDel
                      case $replyDel in
                        [yY]|[yY][Ee][Ss])
                          rm -v ${fileExists[k]}
                        ;;
                        [nN]|[nN][Oo])
                          echo "file ${fileExists[k]} not deleted"
                          storFname=${fileExists[k]}
                        ;;
                        *)
                          rm -v ${fileExists[k]}
                        ;;
                      esac
                    done
                    echo "Download $src (Y/n)"
                    read reply_Dwnld
                    case $reply_Dwnld in
                       [yY]|[yY][Ee][Ss])
                         wget -O ${SourceDir}/${src} ${lines[i]}
                         chown john:john ${SourceDir}/${src}
                       ;;
                       [nN]|[nN][Oo])
                         echo "File not downloaded"
                         reply_Dwnld=$(echo ${reply_Dwnld,,*}) # make sure it's lower case
                         if [ "$replyDel" = n -o "$replyDel" = no ]; then
                           echo "File $storFname not deleted and"
                           echo "File $src not downloaded"
                           tarfname=$(echo ${lines[i]} |  awk -F\/ '{print $NF}')
                           laterFname=$(echo $storFname |  awk -F\/ '{print $NF}')
                           echo "Will place $laterFname in the wget-list file"
                           url_bit="${lines[i]%${tarfname}}"
                           newURL=${url_bit}${laterFname}
                         fi
                       ;;
                       *)
                         wget -O ${SourceDir}/${src} ${lines[i]}
#                         chown lfs:root ${SourceDir}/${src}
                       ;;
                    esac
                  fi
                else
                  echo "The variable useThisOne is null. Investigate why"
                fi
              fi # end runit
          ;;
      esac
    else
      echo "file $src already downloaded"
    fi
  else
    echo "variable \$src is null"
    echo "Didn't find a tar.xz, tar.bz2 or tar.gz file"
    echo "Need to investigate why not"
    exit 1
  fi
  if [ -z "$newURL" ]; then
# echo "write ${lines[i]} to $wgetlist"
    echo "${lines[i]}" >> $wgetlist
  else
# echo "write $newURL to $wgetlist"
    echo "$newURL" >> $wgetlist
    newURL=""
  fi
done
# update any patches
local -a patches=($(python3 BShref.py $PatchURLtoUse))
local patchExists
for ((i=0; i<${#patches[@]}; i++)); do
  local ptch=$(echo ${patches[i]} | awk -F\/ '{print $NF}' | grep -E ".patch")
  if [ ! -e ${SourceDir}/${ptch} ]; then
    echo "Will download the patch $ptch and place in $SourceDir"
    pkgnm=$(GetPkgName $ptch)
    rtrvers=""
    GetVersionNum $SourceDir $pkgnm ".patch" "patch"
    retval=$?
    if [ $retval -ne 0 ]; then
      echo "parsing a patch file."
      echo "return value is $retval. It should be 0"
      exit 1
    else
      pkgvers=$rtrvers
    fi
    patchExists=$(find $SourceDir -type f -name "$pkgnm*.patch")
    if [ ! -z "$patchExists" ]; then
      if $runit; then
        echo "delete $patchExists (Y/n)"
        read replyDel
        case $replyDel in
          [yY]|[yY][Ee][Ss])
            rm -v $patchExists
          ;;
          [nN]|[nN][Oo])
            echo "file $patchExists not deleted"
          ;;
          *)
            rm -v $patchExists
          ;;
        esac
      else
        echo "Could delete $patchExists if runit were true"
      fi
    fi
    if $runit; then
      wget -O ${SourceDir}/${ptch} ${patches[i]}
#      chown lfs:root ${SourceDir}/${ptch}
    fi
  else
    echo "patch $ptch already downloaded"
  fi
# echo "write ${patches[i]} to $wgetlist"
  if $runit; then echo "${patches[i]}" >> $wgetlist; fi
done
} # end GetLatestVers
#
GetSource () {
local bookvers=$1
local srcdir=$2
local wgetlistFile=$3
local bookdir=$4
local fnameUnknown=false
# RequiredFiles contains an array of the required files. If RequiredFiles[0]=no, all files are requested.
local RequiredFiles=("${!5}")
#
# echo "RequiredFiles is ${RequiredFiles[@]}"
if [ "$bookvers" = BOOK ]; then # get sources from the urls in $wgetlist
  if [ ! -d $srcdir ]; then install -v -d $srcdir; fi
    if [ ! -e ${srcdir}/${wgetlistFile} ]; then # wget-list doesn't exist, get it from the book
      REPODIR=${bookdir}/${bookvers}
      make -j1 -f ${REPODIR}/Makefile -C $REPODIR BASEDIR=$srcdir REV="systemd" ${srcdir}/${wgetlistFile} ${srcdir}/md5sums
      md5sums=${srcdir}/md5sums
    fi
    if [ "${RequiredFiles[0]}" = no ]; then # all source files requested
      pushd $srcdir
        RequiredFiles=$( md5sum --quiet -c $md5sums 2> /dev/null | awk -F\: '!/OK/{printf "%s ",$1}' )
      popd
    else
      fnameUnknown=true # might not know the precise filename, only the package name
    fi
    for File in ${RequiredFiles[@]}; do
      Url=$( grep $File $wgetlistFile )
      case $File in
         lfs-bootscripts*)
             if [ ! -e ${srcdir}/${File} ]; then
              wget $wgetopts -c $Url -O ${srcdir}/${File}
             fi
         ;;
         ?*)
             if $fnameUnknown; then
               wget $wgetopts -c $Url -P ${srcdir}/
             else
               wget $wgetopts -c $Url -O ${srcdir}/${File}
             fi
         ;;
      esac
    done
else # use anduin to get the source tarball for the released book version
# ****** NOTE ******
# anduin no longer is up-to-date. The LFS editors appear to have abandoned it
#
  bookvers=${bookvers%/} # remove the trailing /
#  File="lfs-packages-${bookvers}.tar"
#  sourceURL="http://anduin.linuxfromscratch.org/sources/LFS/lfs-packages/${File}"
#  wget $wgetopts -c $sourceURL -O ${SOURCEDIR}/${File}
#  tar xvf ${SOURCEDIR}/${File} -C $SOURCEDIR
#  rm -v ${SOURCEDIR}/${File} # untared so remove it
  wget --input-file=$LFS/sources/${bookvers}/wget-list --continue --directory-prefix=$LFS/sources/${bookvers}
fi
#set all the sources to owner lfs, if it exists
if getent passwd lfs > /dev/null 2>&1; then
  echo "User lfs exists"
#  chown -R -h lfs:root $srcdir # because chapter05.sh and chapter06.sh are run as lfs
else
  echo "user lfs doesn't exist. Sources owned by root instead."
  chown -R -h root:root $srcdir
fi
chmod 755 $srcdir
chmod 644 ${srcdir}/*
#
} #end GetSource
#
GetSystemdSources () {
local srcdir=$1
local wgetlistFile=$2
while read -r FileUrl; do
  fileNam=$( echo $FileUrl | awk -F\/ '{print $NF}' )
  wget $wgetopts -c $FileUrl -O ${srcdir}/${fileNam}
done < $wgetlistFile
#if getent passwd lfs > /dev/null 2>&1; then
#  chown -R -h lfs:root $srcdir
#else
  chown -R -h root:root $srcdir
#fi
chmod 644 ${srcdir}/*
#
} # end GetSystemdSources
# 
ChkSrcPresent () { 
# $1 is the directory to check
# $2 is the $wgetlist of files
# $3 is the array to hold any missing src file names
# if a single package, $3 contains the package name in array element 0
local dirtochk=$1
local wgetlistFile=$2
filesNotPresent=("${!3}") # global array
local filetofind
#
if $single_package; then # single package requested
  if [ -e ${dirtochk}/${filesNotPresent[0]} ]; then
    return 0
  else
    return $RETURN_PARAM
  fi
else # check sources in wget-list file are present in dirtochk
  echo "Checking all sources in $wgetlistFile have been downloaded"
  im=0
  while read FileUrl; do
    if [[ ${FileUrl:0:1} != '#' ]]; then # ignore file if it has a hash at the start
      filetofind=$( echo $FileUrl | awk -F\/ '{print $NF}' )
      if [ ! -e ${dirtochk}/${filetofind} ]; then
	if [[ "$filetofind" == "lfs-bootscripts"* && "$SYSTEMD" == yes ]]; then
          echo "don't need lfs-bootscripts with systemd"
        elif [[ "$filetofind" == "sysvinit-"* && "$SYSTEMD" == yes ]]; then
          echo "don't need sysvinit with systemd"
	else
          echo "'$filetofind' not present in $dirtochk"
	  filesNotPresent[im]=$filetofind
          ((im++))
        fi
      fi   
    fi
  done < $wgetlistFile
  if [ $im -gt 0 ]; then # files are missing
    return $RETURN_PARAM
  else
    return 0
  fi
fi
} # end ChkSrcPresent
#
ChkEmptySrcFiles () {
local srcdir=$1
# if checking a single package download, $2 will be the package filename
local pkgnm="${2:-}"
local zeroLenFiles
#
if [ ! -z "$pkgnm" ]; then # single package requested
# chk pkgnm exists
  if [ ! -e "${srcdir}/${pkgnm}" ]; then
# file not found
    return $RETURN_FNF
  else
    zeroLenFiles=$(find $srcdir -type f -name "$pkgnm" -empty)
  fi
else
  zeroLenFiles=$(find $srcdir -type f -empty)
fi
local numzero=${#zeroLenFiles}
if [ $numzero -eq 0 ]; then
  return 0
else
  echo -e "These files are empty:\n$zeroLenFiles"
  return $RETURN_PARAM
fi
} # end ChkEmptySrcFiles
#
GetSeriesNum () {
# $1 is the version number
local versnumber=$1
rtrseries=""
local IFS='.' # parse using a .
digitarray=($versnumber)
rtrseries="${digitarray[0]}.${digitarray[1]}"
} # GetSeriesNum
#
getPatchVers () {
# assumes the standard form of a patch, viz. pkgnm-version-descriptor-1.patch
# $1 is the name of the patch file
# $2 is the pkg name
local patchFile=$1
local pkgnm=$2
local versionPlus="${patchFile#${pkgnm}*}"
pkgvers=$(echo $versionPlus | awk -F\- '{print $1}')
echo $pkgvers
} # end getPatchVers
#
GetPkgVersion () {
# $1 is the location of the src package
# $2 is the name of the package
# $3 is the name to trim against - usually tar
# $4 is used with a patch file and is set to patch
# $5 is used with a patch and if set to returnName, will return the name of the patch file only

local pkgloc=${1:-"nowhere"}
local patch=${4:-""}
local rtrnName=${5:-""}
rtrvers=""
# first check if just requested the name of a patch file
if [ "$rtrnName" = returnName ]; then
  if [ -d "$pkgloc" ]; then
    local patchFile="$2*.patch"
    local -a found=($(find $pkgloc -name $patchFile))
    local num=${#found[@]}
    if [ $num -eq 1 ]; then # return the name
      rtrvers=$found[0]
    elif [ $num -gt 1 ]; then
      return $RETURN_MTOV # more than one version present
    elif [ $num -eq 0 ]; then # file not found
      return $RETURN_FNF
    fi
  else # pkgloc not a directory
    return $RETURN_FNF
  fi
else
  GetVersionNum $pkgloc $2 $3 $patch $rtrnName
  retval=$?
  if [ $retval -eq $RETURN_PARAM ]; then
    return $RETURN_PARAM
  elif [ $retval -eq $RETURN_FNF ]; then
    return $RETURN_FNF
  elif [ $retval -eq $RETURN_MTOV ]; then
    return $RETURN_MTOV
  else
    return 0
  fi
fi
} # GetPkgVersion
#
GetVersionNum () {
# $1 is the dir containing the src package.
# If it doesn't exist, return the version of $2, if possible
# $2 is the name of the package
# $3 is the name to trim against - usually tar
# $4 if present, is "patch" to indicate a patch file
# $5 if present, is returnName to return the name of the patch file only
local pkgloc=$1
local srcfile=$2
local trimto=$3
local patch=${4:-""}
local rtrnName=${5:-""}
local -a found=""
local fname
local fileExt
local num=0
local i
local pkgvers=""
#
if [ -d "$pkgloc" ]; then
  found=($(find $pkgloc -name "${srcfile}[0-9]*${trimto}.*z*"))
  num=${#found[@]}
  if [ $num -gt 0 ]; then
    for((i=0; i<$num; i++)); do
      fname=$(echo ${found[i]} | awk -F\/ '{print $NF}')
      unset found[i]
      found[i]=$fname # replace with just the filename, not the url
    done
    if [ $num -eq 1 ]; then # get the version
      fileExt="${found#*${srcfile}}"
      pkgvers="${fileExt%${trimto}*}"
      rtrvers=($pkgvers)
      return 0
    elif [ $num -gt 1 ]; then
      return $RETURN_MTOV # more than one version present
    fi
  else # num=0 - might be a patch file
    if [ "$trimto" = ".patch" ]; then
      found=$(find $pkgloc -name "${srcfile}[0-9].*${trimto}" | awk -F\/ '{print $NF}')
      num=${#found[@]}
      if [ $num -eq 1 ]; then # a patch file so get the version
        pkgvers=$(getPatchVers $found $srcfile)
        rtrvers=($pkgvers)
        return 0
      else
        return $RETURN_FNF # file not found
      fi
    else # not a patch file, see if can return version of srcfile
      local pkgPlusVers="${srcfile%${trimto}*}"
      if [[ "$pkgPlusVers" = "tzdata"* ]]; then
        pkgnm="tzdata"
      else
        local pkgvers=$(echo $pkgPlusVers | awk -F\- '{print $NF}')
        if [ -z "$pkgvers" ]; then
          pkgnm=""
          return $RETURN_FNF
        else
# trim to the version number
          pkgnm="${pkgPlusVers%${pkgvers}}"
#          echo "pkgvers is $pkgvers"
#          echo "pkgnm is $pkgnm"
	   rtrvers=$pkgvers
	   return 0
	fi
      fi
    fi
  fi
else # no pkg location given - return the version of $2, if possible
  local pkgPlusVers="${srcfile%${trimto}*}"
  if [ "$patch" = patch ]; then
    local pkgnm=$(echo $pkgPlusVers | awk -F\- '{print $1}') # search for pkgnm*.patch
  else
    if [[ "$pkgPlusVers" = "tzdata"* ]]; then
      pkgnm="tzdata"
    else
      local pkgvers=$(echo $pkgPlusVers | awk -F\- '{print $NF}')
      if [ -z "$pkgvers" ]; then
        pkgnm=""
        return $RETURN_FNF
      else
# trim to the version number
        pkgnm="${pkgPlusVers%${pkgvers}}"
      fi
    fi
  fi
  rtrvers=$pkgvers
  return 0
fi
} # end GetVersionNum
#
GetLinuxVersion () {
local srcdir=$1
local linuxfnd
local linuxExt
#
linuxfnd=$(find $srcdir -name "linux-[0-9]*.tar.*z*" | awk -F\/ '{print $NF}')
if [ -z "$linuxfnd" ]; then # linux src not found in wget-list file - return
  return $RETURN_PARAM
else
  linuxExt="${linuxfnd#*-}"
  linuxvers="${linuxExt%.tar*}"
fi
return 0
} # end GetLinuxVersion
#
GetLinuxCommandVersion () {
# find the version of a package in the lfs commands
# $1 is the location of the lfs commands, include $LFS
# $2 is the package name in the command directory
# $3 is the pattern to find in the pkgname commands
local commandloc=$1
local pkgname=$2
local pattern=$3
if [ -e "$commandloc" ]; then
  local cmdLine
  local linuxcomfnd=""
#
  while read cmdLine; do
    if [[ ${cmdLine:0:1} != '#' ]]; then # ignore line if it has a hash at the start
      linuxcomfnd=$( echo $cmdLine | awk -F\/ '{print $NF}' | grep $pattern )
      if [ ! -z "$linuxcomfnd" ]; then
        break # found the pattern in the command line
      fi
    fi
  done < ${commandloc}/*-${pkgname}
  if [ ! -z "$linuxcomfnd" ]; then # found required pattern in the commands - echo it
    echo $linuxcomfnd
    return 0
  else
    return $RETURN_PARAM
  fi
#    linuxcomExt="${linuxcomfnd#*-}"
#    linuxcomvers="${linuxcomExt%-lfs*}"
else
  return $RETURN_PARAM
fi
} # end GetLinuxCommandVersion
#
SetPkgVers () {
cat >> $Output << "EOF"
SetPkgVers () {
# $1 is the package name
# $2 is the name to trim against - usually .tar
local pkgnm=$1
local trim=$2
local fndpkg
local pkgplusvers
fndpkg=$(find . -name "${pkgnm}-[0-9].*${trim}.*z*" | awk -F\/ '{print $NF}')
pkgplusvers="${fndpkg%${trim}*}"
rtrnpkgname=($pkgplusvers)
} # end SetPkgVers
#
EOF
} # end SetPkgVers
#
combineScripts () {
declare -a commands=("${!1}")
declare -a buildWrap=("${!2}")
local combine=""
local numc=${#commands[@]}
local numb=${#buildWrap[@]}
countc=0 # counter for the combine array
countbl=0 # counter for build lines written
inc=false # switch for whether a configure, make and install section is present
cont=0 # number of continuation lines
ifDoc=false # true if an if block containing a doc
#
for (( i=0; i<$numb; i++ )); do
  case "${buildWrap[i]}" in
    configure_commands*)
      combine[countc++]=${buildWrap[countbl++]}
      combine[countc++]=${buildWrap[countbl++]} # the {: line
      for (( jk=$countg; jk<$numc; jk++ )); do
        case ${commands[jk]} in
           make*) # assume either a make command or make install
              countg=$jk
              break
           ;;
           *"make -c"*) # ncurses has a pushd with make commands
              if $foundPushd; then # keep writing until popd found
                combine[countc++]="  ${commands[jk]}"
              else
                countg=$jk
                break
              fi
           ;;
           *popd*)
	     if $foundPushd; then # write it out and set foundPushd to false
                combine[countc++]="  ${commands[jk]}"
		foundPushd=false
             else
		echo "popd found but no pushd found before it"
		echo "Something is wrong. You need to investigate"
		exit 1
	     fi
	   ;;
           *"install_man_docs install_html_docs"*) # openssl in chapter06
              countg=$jk
              break
           ;;
           "python3 setup.py"*) # meson
              countg=$jk
              break
           ;;
           *"LANG=en_US.UTF-8 ninja"*) # systemd using ninja
              countg=$jk
              break
           ;;
           *'LIBRARY_PATH=/tools/lib make'*) # the eudev make command
              countg=$jk
              break
           ;;
           "cp services protocols"*) # iana-etc copy
              countg=$jk
              break
           ;;
           *install*) # test to see if part of a continuation squence
              case ${commands[jk]} in
                 *\\) # a continuation line
                    if [ $cont -gt 0 ]; then # part of configure sequence so store it
                      storit[cont++]="${commands[jk]}"
                    else # assume an install cont line
                      countg=$jk
                      break
                    fi
                 ;;
                 './configure'*) # might be a configure with install in it
                    combine[countc++]="  ${commands[jk]}"
                    inc=true
                 ;;
                 *)
                    countg=$jk
                    break
                 ;;
              esac
           ;;
           *)
              case "${commands[jk]}" in
                 *\\)
                    storit[cont++]="${commands[jk]}"
                 ;;
                 *)
                    # write with any continuation lines
                    if [ $cont -gt 0 ]; then
                      for (( l=0; l<$cont; l++ )); do
                        combine[countc++]="  ${storit[l]}"
                      done
                      combine[countc++]="  ${commands[jk]}"
                      cont=0
                      inc=true
                    else
                      combine[countc++]="  ${commands[jk]}" # configure command
                      inc=true # found at least one configure command
                    fi
                    if [ $[jk+1] -eq $numc ]; then countg=$jk; fi
                 ;;
              esac
           ;;
        esac
      done
      if [ $cont -gt 0 ]; then
        for (( l=0; l<$cont; l++ )); do
          combine[countc++]="  ${storit[l]}"
        done
        combine[countc++]="  ${commands[countg++]}"
        inc=true
        cont=0
      fi
      if ! $inc; then
        combine[countc++]='  echo "no configure script for this package"'
      fi
    ;;
    make_commands*)
      inc=false
      combine[countc++]=${buildWrap[countbl++]}
      combine[countc++]=${buildWrap[countbl++]} # the {: command
      for (( jl=$countg; jl<$numc; jl++ )); do
        case ${commands[jl]} in
           *"install_man_docs install_html_docs"*) # openssl chapter06, write this
              combine[countc++]="  ${commands[jl]}"
              cont=0
              inc=true
           ;;
           *install*) # assume an install command
              countg=$jl
              break
           ;;
           'cp -v src/{msgfmt'*) # gettext ch5
              countg=$jl
              break
           ;;
           'cp -v src/{fstab-decode'*) # sysvinit (systemd) ch6
              countg=$jl
              break
           ;;
           'cp -v perl cpan'*) # perl ch5
              countg=$jl
              break
           ;;
           "cp services protocols"*) # iana-etc copy
              countg=$jl
              break
           ;; 
           *)
              case "${commands[jl]}" in
                 *\\)
                     storit[cont++]="${commands[jl]}"
                 ;;
                 *)
                     if [ $cont -gt 0 ]; then # write the continuation lines
                       for (( l=0; l<$cont; l++ )); do
                         combine[countc++]="  ${storit[l]}"
                       done
                       combine[countc++]="  ${commands[jl]}"
                       cont=0
                       inc=true
                     else
                       combine[countc++]="  ${commands[jl]}" # make commands
                       inc=true #at least one make command found
                     fi
                     if [ $[jl+1] -eq $numc ]; then # no more commands
                       countg=$jl
                       if [[ "${commands[$countg]}" != *make* ]]; then
                         ((countc--))
                       fi
                     fi
                 ;;
              esac
           ;;
        esac
      done
       if ! $inc; then
         combine[countc++]='  echo "no make script for this package"'
       fi
    ;;
    install_commands*)
      inc=false
      foundDoc=false
      tarCom=false
      combine[countc++]=${buildWrap[countbl++]}
      combine[countc++]=${buildWrap[countbl++]} # the {: command
      for (( jm=$countg; jm<$numc; jm++ )); do
        case ${commands[jm]} in
          *install*)
             case "${commands[jm]}" in
               *\\) # cont line so store it
                  case "${commands[jm]}" in
                    *'/usr/share/doc'*) # cont line contains a doc
                        foundDoc=true
                        storit[cont++]="${commands[jm]}"
                    ;;
                    *) # no doc in this cont line
                        storit[cont++]="${commands[jm]}"
                    ;;
                  esac
               ;;
               'make'*'=/usr/share/doc'*|*'DOCDIR=/usr/share/doc'*) # genuine install command
                    if [ $cont -gt 0 ]; then # first write out cont lines
                      for (( l=0; l<$cont; l++ )); do
                        combine[countc++]="  ${storit[l]}"
                      done
                    fi
                    combine[countc++]="  ${commands[jm]}"
                    inc=true
               ;;
               *'/usr/share/doc'*) # don't write a doc install
                    :
               ;;
               *) # install line so write it out
                    if [ $cont -gt 0 ]; then # first write out cont lines
                      for (( l=0; l<$cont; l++ )); do
                        combine[countc++]="  ${storit[l]}"
                      done
                    fi
                    combine[countc++]="  ${commands[jm]}"
                    inc=true
                    cont=0
                    countg=$((jm+1))
               ;;
             esac
          ;;
          "tar "*) # a tar command, so break
             countg=$jm
             cont=0
             inc=true
             tarCom=true # set to true in case continuation lines have a /usr/share/doc in them
             break
          ;;
          '#'*) # comment line so ignore it
              if [ $[jm+1] -eq $numc ]; then countg=$[jm+1]; fi
          ;;
          if*) # starts with if so if a doc, will need to delete the closing fi
                   case ${commands[jm]} in
                   *'/usr/share/doc'*)
                       ifDoc=true
                       case ${commands[j]} in
                          *\\) # a continuation line so store it
                                storit[cont++]="${commands[jm]}"
                          ;;
                       esac
                   ;;
                   *\\) # a continuation line
                       storit[cont++]="${commands[jm]}"
                   ;;
                   *) # if block but not a doc or a cont line
                       echo ${commands[jm]}
                   ;;
                esac
          ;;
          *'/usr/share/doc'*) # would have got here because we have a cont line
             cont=0 # doc so don't write it out
             countg=$((jm+1)) # update countg in case this is the last line
          ;;
          "for "*) # begining of a for loop so break
             countg=$jm
             cont=0
             inc=true
             break
          ;;
          'cp -v src/{fstab-decode'*|'cp -v src/last'*|'cp -v man/{last'*|'cp -v man/{fstab-decode'*) # sysvinit (systemd) ch6
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'cp -v perl cpan/podlators'*|'mkdir -pv /tools/lib/perl5'*|'cp -Rv lib/* /tools/lib/perl5'*) # perl ch5
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'make -C ld clean'*|'make -C ld LIB_PATH=/usr/lib:/lib'*|'cp -v ld/ld-new /tools/bin'*) # binutils pass 2
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'cp -v gettext-tools/src/{msgfmt'*) # gettext chapter07
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'cp -rv usr/include $LFS/usr'*) # linux-headers copy
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'cp -rv usr/include /usr'*) # linux-headers copy when updating
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'cp -rv dest/* /'*) # meson copy from destdir
             combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;;
          'cp services protocols /etc'*) # iana-etc copy
	    combine[countc++]="  ${commands[jm]}"
             inc=true
             countg=$((jm+1))
          ;; 
          *)
             case "${commands[jm]}" in
               *\\) # if a cont line, then store it
                     storit[cont++]="${commands[jm]}"
               ;;
               'cp -v src/msgfmt'*)
                     combine[countc++]="  ${commands[jm]}"
                     countg=$((jm+1))
                     cont=0
                     inc=true
               ;;
               *)
                     if ! $foundDoc; then # write out any cont lines
                       if [ $cont -gt 0 ]; then
                         for (( l=0; l<$cont; l++ )); do
                           combine[countc++]="  ${storit[l]}"
                         done
                         combine[countc++]="  ${commands[jm]}"
                         cont=0
                         inc=true
                         countg=$((jm+1))
                       else # not part of install commands so break
                         countg=$jm
                         cont=0
                         inc=true
                         break
                       fi
                     else # continuation of a doc line so ignore it
                       cont=0
                     fi
               ;;
             esac
          ;;
        esac
      done
      if ! $inc; then
        combine[countc++]='  echo "no install script for this package"'
      fi
    ;;
    *)
      if [ $i -lt $countbl ]; then
        :
      else
        combine[countc++]=${buildWrap[i]}
        ((countbl++)) # increment because have written another build command
      fi
    ;;
  esac
done
rtr=(${combine[@]})
} # end combineScript
#
getBuild () {
# $1 is the pkguser directory in /tools, pkguser by default
local pkguser=${1:-pkguser}
local abuild=""
buildfile=${LFS}/tools/${pkguser}/build
if [ ! -e $buildfile ]; then
  return $RETURN_PARAM
else
IFS='
'
abuild=( $( < $buildfile ) )
rtrnBuild=(${abuild[@]})
return 0
fi
} # end getBuild
#
getComms () {
# $1 is the chapter containing the commands
# $2 is the package name
local acom=""
local bcom=""
local localpkgname=$2
chapreq=$1
if [ -e ${DumpedCommands}/${chapreq}/*-${CmdName} ]; then
  curfile=${DumpedCommands}/${chapreq}/*-${CmdName}
else
  return $RETURN_PARAM
fi
local IFS='
'
acom=( $( < $curfile ) )
#
# can adjust the commands here if necessary
#
case $localpkgname in
     *)
             rtrnCom=(${acom[@]})
             return 0
     ;;
esac
} # end getComms
#
GetCommands () {
#get access to the arrays
rtrnBuild=""
getBuild
return_val=$?
if [ "$return_val" -eq $RETURN_PARAM ]; then # no build file present in /tools
  return $RETURN_PARAM
else
buildScripts=(${rtrnBuild[@]})
rtrnCom=""
getComms $currentChapter $PkgName
ret_val=$?
if [ "$ret_val" -eq $RETURN_PARAM ]; then # no commands found
  echo 'echo "No commands found for package '"$PkgName"' in '"$lfscommands"'"
echo "Check you have the correct book written to '"$lfscommands"'"
echo "and that '"$PkgName"' is supposed to be installed in '"$Chapter"'"
echo "This script will fail."
exit 1' >> $Output
  return $RETURN_NO_CMNDS
else
  commandScripts=(${rtrnCom[@]})
  numclines=${#commandScripts[@]} # # of commands
#
# place commands in output until first configure found
  countg=0
  contline=0
  foundPushd=false # used to find the corresponding popd
  for line in "${commandScripts[@]}"; do
    case "$line" in
         sed*)
           echo "$line"
           ((countg++))
         ;;
         *pushd*) # ncurses has this in chapter06
	   foundPushd=true
	   countg=$countg-$contline
	   break
	 ;;
         *configure*|*Configure*) #Perl has Configure!
           countg=$countg-$contline
           break
         ;;
         *"config --prefix="*) # openssl
           countg=$countg-$contline
           break
         ;;
         *"cp services protocols"*) # iana-etc copy
           break
         ;;
         *"LANG=en_US.UTF-8"*) # systemd has this at start of configure
           countg=$countg-$contline
           break
         ;;
         "perl Makefile"*) # xml-parser is a perl module
           countg=$countg-$contline
           break
         ;;
         "python3 setup.py"*) # added for meson
           countg=$countg-$contline
           break
         ;;
         make*) #begins with make
           break
         ;;
         "PKG_CONFIG_PATH=/usr/lib/pkgconfig"*) # added for systemd using meson
           break
         ;;
         *)
# if a continuation line, store in cache
           case "$line" in
              *\\)
               cacheit[contline++]="$line"
               ((countg++))
              ;;
              *)
               if [ $contline -gt 0 ]; then # continuation line found
                 for (( l=0; l<$contline; l++ )); do
                   echo "${cacheit[l]}"
                 done
                 echo "$line"
                 contline=0
                 ((countg++)) # count # of commands written to output
                 if [ $countg -eq $numclines ]; then
                   return 0
                 fi
               else
                 echo "$line"
                 ((countg++)) # count # of commands written to output
                 if [ $countg -eq $numclines ]; then 
                   return 0 
                 fi
               fi
              ;;
            esac
         ;;
    esac
  done
#
  rtr=""
  combineScripts commandScripts[@] buildScripts[@]
  scriptOut=(${rtr[@]})
  for t in "${scriptOut[@]}"; do
    echo $t
  done
  if [ $countg -lt $((numclines)) ]; then # output remaining commands
    contin=false # switch for a continuation line
    contline=0   # # of continuation lines found
    iftest=false # test for an if block with a /usr/share/doc in it
    for (( k=$countg; k<$((numclines)); k++ )); do
      case ${commandScripts[k]} in
         install*)
                case ${commandScripts[k]} in
                   *'/usr/share/doc'*)
                       case ${commandScripts[k]} in
                          *\\) # a continuation line
                             contin=true
                          ;;
                       esac
                   ;;
                   *\\) # a continuation line
                       cacheit[contline++]=${commandScripts[k]}
                       contin=true
                   ;;
                   *) # install but not a doc or a cont line
                       echo ${commandScripts[k]}
                   ;;
                esac
         ;;
         if*) # starts with if so if a doc, will need to delete the closing fi
                case ${commandScripts[k]} in
                   *'/usr/share/doc'*)
                       iftest=true
                       case ${commandScripts[k]} in
                          *\\) # a continuation line
                             contin=true
                          ;;
                       esac
                   ;;
                   *\\) # a continuation line
                       cacheit[contline++]=${commandScripts[k]}
                       contin=true
                   ;;
                   *) # if test but not a doc or a cont line
                       echo ${commandScripts[k]}
                   ;;
                esac
         ;;
         ln*) # a symlink so write it - e.g. vim74
                echo ${commandScripts[k]}
         ;;
         *'/usr/share/doc'*)
                case ${commandScripts[k]} in
                    *\\) # a continuation line
                       if $tarCom; then # part of a tar command so write it to the cache
                         cacheit[contline++]=${commandScripts[k]}
                       fi
                       contin=true
                    ;;
                    *)
                       if $contin; then # is a doc, so don't write
                         contin=false
                         contline=0
                       fi
                    ;;
                esac
         ;;
         "fi"*)
                if $iftest; then # end of a doc if test - don't write it
                  iftest=false
                else
                  echo ${commandScripts[k]} # if block is not a doc
                fi
         ;;
         *)
                if ! $iftest; then # commands not within a doc if block
                  case ${commandScripts[k]} in
                      *\\) # continuation line, store it
                           cacheit[contline++]=${commandScripts[k]}
                           contin=true
                      ;;
                      *)
                           if [ $contline -gt 0 ]; then # write out continuation lines
                             for (( l=0; l<$contline; l++ )); do
                               echo "${cacheit[l]}"
                             done
                             contin=false
                             tarCom=false
                             contline=0
                           fi
                           echo ${commandScripts[k]}
                      ;;
                  esac
                fi
         ;;
      esac
    done
  fi
fi
return 0
fi
} # end GetCommands
#
dbusComms () {
local dbuscom=""
dbuscom[0]="./configure --prefix=/usr \\"
dbuscom[1]="            --sysconfdir=/etc \\"
dbuscom[2]="            --localstatedir=/var \\"
dbuscom[3]="            --libexecdir=/usr/lib/dbus-1.0 \\"
dbuscom[4]="            --docdir=/usr/share/doc/dbus-${dbusvers} \\"
dbuscom[5]="            --with-system-pid-file=/run/dbus/pid \\"
dbuscom[6]="            --with-system-socket=/run/dbus/system_bus_socket \\"
dbuscom[7]="            --disable-static \\"
dbuscom[8]="            --enable-systemd \\"
dbuscom[9]="            --with-console-auth-dir=/run/console/ \\"
dbuscom[10]="            --with-systemdsystemunitdir=/usr/lib/systemd/system"
dbuscom[11]="make"
dbuscom[12]="make install"
dbuscom[13]="ln -s /etc/machine-id /var/lib/dbus"
rtrncommands=(${dbuscom[@]})
} # end dbusComms
#
# TODO get the gcc version for the last command
gccComms () {
local gcccom=""
gcccom[0]='case $(uname -m) in'
gcccom[1]="  x86_64)"
gcccom[2]="    sed -i.orig '/m64=/s/lib64/lib/' gcc/config/i386/t-linux64"
gcccom[3]="  ;;"
gcccom[4]="esac"
gcccom[5]="mkdir build"
gcccom[6]="cd build"
gcccom[7]="../configure --prefix=/usr      \\"
gcccom[8]="             --disable-multilib \\"
gcccom[9]="             --with-system-zlib \\"
gcccom[10]="             --enable-languages=c,c++,fortran"
gcccom[11]="make"
gcccom[12]="make install"
gcccom[13]="mkdir -pv /usr/share/gdb/auto-load/usr/lib"
gcccom[14]="mv -v /usr/lib/*gdb.py /usr/share/gdb/auto-load/usr/lib"
gcccom[15]='rm -rf /usr/lib/gcc/$(gcc -dumpmachine)/10.2.0/include-fixed/bits/'
rtrncommands=(${gcccom[@]})
} # end gccComms
#
shadowComms () {
local shadowcom=""
shadowcom[0]="sed -i 's/groups\$(EXEEXT) //' src/Makefile.in"
shadowcom[1]="find man -name Makefile.in -exec sed -i 's/groups\\.1 / /'   {} \\;"
shadowcom[2]="find man -name Makefile.in -exec sed -i 's/getspnam\\.3 / /' {} \\;"
shadowcom[3]="find man -name Makefile.in -exec sed -i 's/passwd\\.5 / /'   {} \\;"
shadowcom[4]="sed -e 's@#ENCRYPT_METHOD DES@ENCRYPT_METHOD SHA512@' \\"
shadowcom[5]="    -e 's@/var/spool/mail@/var/mail@'                 \\"
shadowcom[6]="    -i etc/login.defs"
shadowcom[7]="sed -i 's/1000/999/' etc/useradd"
shadowcom[8]="./configure --sysconfdir=/etc --with-group-name-max-length=32"
shadowcom[9]="make"
shadowcom[10]="make install"
shadowcom[11]="sed -i 's/yes/no/' /etc/default/useradd"
shadowcom[12]="install -v -m644 /etc/login.defs /etc/login.defs.orig"
shadowcom[13]="for FUNCTION in FAIL_DELAY               \\"
shadowcom[14]="                FAILLOG_ENAB             \\"
shadowcom[15]="                LASTLOG_ENAB             \\"
shadowcom[16]="                MAIL_CHECK_ENAB          \\"
shadowcom[17]="                OBSCURE_CHECKS_ENAB      \\"
shadowcom[18]="                PORTTIME_CHECKS_ENAB     \\"
shadowcom[19]="                QUOTAS_ENAB              \\"
shadowcom[20]="                CONSOLE MOTD_FILE        \\"
shadowcom[21]="                FTMP_FILE NOLOGINS_FILE  \\"
shadowcom[22]="                ENV_HZ PASS_MIN_LEN      \\"
shadowcom[23]="                SU_WHEEL_ONLY            \\"
shadowcom[24]="                CRACKLIB_DICTPATH        \\"
shadowcom[25]="                PASS_CHANGE_TRIES        \\"
shadowcom[26]="                PASS_ALWAYS_WARN         \\"
shadowcom[27]="                CHFN_AUTH ENCRYPT_METHOD \\"
shadowcom[28]="                ENVIRON_FILE"
shadowcom[29]="do"
shadowcom[30]='    sed -i "s/^${FUNCTION}/# &/" /etc/login.defs'
shadowcom[31]="done"
shadowcom[32]='cat > /etc/pam.d/login << "EOF"'
shadowcom[33]="# Begin /etc/pam.d/login"
shadowcom[34]="# Set failure delay before next prompt to 3 seconds"
shadowcom[35]="auth      optional    pam_faildelay.so  delay=3000000"
shadowcom[36]="# Check to make sure that the user is allowed to login"
shadowcom[37]="auth      requisite   pam_nologin.so"
shadowcom[38]="# Check to make sure that root is allowed to login"
shadowcom[39]="# Disabled by default. You will need to create /etc/securetty"
shadowcom[40]="# file for this module to function. See man 5 securetty."
shadowcom[41]="#auth      required    pam_securetty.so"
shadowcom[42]="# Additional group memberships - disabled by default"
shadowcom[43]="#auth      optional    pam_group.so"
shadowcom[44]="# include system auth settings"
shadowcom[45]="auth      include     system-auth"
shadowcom[46]="# check access for the user"
shadowcom[47]="account   required    pam_access.so"
shadowcom[48]="# include system account settings"
shadowcom[49]="account   include     system-account"
shadowcom[50]="# Set default environment variables for the user"
shadowcom[51]="session   required    pam_env.so"
shadowcom[52]="# Set resource limits for the user"
shadowcom[53]="session   required    pam_limits.so"
shadowcom[54]="# Display date of last login - Disabled by default"
shadowcom[55]="#session   optional    pam_lastlog.so"
shadowcom[56]="# Display the message of the day - Disabled by default"
shadowcom[57]="#session   optional    pam_motd.so"
shadowcom[58]="# Check user's mail - Disabled by default"
shadowcom[59]="#session   optional    pam_mail.so      standard quiet"
shadowcom[60]="# include system session and password settings"
shadowcom[61]="session   include     system-session"
shadowcom[62]="password  include     system-password"
shadowcom[63]="# End /etc/pam.d/login"
shadowcom[64]="EOF"
shadowcom[65]='cat > /etc/pam.d/passwd << "EOF"'
shadowcom[66]="# Begin /etc/pam.d/passwd"
shadowcom[67]="password  include     system-password"
shadowcom[68]="# End /etc/pam.d/passwd"
shadowcom[69]="EOF"
shadowcom[70]='cat > /etc/pam.d/su << "EOF"'
shadowcom[71]="# Begin /etc/pam.d/su"
shadowcom[72]="# always allow root"
shadowcom[73]="auth      sufficient  pam_rootok.so"
shadowcom[74]="# Allow users in the wheel group to execute su without a password"
shadowcom[75]="# disabled by default"
shadowcom[76]="#auth      sufficient  pam_wheel.so trust use_uid"
shadowcom[77]="# include system auth settings"
shadowcom[78]="auth      include     system-auth"
shadowcom[79]="# limit su to users in the wheel group"
shadowcom[80]="auth      required    pam_wheel.so use_uid"
shadowcom[81]="# include system account settings"
shadowcom[82]="account   include     system-account"
shadowcom[83]="# Set default environment variables for the service user"
shadowcom[84]="session   required    pam_env.so"
shadowcom[85]="# include system session settings"
shadowcom[86]="session   include     system-session"
shadowcom[87]="# End /etc/pam.d/su"
shadowcom[88]="EOF"
shadowcom[89]='cat > /etc/pam.d/chage << "EOF"'
shadowcom[90]="# Begin /etc/pam.d/chage"
shadowcom[91]="# always allow root"
shadowcom[92]="auth      sufficient  pam_rootok.so"
shadowcom[93]="# include system auth, account, and session settings"
shadowcom[94]="auth      include     system-auth"
shadowcom[95]="account   include     system-account"
shadowcom[96]="session   include     system-session"
shadowcom[97]="# Always permit for authentication updates"
shadowcom[98]="password  required    pam_permit.so"
shadowcom[99]="# End /etc/pam.d/chage"
shadowcom[100]="EOF"
shadowcom[101]="for PROGRAM in chfn chgpasswd chpasswd chsh groupadd groupdel \\"
shadowcom[102]="               groupmems groupmod newusers useradd userdel usermod"
shadowcom[103]="do"
shadowcom[104]='    install -v -m644 /etc/pam.d/chage /etc/pam.d/${PROGRAM}'
shadowcom[105]='    sed -i "s/chage/$PROGRAM/" /etc/pam.d/${PROGRAM}'
shadowcom[106]="done"
shadowcom[107]="[ -f /etc/login.access ] && mv -v /etc/login.access{,.NOUSE}"
shadowcom[108]="[ -f /etc/limits ] && mv -v /etc/limits{,.NOUSE}"
rtrncommands=(${shadowcom[@]})
} # end shadowComms
#
sysvinitComms () {
local sysvinitcom=""
sysvinitcom[0]="make -C src fstab-decode"
sysvinitcom[1]="make -C src killall5"
sysvinitcom[3]="cp -v src/{fstab-decode,killall5} /usr/sbin"
sysvinitcom[6]="cp -v man/{fstab-decode,killall5,pidof}.8 /usr/share/man/man8"
sysvinitcom[7]="ln -sv ../sbin/killall5 /usr/bin/pidof"
rtrncommands=(${sysvinitcom[@]})
} # end sysvinitComms
#
GetInternalCommands () {
# $1 is the function name that creates the commands
# get access to the build array
rtrnBuild=""
getBuild
return_val=$?
if [ $return_val -eq $RETURN_PARAM ]; then # no build file present
  return $RETURN_PARAM
else
  buildScripts=(${rtrnBuild[@]})
  declare -a rtrncommands=""
  eval $1
  commandScripts=(${rtrncommands[@]})
  numclines=${#commandScripts[@]}
  countg=0 # initialize commands counter
  cont=0
  for line in "${commandScripts[@]}"; do
    case "$line" in
       sed*)
# test if sed has continuation line
         case "$line" in
           *\\)
             cacheit[cont++]="$line"
             ((countg++))
           ;;
           *)
             echo "$line"
             ((countg++))
           ;;
         esac
       ;;
       *configure*)
         break
       ;;
       make*) #  if no configure script present
         break
       ;;
       "perl Makefile.PL") # for perl modules
         break
       ;;
       *)
         case "$line" in
            *\\) # if a continuation line then store in cache
             cacheit[cont++]="$line"
             ((countg++))
            ;;
            *)
             if [ $cont -gt 0 ]; then # continuation line found
               for (( l=0; l<$cont; l++ )); do
                 echo "${cacheit[l]}"
               done
               echo "$line"
               cont=0
               ((countg++)) # count # of commands written to output
             else
               echo "$line"
               ((countg++)) # count # of commands written to output
             fi
            ;;
          esac
       ;;
    esac
  done
#
  rtr=""
  combineScripts commandScripts[@] buildScripts[@]
  scriptOut=(${rtr[@]})
  for t in "${scriptOut[@]}"; do
    echo $t
  done
  if [ $countg -lt $numclines ]; then # output remaining commands
    contin=false
    for (( k=$countg; k<$numclines; k++ )); do
      if [[ "${commandScripts[k]}" == install* ]]; then #don't install docs
        case ${commandScripts[k]} in
            *\\) # continuation line
                contin=true
            ;;
            */usr/share/doc*) # doc so don't write
                continue
            ;;
            *) # not a doc so write it
                echo ${commandScripts[k]}
            ;;
        esac
      else
        if $contin; then
          if [[ "${commandScripts[k]}" == *\\ ]]; then # more continuation
            :
          else
            contin=false
          fi
        else
          echo ${commandScripts[k]}
        fi
      fi
    done
  fi
  return 0
fi
} # end GetInternalCommands
#
createPkguser () {
cat >> $Output << "CPUEOF"
createPkguser () {
# $1 is the UID of the package
# $2 is the GID of the package. In this scheme UID = GID
# if $1 and $2 are 0, then the values are incremented on the initial value of 10000
# does the $PkgName user exist?
ret=false
getent passwd $PkgName > /dev/null 2>&1 && ret=true
if $ret; then
  echo "user $PkgName exists"
# make sure the home dir exists
  mkdir -pv ${PkgUserDir}/${PkgName}
else # create it and add it to the install group
  echo "Creating the user $PkgName"
  if [ $2 -ne 0 ]; then
    groupadd -g $2 $PkgName
    mkdir -pv ${PkgUserDir}/${PkgName}
    useradd -d ${PkgUserDir}/${PkgName} -s /bin/bash -u $1 -g $PkgName -m -k /dev/null $PkgName
  else # increment
    groupadd $PkgName
    useradd -d ${PkgUserDir}/${PkgName} -s /bin/bash -g $PkgName -m -k /dev/null $PkgName
  fi
  usermod -aG install $PkgName # add PkgName to the install group
fi
# create the .bash_profile and .bashrc files if they don't exist
if [ ! -e ${PkgUserDir}/${PkgName}/.bash_profile ]; then
  echo "exec env -i HOME=\$HOME TERM=\$TERM PS1='\u:\w\$ ' ${LFS}/install${PkgName}.sh" >> ${PkgUserDir}/${PkgName}/.bash_profile
fi
if [ ! -e ${PkgUserDir}/${PkgName}/.bashrc ]; then
  cat > ${PkgUserDir}/${PkgName}/.bashrc << "EOF"
set +h
umask 022
LFS=/mnt/lfs
LC_ALL=POSIX
LFS_TGT=$(uname -m)-lfs-linux-gnu
PATH=/usr/bin
if [ ! -L /bin ]; then PATH=/bin:$PATH; fi
PATH=$LFS/tools/bin:$PATH
CONFIG_SITE=$LFS/usr/share/config.site
export LFS LC_ALL LFS_TGT PATH CONFIG_SITE
EOF
fi
} # end createPkguser
#
CPUEOF
} # end createPkguser
#
cleanPkgDir () {
    cat >> $Output << "EOF"
cleanpkgdir () {
# $1 is the dir to clean
# $2 is the pkgname
local dirtoClean=$1
local pkgtoClean=$2
rm -rf ${dirtoClean}/build
rm -rf ${dirtoClean}/*.err
rm -rf ${dirtoClean}/*.log
rm -rf ${dirtoClean}/".ch08${pkgtoClean}"
rm -rf ${dirtoClean}/*.zst # remove any Arch binary files
rm -rf ${dirtoClean}/.subversion
rm -rf ${dirtoClean}/.wget-hsts
} # end cleanpkgdir
EOF
} # end cleanPkgDir
#
Header () {
echo writing the script to: $Output
if [[ "$as_root" = true && ("$Chapter" = chapter05 || "$Chapter" = chapter06) ]]; then
  cat > $Output << "EOF"
#!/bin/bash -e
#
if [ $UID -eq 0 ]; then
  echo "Please do NOT run this script as root."
  echo "Run it as user lfs."
  exit 1
fi
if [ $(whoami) != "lfs" ]; then echo Please run this script as user lfs. ; exit 1; fi
#
EOF
else # as root and chapter 7,8,10 and update or as pkguser
  cat > $Output << "EOF"
#!/bin/bash -e
#
if [ $UID -ne 0 ]; then echo Please run this script as root. ; exit 1; fi
#
EOF
fi
echo "me=\$0
SVNINFO=\"$SVNINFO\"
AS_ROOT=$as_root" >> $Output
if $useDESTDIR; then echo "useDESTDIR=$useDESTDIR" >> $Output; fi
case "$Chapter" in
   chapter05|chapter06)
     echo "Chapter=$Chapter
LFS=$LFS" >> $Output
     if ! $as_root; then
       echo "PkgUserDir=\${LFS}${PkgUserDir}" >> $Output
       cat >> $Output << "EOF"
buildDir=${LFS}/build
if [ ! -d ${LFS}/build ]; then
  mkdir -v ${LFS}/build
fi
chgrp install ${LFS}/{build,LFS-build.log}
chmod 1775 ${LFS}/build
chmod 664 ${LFS}/LFS-build.log
EOF
       createPkguser
     else # as root
       cat >> $Output << "EOF"  
buildDir=${LFS}/build
BuildLog=/LFS-build.log
sourcedir=/sources
sourceloc=${sourcedir}/BOOK
#
EOF
       CreateBuildDir
       unpack05
     fi
   ;;
   chapter07|chapter08|chapter10|update)
       echo "PkgUserDir=$PkgUserDir
sourcedir=$sourcedir
sourceloc=$sourceloc
BuildLog=/$BuildLog # no \$LFS here because in chroot
Chapter=$Chapter
wgetopts=\"$wgetopts\"
ncc=\"--no-check-certificate\"" >> $Output
if [[ "$Chapter" = update && "$as_root" = false ]]; then
  echo "# make sure a pkguser can write to BuildLog
chgrp install $BuildLog
chmod 664 $BuildLog" >> $Output
fi
if $as_root; then
  CreateBuildDirasroot
  unpack07
else
  setUserEnv # used in packageuser home dir to make sure .bash_profile and .bashrc are symlinks to /etc/pkgusr dir
  resetBashProfile # make sure Chapter is set in /etc/pkgusr
fi
if [ "$Chapter" = update ]; then cleanPkgDir; fi
     ;;
esac
} # end Header
#
unpackPkguser () {
#
# $1 is the pkguser filename
local pkguserFile=$1
if [ -L ${LFS}/tools ]; then
  echo "${LFS}/tools is currently a symbolic link"
  echo "It needs to be a directory."
  rm -v ${LFS}/tools
fi
if [ ! -d ${LFS}/tools ]; then install -vm755 -d ${LFS}/tools; fi
tar -xvf ${LFS}${sourcedir}/${pkguserFile} -C ${LFS}/tools --no-same-owner
if [ $? -ne 0 ]; then
  return $RETURN_PARAM
else
  rm ${LFS}${sourcedir}/${pkguserFile}
  return 0
fi
} #end unpackPkguser
#
copypkguserbin () { # when installing as root, may need listdelpkg.sh
cat >> $Output << "EOF"
copypkguserbin_ () {
FuncName=copypkguserbin
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName" #package already built so skip
  return 0
else
  echo "In function $FuncName"
fi
EOF
echo "pkguserdir=/tools/${pkgFileName}" >> $Output
cat >> $Output << "EOF"
cp ${pkguserdir}/bin/* /usr/bin/
echo "${FuncName}" >> $BuildLog
}
EOF
} # end copypkguserbin
#
pkguser () {
cat >> $Output << "EOF"
pkguser_ () {
FuncName=pkguser
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName" #package already built so skip
  return 0
else
  echo "In function $FuncName"
fi
EOF
echo "local pkguserdir=/tools/${pkgFileName}" >> $Output
cat >> $Output << "EOF"
cp ${pkguserdir}/sbin/* /usr/bin # groupadd, su and useradd (packages from shadow)
cp ${pkguserdir}/usr/sbin/* /usr/bin # installpkg
if [ $(uname -m) = x86_64 ]; then
  mv /usr/bin/su64 /usr/bin/su
  chmod 0755 /usr/bin/su
else
  echo "This doesn't exist"
  echo "You need to create su32 using shadow - aborting"
  exit 1
  mv /usr/bin/su32 /usr/bin/su
fi
if [ ! -d /etc/pkgusr/skel-package ]; then
  install -v -m0755 -d /etc/pkgusr/skel-package
fi
cp -r ${pkguserdir}/etc/* /etc/pkgusr/ # bash_profile, bashrc, skel-package symlinks
cp ${pkguserdir}/bin/* /usr/bin/ # listdelpkg.sh
# make them executable
chmod 755 /usr/bin/{groupadd,useradd,su,installpkg,listdelpkg.sh}
#
if [ "$(grep -q ^install\: /etc/group;echo $?)" != 0 ]; then
  groupadd -g 9999 install
fi
# make sure pkgusers can write to the logfile
chgrp install $BuildLog
chmod 664 $BuildLog
# set some initial dirs to install and sticky
chgrp 9999 $(cat ${pkguserdir}/installdirs.lst)
chmod 1775 $(cat ${pkguserdir}/installdirs.lst)
EOF
# if using sysvinit for init then build uses /usr/libexec
if [ "$SYSTEMD" = no ]; then
  echo "chgrp install /usr/libexec
chmod 1775 /usr/libexec" >> $Output
fi
cat >> $Output << "EOF"
#
cat >> /etc/pkgusr/bash_profile << "BashProfile"
#
complete -o default -o nospace -A user su finger pinky
export PkgName=$LOGNAME
EOF
echo "Chapter=$Chapter
testBuilt=\".\${Chapter/apter/}\${LOGNAME}\"" >> $Output
echo "if [ -e /usr/src/core/\${LOGNAME}/${build} -a ! -e ~/\${testBuilt} ]; then
  cd
  bash -e /usr/src/core/\${LOGNAME}/${build}" >> $Output
cat >> $Output << "EOF"
  exit
fi
BashProfile
install -v -d /usr/src/core/${LOGNAME}
echo "${FuncName}" >> $BuildLog
}
EOF
} # end of pkguser
#
resetBashProfile () {
# recreates bash_profile in /etc/pkgusr to reflect changes in chapter
cat >> $Output << "EOF"
resetBashProfile_ () {
cat > /etc/pkgusr/bash_profile << "BASHPEOF"
export PATH=/bin:/usr/bin

# Make prompt reflect that we are a package user.
export PROMPT_COMMAND='PS1="package \u:"`pwd`"> "'

# Go to the home directory when su to a package user.
cd
#
#
complete -o default -o nospace -A user su finger pinky
export PkgName=$LOGNAME
EOF
echo "Chapter=$Chapter" >> $Output
if [ "$Chapter" = update ]; then
  testBuilt=".\${LOGNAME}-\${Chapter}"
else
  testBuilt=".\${Chapter/apter/}\${LOGNAME}"
fi
echo "testBuilt=\"$testBuilt\"" >> $Output
cat >> $Output << "EOF"
if [ -e /usr/src/core/${LOGNAME}/build -a ! -e ~/${testBuilt} ]; then
  cd
  bash -e /usr/src/core/${LOGNAME}/build
  exit
fi
BASHPEOF
} # resetBashProfile
EOF
} # resetBashProfile
#
update_pkguser () {
cat >> $Output << "EOF"
update_pkguser_ () {
FuncName=update_pkguser
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName" #package already built so skip
  return
fi
EOF
echo "pkguserdir=/tools/${pkgFileName}" >> $Output
cat >> $Output << "EOF"
cp ${pkguserdir}/sbin/* /usr/bin # groupadd, su and useradd (packages from shadow)
cp ${pkguserdir}/usr/sbin/* /usr/bin # installpkg
if [ $(uname -m) = x86_64 ]; then
  mv /usr/bin/su64 /usr/bin/su
else
  echo "This doesn't exist"
  echo "You need to create su32 using shadow - aborting"
  exit 1
  mv /usr/bin/su32 /usr/bin/su
fi
# make sure pkgusers can write to the logfile
chgrp install $BuildLog
chmod 664 $BuildLog
#
cat > /etc/pkgusr/bash_profile << "BashProfile"
export PATH=/bin:/usr/bin:/opt/jdk/bin:/opt/ant/bin:/opt/qt/bin
export PROMPT_COMMAND='PS1="package \u:"$(pwd)"> "'
cd
EOF
echo "PkgUserDir=$PkgUserDir" >> $Output
cat >> $Output << "EOF"
complete -o default -o nospace -A user su finger pinky
export PkgName=$LOGNAME
EOF
if $useDESTDIR; then
  echo "if [ -e \${PkgUserDir}/\${LOGNAME}/${build} -a ! -e ~/.\${LOGNAME}-destdir ]; then
  cd
  bash \${PkgUserDir}/\${LOGNAME}/$build" >> $Output
else
  echo "if [ -e \${PkgUserDir}/\${LOGNAME}/$build -a ! -e ~/.\${LOGNAME} ]; then
  cd
  bash \${PkgUserDir}/\${LOGNAME}/$build" >> $Output
fi
cat >> $Output << "EOF"
  exit
fi
BashProfile
echo "${FuncName}" >> $BuildLog
}
EOF
} # end update_pkguser
#
delSrcFile () {
echo "cd \$curdir
cd ..
rm -rf \$curdir
rm -rf .wget-hsts"
} # end of delSrcFile
#
setUserEnv () {
cat >> $Output << "EOF"
setUserEnv () {
# delete the .bashrc and .bash_profile files in /usr/src/core/PkgName and
# replace with symlinks to /etc/pkgusr versions. Used in chroot so no LFS needed
# $1 is the package user directory usually /usr/src/core
# $2 is the package name
local PkgUserDir=$1
local PkgName=$2
pushd ${PkgUserDir}/${PkgName}
# make sure .bash_profile and .basrc are symlinks to /etc/pkgusr
rm -rf .bash_profile .bashrc
ln -svf /etc/pkgusr/bash_profile .bash_profile
ln -svf /etc/pkgusr/bashrc .bashrc
chown -h $PkgName:$PkgName .bash*
popd
} # end setUserEnv
EOF
} # end setUserEnv
#
createPkgfile () {
cat >> $Output << "EOF"
createPkgfile () {
# get dir names, make the package tar file and delete the build directories
# if present, $1 is the version number to use, bypassing SetPkgVers
local listDIRS
local packageName
local pkgfilename
local trimto=".tar"
#
pushd ${PkgUserDir}/${PkgName} # make sure in the right dir
listDIRS=$(ls -l --time-style="long-iso" . | egrep '^d' | awk '{print $8}')
# check the dirs present so as not to delete any needed ones
local chknum=( $listDIRS )
for (( i=0; i<${#chknum[@]}; i++ )); do
  if [[ ${chknum[i]} != etc && ${chknum[i]} != usr && ${chknum[i]} != var ]]; then
    echo "Directory ${chknum[i]} will be included in the package file"
    echo "Is this correct? (Y/n)"
    read reply
      case $reply in
         [yY]|[yY][Ee][Ss])
              echo "okay continuing"
         ;;
         [nN]|[nN][Oo])
              echo "Then you need to move it out of ${PkgUserDir}/${PkgName}"
              echo "Exiting now"
              exit 1
         ;;
         *)
              echo "okay continuing"
         ;;
      esac
  fi
done
# add the .INSTALL file if present
if [ -e .INSTALL ]; then
  listDIRS="$listDIRS .INSTALL"
fi
rtrnpkgname=""
case $PkgName in
   acl|attr)
      packageName=$PkgName
      trimto=".src"
   ;;
   xml-parser)
      packageName="XML-Parser"
   ;;
   kernel)
      packageName="linux"
   ;;
   *)
      packageName=$PkgName
   ;;
esac
if [ $(uname -m) = x86_64 ]; then
  local extension="x86_64.pkg.tar.xz"
else
  local extension="i686.pkg.tar.xz"
fi
if [ ! -z "$1" ]; then
  pkgfilename="${packageName}-${1}-${extension}"
else
  SetPkgVers $packageName $trimto
  pkgfilename="${rtrnpkgname}-${extension}"
fi
echo "pkgfilename is $pkgfilename"
tar -cJf $pkgfilename $listDIRS
if ! $AS_ROOT; then chown $PkgName:$PkgName $pkgfilename; fi
for dir in $listDIRS; do
  if [ -d $dir ]; then
    echo "Delete dir $dir? (Y/n)"
  elif [ -f $dir ]; then
    echo "Delete file $dir? (Y/n)"
  fi
  read reply
    case $reply in
         [yY]|[yY][Ee][Ss])
              echo "okay deleting $dir"
              rm -rf $dir
         ;;
         [nN]|[nN][Oo])
              echo "okay continuing"
         ;;
         *)
              echo "okay deleting $dir"
              rm -rf $dir
         ;;
    esac
done
popd
} # end createPkgfile
EOF
} # end createPkgfile
#
getUrlSrcDnld () {
# get the url to download the src file and, if downloaded already, the location to copy it
# $1 is either unpack or unpack07, depending either ! root or root install, respectively
local unpackType=$1
for srcURL in ${sourceURL[@]}; do
  serchstr="*$SrcName*"
  useThisSrcLoc=""
  case $FuncName in # can modify the src file name to search for
# and add the location for already downloaded src files
     bash|coreutils|diffutils|file|findutils|gawk|glibc|grep|gzip|m4|ncurses|openssl|patch|sed|tar|xz)
       useThisSrcLoc="/build/${FuncName}"
     ;;
     binutils)
       useThisSrcLoc="/build/binutilspass1"
     ;;
     gmp|libstdc++pass2|mpc|mpfr)
       useThisSrcLoc="/build/gccpass1"
     ;;
     kernel)
       serchstr="*/linux-[0-9]*"
       useThisSrcLoc="/build/linuxheaders"
     ;;
     linuxheaders)
       if [ "$WHICH_CHAPTER" = update ]; then # test if linux version is up-to-date
         serchstr="*/linux-[0-9]*"
         if [ "$linuxcomvers" = "$latestVers" ]; then # use this one
           useThisSrcLoc="/usr/src/core/kernel"
         fi
       fi
     ;;
     make) # get make not automake
       serchstr="*/make-[0-9]*"
       useThisSrcLoc="/build/${FuncName}"
     ;;
  esac
  case $srcURL in
     $serchstr)
       echo "$unpackType \$SrcName \"$srcURL\" \"$useThisSrcLoc\"" >> $Output
       break
     ;;
  esac
done
} # end getUrlSrcDnld
#
dnldAddFiles () {
case $FuncName in
#   autoconf) # need the patch
#     cat >> $Output << "EOF"
#if [ -e ${CUR_DIR}/autoconf-*-consolidated_fixes-1.patch  ]; then
#  echo "patch already in place - will use that"
#elif [ -e ${sourceloc}/autoconf-*-consolidated_fixes-1.patch  ]; then
#  cp -v ${sourceloc}/autoconf-*-consolidated_fixes-1.patch ../
#else # download it
#  if [ -e /usr/bin/wget ]; then # wget exists on target machine
#    wget $wgetopts -O ../autoconf-2.69-consolidated_fixes-1.patch "http://www.linuxfromscratch.org/patches/lfs/development/autoconf-2.69-consolidated_fixes-1.patch"
#  else
#    echo "/usr/bin/wget not found on the target machine"
#    echo "Install it to continue"
#    echo "Aborting"
#    exit 1
#  fi
#fi
#EOF
#   ;;
#   bash) # need the patch
#     cat >> $Output << "EOF"
#if [ -e ${CUR_DIR}/bash-*-upstream_fixes-1.patch ]; then
#  echo "patch already in place - will use that"
#elif [ -e ${sourceloc}/bash-*-upstream_fixes-1.patch ]; then
#  cp -v ${sourceloc}/bash-*-upstream_fixes-1.patch ../
#else # download it
#  if [ -e /usr/bin/wget ]; then # wget exists on target machine
#    wget $wgetopts -O ../bash-5.0-upstream_fixes-1.patch "http://www.linuxfromscratch.org/patches/lfs/development/bash-5.0-upstream_fixes-1.patch"
#  else
#    echo "/usr/bin/wget not found on the target machine"
#    echo "Install it to continue"
#    echo "Aborting"
#    exit 1
#  fi
#fi
#EOF
#   ;;
   bzip2) # need the patch
     echo "bzip2Patch=\"$bzip2Patch\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${bzip2Patch} ]; then
  echo "patch already in place - will use that"
elif [ -e ${sourceloc}/${bzip2Patch} ]; then
  cp -v ${sourceloc}/${bzip2Patch} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts -O ../${bzip2Patch} "http://www.linuxfromscratch.org/patches/lfs/development/${bzip2Patch}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
   coreutils) # need the patch
     echo "coreutilsPatch=\"$coreutilsPatch\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${coreutilsPatch} ]; then
  echo "patch already in place - will use that"
elif [ -e ${sourceloc}/${coreutilsPatch} ]; then
  cp -v ${sourceloc}/${coreutilsPatch} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts -O ../${coreutilsPatch} "http://www.linuxfromscratch.org/patches/lfs/development/${coreutilsPatch}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
   glibc) # need the patch and the time zone data
     echo "glibcPatch=\"glibc-${glibcvers}-fhs-1.patch\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${glibcPatch} ]; then
  echo "$glibcPatch patch already in $CUR_DIR, will use that"
elif [ -e ${sourceloc}/${glibcPatch} ]; then
  cp -v ${sourceloc}/${glibcPatch} ../
else
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts -O ../${glibcPatch} http://www.linuxfromscratch.org/patches/lfs/development/${glibcPatch}
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
     echo "tzdataFile=\"$tzdataFile\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${tzdataFile} ]; then
  echo "$tzdataFile file already downloaded - will use that one"
elif [ -e ${sourceloc}/${tzdataFile} ]; then
  cp -v ${sourceloc}/${tzdataFile} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../${tzdataFile} "https://www.iana.org/time-zones/repository/releases/${tzdataFile}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
   kbd) # need the patch
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/kbd-*-backspace-1.patch ]; then
  echo "patch already in place - will use that"
elif [ -e ${sourceloc}/kbd-*-backspace-1.patch ]; then
  cp -v ${sourceloc}/kbd-*-backspace-1.patch ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../kbd-2.4.0-backspace-1.patch "http://www.linuxfromscratch.org/patches/lfs/development/kbd-2.4.0-backspace-1.patch"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
   kernel) # if making the kernel, need to add mproper
     if [ "$MAKE_KERNEL" = yes ]; then
       cat >> $Output << "EOF"
make mrproper
cp ${sourcedir}/.config .
# copy the firmware to /usr/lib/firmware
cp -r /tools/pkguser/firmware/* /usr/lib/firmware/
EOF
     fi
   ;;
#   meson) # need the patch
#     cat >> $Output << "EOF"
#if [ -e ${CUR_DIR}/meson-0.56.0-upstream_fix-1.patch ]; then
#  echo "patch already in place - will use that"
#elif [ -e ${sourceloc}/meson-0.56.0-upstream_fix-1.patch ]; then
#  cp -v ${sourceloc}/meson-0.56.0-upstream_fix-1.patch ../
#else # download it
#  if [ -e /usr/bin/wget ]; then # wget exists on target machine
#    wget $wgetopts $ncc -O ../meson-0.56.0-upstream_fix-1.patch "http://www.linuxfromscratch.org/patches/lfs/development/meson-0.56.0-upstream_fix-1.patch"
#  else
#    echo "/usr/bin/wget not found on the target machine"
#    echo "Install it to continue"
#    echo "Aborting"
#    exit 1
#  fi
#fi
#EOF
#   ;;
   systemd) # need the patch and man-pages
     echo "systemdPatch=\"$systemdPatch\"
systemdManPages=\"$systemdManPages\"" >> $Output
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${systemdManPages} ]; then
  echo "systemd-man-pages already downloaded - will use that one"
elif [ -e ${sourceloc}/${systemdManPages} ]; then
  cp -v ${sourceloc}/${systemdManPages} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../${systemdManPages} "http://anduin.linuxfromscratch.org/LFS/${systemdManPages}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
if [ -e ${CUR_DIR}/${systemdPatch} ]; then
  echo "patch already in place - will use that"
elif [ -e ${sourceloc}/${systemdPatch} ]; then
  cp -v ${sourceloc}/${systemdPatch} ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../${systemdPatch} "http://www.linuxfromscratch.org/patches/lfs/development/${systemdPatch}"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
   tcl) # need the html file
     cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${SrcName}*html.tar.*z* ]; then
  echo "tcl8 html file already downloaded - will use that one"
elif [ -e ${sourceloc}/${SrcName}*html.tar.*z* ]; then
  cp -v ${sourceloc}/${SrcName}*html.tar.*z* ../
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on target machine
    wget $wgetopts $ncc -O ../tcl8.6.11-html.tar.gz "https://downloads.sourceforge.net/tcl/tcl8.6.11-html.tar.gz"
  else
    echo "/usr/bin/wget not found on the target machine"
    echo "Install it to continue"
    echo "Aborting"
    exit 1
  fi
fi
EOF
   ;;
esac
} # end dnldAddFiles
#
setInstallDirs () {
#set required dirs to be install dirs
case $PkgName in
   autoconf|automake|bc|diffutils|findutils|flex|gawk|gdbm|gettext|gperf|groff|gzip|libtool|m4|make|tar|texinfo)
     if $useDESTDIR; then # include the INSTALL file
       cat >> $Output << "EOF"
install -m644 ${pkguserdir}/installFiles/${PkgName}/INSTALL ${PkgUserDir}/${PkgName}/.INSTALL
if ! $AS_ROOT; then chown $PkgName:$PkgName ${PkgUserDir}/${PkgName}/.INSTALL; fi
EOF
     fi
   ;;
   bash) #/usr/share/aclocal
     if ! $useDESTDIR; then
        cat >> $Output << "EOF"
chgrp install /usr/share/aclocal
chmod g+w,o+t /usr/share/aclocal
chown -h bash:bash /bin/sh
EOF
     fi
   ;;
   binutils)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/lib/bfd-plugins
chmod g+w,o+t /usr/lib/bfd-plugins
EOF
     fi
   ;;     
   bison)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/aclocal
chmod g+w,o+t /usr/share/aclocal
EOF
     fi
   ;;
   bzip2) # prepare locales for installation
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/locale/*/LC_MESSAGES
chmod g+w,o+t /usr/share/locale/*/LC_MESSAGES
chgrp install /usr/share/doc
chmod g+w,o+t /usr/share/doc
EOF
     fi
   ;;
   coreutils)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown 0:coreutils /etc/{group,group-}
chmod 644 /etc/{group,group-}
EOF
     else # useDESTDIR
       cat >> $Output << "EOF"
install -m644 ${pkguserdir}/installFiles/${PkgName}/INSTALL ${PkgUserDir}/${PkgName}/.INSTALL
if ! $AS_ROOT; then chown $PkgName:$PkgName ${PkgUserDir}/${PkgName}/.INSTALL; fi
EOF
     fi
   ;;
   dejagnu)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown root:install /usr/share/info/{,dir}
chmod g+w,o+t /usr/share/info
chmod 664 /usr/share/info/dir
EOF
     fi
   ;;
   dbus)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown root /usr/lib/dbus-1.0/dbus-daemon-launch-helper
chmod 4750 /usr/lib/dbus-1.0/dbus-daemon-launch-helper
chgrp install /usr/lib/dbus-1.0
chmod g+w,o+t /usr/lib/dbus-1.0
chgrp install /usr/share/dbus-1
chmod g+w,o+t /usr/share/dbus-1
chgrp install /usr/share/dbus-1/services
chmod g+w,o+t /usr/share/dbus-1/services
chgrp install /usr/share/dbus-1/system-services
chmod g+w,o+t /usr/share/dbus-1/system-services
chgrp install /usr/include/dbus-1.0/dbus
chmod g+w,o+t /usr/include/dbus-1.0/dbus
chgrp install /usr/lib/systemd/
chmod g+w,o+t /usr/lib/systemd/
chgrp install /usr/lib/systemd/system
chmod g+w,o+t /usr/lib/systemd/system
chgrp install /usr/lib/systemd/system/sockets.target.wants
chmod g+w,o+t /usr/lib/systemd/system/sockets.target.wants
chgrp install /usr/lib/systemd/system/multi-user.target.wants
chmod g+w,o+t /usr/lib/systemd/system/multi-user.target.wants
EOF
     else
       cat >> $Output << "EOF"
chown root ${PkgUserDir}/${PkgName}/usr/lib/dbus-1.0/dbus-daemon-launch-helper
chmod 4750 ${PkgUserDir}/${PkgName}/usr/lib/dbus-1.0/dbus-daemon-launch-helper
mkdir -pv ${PkgUserDir}/${PkgName}/run/dbus
chown 0:0 ${PkgUserDir}/${PkgName}/run
chown dbus:dbus ${PkgUserDir}/${PkgName}/run/dbus
chmod 1777 ${PkgUserDir}/${PkgName}/run
rm -rf ${PkgUserDir}/${PkgName}/var
EOF
     fi
   ;;
   eudev)
     cat >> $Output << "EOF"
chgrp install /lib/udev/rules.d
chmod g+w,o+t /lib/udev/rules.d
chgrp install /lib/firmware
chmod g+w,o+t /lib/firmware
EOF
   ;;
   file)
     cat >> $Output << "EOF"
rm -rf ${PkgUserDir}/${PkgName}/usr/share/man/man5 # this is empty
EOF
   ;;
   glibc) #/usr/share/info/dir
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown root:install /usr/share/info/dir
chmod 664 /usr/share/info/dir
chgrp install /usr/include/sys # for libcap
chmod g+w,o+t /usr/include/sys
if [ -d /usr/lib/systemd ]; then
  chgrp install /usr/lib/systemd
  chmod g+w,o+t /usr/lib/systemd
  chgrp install /usr/lib/systemd/system
  chmod g+w,o+t /usr/lib/systemd/system
  chgrp install /usr/lib/tmpfiles.d
  chmod g+w,o+t /usr/lib/tmpfiles.d
fi
# check the symlink ld-linux.so.2 is set up
if [ ! -L /usr/lib/ld-linux.so.2 ]; then
EOF
       echo "  ln -svf ld-${glibcvers}.so /usr/lib/ld-linux.so.2" >> $Output
       cat >> $Output << "EOF"
fi
if ! $AS_ROOT; then chown -h glibc:glibc /usr/lib/ld-linux.so.2; fi
EOF
     fi
   ;;
   grub)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /etc/bash_completion.d
chmod g+w,o+t /etc/bash_completion.d
EOF
     else # install the .INSTALL file
       cat >> $Output << "EOF"
install -m644 ${pkguserdir}/installFiles/${PkgName}/INSTALL ${PkgUserDir}/${PkgName}/.INSTALL
if ! $AS_ROOT; then chown $PkgName:$PkgName ${PkgUserDir}/${PkgName}/.INSTALL; fi
EOF
     fi
   ;;
   inetutils) # ping, etc setuid root
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown root /bin/ping*
chmod 4755 /bin/ping*
chown root /bin/traceroute
chmod 4755 /bin/traceroute
EOF
     else
       cat >> $Output << "EOF"
chown root ${PkgUserDir}/${PkgName}/usr/bin/ping*
chmod 4755 ${PkgUserDir}/${PkgName}/usr/bin/ping*
chown root ${PkgUserDir}/${PkgName}/usr/bin/traceroute
chmod 4755 ${PkgUserDir}/${PkgName}/usr/bin/traceroute
EOF
     fi
   ;;
   iproute2)
     if $useDESTDIR; then
       cat >> $Output << "EOF"
mkdir -pv ${PkgUserDir}/${PkgName}/usr/bin
mv ${PkgUserDir}/${PkgName}/sbin/* ${PkgUserDir}/${PkgName}/usr/bin
rm -rf ${PkgUserDir}/${PkgName}/sbin
if ! $AS_ROOT; then
  chown -R -h iproute2:iproute2 ${PkgUserDir}/${PkgName}/usr/bin
fi
EOF
     fi
   ;;
   kmod)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/bash-completion/completions
chmod g+w,o+t /usr/share/bash-completion/completions
EOF
     fi
   ;;
   linux-headers) #/usr/include/scsi
     cat >> $Output << "EOF"
chgrp install /usr/include/scsi
chmod g+w,o+t /usr/include/scsi
EOF
   ;;
   man-db) #/es,it
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/man/it
chgrp install /usr/share/man/it/man*
chmod g+w,o+t /usr/share/man/it
chmod g+w,o+t /usr/share/man/it/man*
EOF
     fi
   ;;
   man-pages)
     cat >> $Output << "EOF"
chgrp install /usr/share/man/{,man{1..8}}
chmod 1775 /usr/share/man/{,man{1..8}}
EOF
     if $useDESTDIR; then
       cat >> $Output << "EOF"
# these are included in coreutils
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man1/{chgrp,chmod,chown,cp,dir,dd}.1
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man1/{df,dircolors,du,install,ln,ls}.1
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man1/{mkdir,mkfifo,mknod,mv,rm,rmdir}.1
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man1/{touch,vdir}.1
# this is included in shadow
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man5/passwd.5
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man3/getspnam.3
# this is included in diffutils
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man1/diff.1
# this is included in xf86-input-mouse
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man4/mouse.4
# this is included in attr
rm -f ${PkgUserDir}/${PkgName}/usr/share/man/man5/attr.5
EOF
     fi
   ;;
   meson)
     cat >> $Output << "EOF"
cat > /usr/bin/arch-meson << "MESONEOF"
#!/bin/bash -ex
# Arch Linux Meson wrapper

exec meson setup \
  --prefix         /usr \
  --libdir         /usr/lib \
  --libexecdir     /usr/lib \
  --bindir         /usr/bin \
  --sbindir        /usr/bin \
  --includedir     /usr/include \
  --datadir        /usr/share \
  --mandir         /usr/share/man \
  --infodir        /usr/share/info \
  --localedir      /usr/share/locale \
  --sysconfdir     /etc \
  --localstatedir  /var \
  --sharedstatedir /var/lib \
  --wrap-mode      nodownload \
  -D               b_lto=true \
  -D               b_pie=true \
  "$@"
MESONEOF
chmod 755 /usr/bin/arch-meson
if ! $AS_ROOT; then chown $PkgName:$PkgName /usr/bin/arch-meson; fi
EOF
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/polkit-1
chgrp install /usr/share/polkit-1/actions
chmod g+w,o+t /usr/share/polkit-1
chmod g+w,o+t /usr/share/polkit-1/actions
EOF
     fi
   ;;
   ncurses)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown 0.0 /etc/ld.so.cache
EOF
     fi
   ;;
   ninja)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/zsh/site-functions
chmod g+w,o+t /usr/share/zsh/site-functions
EOF
     fi
   ;;
   openssl)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /etc/ssl/{,certs}
chmod g+w,o+t /etc/ssl/{,certs}
EOF
     fi
   ;;
   perl)
     if ! $useDESTDIR; then
       echo "case \$(uname -m) in
   x86_64) archi=x86_64-linux-thread-multi
   ;;
   *)      archi=i686-linux-thread-multi
   ;;
esac
chgrp install /usr/lib/perl5/${perlseries}/{core_perl,site_perl}
chmod g+w,o+t /usr/lib/perl5/${perlseries}/{core_perl,site_perl}" >> $Output
     fi
   ;;
   pkg-config) #/usr/share/aclocal
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/aclocal
chmod g+w,o+t /usr/share/aclocal
chgrp install /usr/lib/pkgconfig
chmod g+w,o+t /usr/lib/pkgconfig
EOF
     fi
   ;;
   python3)
     if ! $useDESTDIR; then
       echo "chgrp install /usr/lib/python${pythonseries}/site-packages
chmod g+w,o+t /usr/lib/python${pythonseries}/site-packages" >> $Output
     fi
   ;;
   shadow)
     if [[ "$Chapter" != update && "$useDESTDIR" = false ]]; then # need pwconv and grpconv
       cat >> $Output << "EOF"
pwconv
grpconv
EOF
     fi
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown 0:shadow /etc/{group,group-,gshadow,gshadow-,passwd,passwd-,shadow,shadow-}
chmod 644 /etc/{group,group-,passwd,passwd-}
chmod 640 /etc/{gshadow,gshadow-,shadow,shadow-}
EOF
       if [ "$SYSTEMD" = yes ]; then
         echo "chown root /usr/bin/{chage,chfn,chsh,expiry,gpasswd,newgidmap,newgrp,newuidmap,passwd,su}
chmod 4755 /usr/bin/{chage,chfn,chsh,expiry,gpasswd,newgidmap,newgrp,newuidmap,passwd,su}" >> $Output
       else
         echo "chown root /bin/passwd
chmod 4755 /bin/passwd" >> $Output
       fi
     else # using DESTDIR
       cat >> $Output << "EOF"
rm ${PkgUserDir}/${PkgName}/usr/sbin/{vipw,vigr} # use util-linux version
rm ${PkgUserDir}/${PkgName}/usr/bin/nologin # provided by util-linux
find ${PkgUserDir}/${PkgName}/usr/share/man \
      '(' -name 'nologin.8' -o \
          -name 'vipw.8'    -o \
          -name 'vigr.8' ')' \
      -delete
chown root ${PkgUserDir}/${PkgName}/usr/bin/{chage,chfn,chsh,expiry,gpasswd,newgidmap,newgrp,newuidmap,passwd,su}
chmod 4755 ${PkgUserDir}/${PkgName}/usr/bin/{chage,chfn,chsh,expiry,gpasswd,newgidmap,newgrp,newuidmap,passwd,su}
mv ${PkgUserDir}/${PkgName}/usr/sbin/* ${PkgUserDir}/${PkgName}/usr/bin/
rm -rf ${PkgUserDir}/${PkgName}/usr/sbin
install -m644 ${pkguserdir}/installFiles/${PkgName}/INSTALL ${PkgUserDir}/${PkgName}/.INSTALL
if ! $AS_ROOT; then chown $PkgName:$PkgName ${PkgUserDir}/${PkgName}/.INSTALL; fi
EOF
     fi
   ;;
   systemd)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/lib/udev/rules.d
chmod g+w,o+t /usr/lib/udev/rules.d
chgrp install /etc/udev/rules.d
chmod g+w,o+t /etc/udev/rules.d
chgrp install /usr/share/pkgconfig
chmod g+w,o+t /usr/share/pkgconfig
chgrp install /usr/share/polkit-1 # for polkit
chmod g+w,o+t /usr/share/polkit-1
chgrp install /usr/share/polkit-1/actions
chmod g+w,o+t /usr/share/polkit-1/actions
chgrp install /usr/share/dbus-1
chmod g+w,o+t /usr/share/dbus-1
chgrp install /etc/xdg # for at-spi2-core
chmod g+w,o+t /etc/xdg
chgrp install /usr/share/bash-completion/completions
chmod g+w,o+t /usr/share/bash-completion/completions
chgrp install /usr/lib/systemd/system
chmod g+w,o+t /usr/lib/systemd/system
chgrp install /usr/lib/systemd/system/sockets.target.wants # for dbus
chmod g+w,o+t /usr/lib/systemd/system/sockets.target.wants
chgrp install /usr/lib/systemd/system/multi-user.target.wants
chmod g+w,o+t /usr/lib/systemd/system/multi-user.target.wants
chgrp install /usr/lib/tmpfiles.d
chmod g+w,o+t /usr/lib/tmpfiles.d
chown root:systemd-journal /var/log/journal
chmod 2755 /var/log/journal
chown 0:0 /usr # had to change it to systemd to allow time update
systemctl preset-all
systemctl disable systemd-time-wait-sync.service
rm -f /etc/sysctl.d/50-pid-max.conf
rm -fv /usr/lib/lib{blkid,uuid,mount}.so*
rm -f /usr/lib/tmpfiles.d/systemd-nologin.conf
EOF
     else
       cat >> $Output << "EOF"
chown root:systemd-journal ${PkgUserDir}/${PkgName}/var/log/journal
chmod 2755 ${PkgUserDir}/${PkgName}/var/log/journal
install -m644 ${pkguserdir}/installFiles/${PkgName}/INSTALL ${PkgUserDir}/${PkgName}/.INSTALL
if ! $AS_ROOT; then chown systemd:systemd ${PkgUserDir}/${PkgName}/.INSTALL; fi
# only use these if the compat-libs patch is not available
#install -m644 ${pkguserdir}/usr/lib/pkgconfig/*.pc ${PkgUserDir}/${PkgName}/usr/lib/pkgconfig/
#if ! $AS_ROOT; then chown systemd:systemd ${PkgUserDir}/${PkgName}/usr/lib/pkgconfig/*.pc; fi
EOF
     fi
   ;;
   sysvinit)
     cat >> $Output << "EOF"
rm -f /dev/initctl
mknod -m 600 /dev/initctl p
EOF
   ;;
   util-linux) # mount setuid root
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chown root /bin/{mount,umount}
chmod 4755 /bin/{mount,umount}
chown root:tty /usr/bin/wall
chmod 2755 /usr/bin/wall
chgrp install /usr/share/bash-completion/completions
chmod g+w,o+t /usr/share/bash-completion/completions
EOF
       if [ "$SYSTEMD" = yes ]; then
         cat >> $Output << "EOF"
chgrp install /usr/lib/systemd # if dbus installed
chmod g+w,o+t /usr/lib/systemd
chgrp install /usr/lib/systemd/system
chmod g+w,o+t /usr/lib/systemd/system
chgrp install /usr/share/bash-completion/completions
chmod g+w,o+t /usr/share/bash-completion/completions
EOF
         if [ "$currentChapter" = chapter08 ]; then
           cat >> $Output << "EOF"
# do this here because libmount is now installed
systemd-machine-id-setup
chown systemd:systemd /etc/machine-id
EOF
         fi
       fi
       cat >> $Output << "EOF"
chown root /usr/bin/su
chmod 4755 /usr/bin/su
EOF
     else
       cat >> $Output << "EOF"
chown root ${PkgUserDir}/${PkgName}/usr/bin/{mount,umount}
chmod 4755 ${PkgUserDir}/${PkgName}/usr/bin/{mount,umount}
chown root:tty ${PkgUserDir}/${PkgName}/usr/bin/wall
chmod 2755 ${PkgUserDir}/${PkgName}/usr/bin/wall
mv ${PkgUserDir}/${PkgName}/usr/sbin/* ${PkgUserDir}/${PkgName}/usr/bin/
rm -rf ${PkgUserDir}/${PkgName}/usr/sbin
EOF
     fi
   ;;
   vim)
     if ! $useDESTDIR; then
       cat >> $Output << "EOF"
chgrp install /usr/share/man/fr*
chgrp install /usr/share/man/it*
chgrp install /usr/share/man/ja
chgrp install /usr/share/man/pl*
chgrp install /usr/share/man/ru*
chmod g+w,o+t /usr/share/man/fr*
chmod g+w,o+t /usr/share/man/it*
chmod g+w,o+t /usr/share/man/ja
chmod g+w,o+t /usr/share/man/pl*
chmod g+w,o+t /usr/share/man/ru*
EOF
     fi
   ;;
   xml-parser)
     if ! $useDESTDIR; then
echo "chgrp install /usr/lib/perl5/${perlseries}/site_perl/XML
chmod g+w,o+t /usr/lib/perl5/${perlseries}/site_perl/XML
chgrp install /usr/lib/perl5/${perlseries}/site_perl/auto
chmod g+w,o+t /usr/lib/perl5/${perlseries}/site_perl/auto
chgrp install /usr/lib/perl5/${perlseries}/site_perl/auto/XML
chmod g+w,o+t /usr/lib/perl5/${perlseries}/site_perl/auto/XML
chgrp install /usr/lib/perl5/${perlseries}/core_perl/perllocal.pod
chmod 664 /usr/lib/perl5/${perlseries}/core_perl/perllocal.pod" >> $Output
     fi
   ;;
esac
} # end setInstallDirs
#
Function () {
case $PkgName in
    changingowner)
        if [[ $as_root && "$Chapter" != update ]]; then
          WriteScript
          return
        fi
    ;;
    kernfs|chroot)
        if [ "$Chapter" != update ]; then
          WriteScript
          return
        fi
    ;;
esac
echo "${FuncName}_ () {" >> $Output
case $Chapter in
    all|chapter05|chapter06|chapter07|chapter08|chapter10)
        case "$Chapter" in
            chapter05|chapter06)
              echo "FuncName=$FuncName
PkgName=$PkgName" >> $Output
              if $as_root; then
                TestBuiltCh56
                echo "SrcName=$SrcName
starttime=\$( date +%s )" >> $Output
                cat >> $Output << "EOF"
# check env variables set correctly
echo "Running as $(whoami)"
if [ "$LFS" != /mnt/lfs ]; then
  echo "LFS is $LFS"
  echo "It should be /mnt/lfs"
  echo "Abort"
  exit 1
fi
if [ "$LFS_TGT" != x86_64-lfs-linux-gnu ]; then
  echo "LFS_TGT is $LFS_TGT"
  echo "It should be x86_64-lfs-linux-gnu"
  echo "Abort"
  exit 1
fi
EOF
                echo "CreateBuildDir \$FuncName" >> $Output
# download any additional files
                case $FuncName in
                   gccpass1)
                     if [ "$SOURCES" = atinstall ]; then
                       echo "gmpvers=$gmpvers
mpcvers=$mpcvers
mpfrvers=$mpfrvers" >> $Output
                       cat >> $Output << "EOF"
# download the extra files
gmpFile="gmp-${gmpvers}.tar.xz"
mpcFile="mpc-${mpcvers}.tar.gz"
mpfrFile="mpfr-${mpfrvers}.tar.xz"
if [ -e ${CUR_DIR}/${gmpFile} ]; then
  echo "file $gmpFile already in $CUR_DIR, will use that"
else
  wget $wgetopts http://ftp.gnu.org/gnu/gmp/${gmpFile}
fi
if [ -e ${CUR_DIR}/${mpcFile} ]; then
  echo "file $mpcFile already in $CUR_DIR, will use that"
else
  wget $wgetopts https://ftp.gnu.org/gnu/mpc/${mpcFile}
fi
if [ -e ${CUR_DIR}/${mpfrFile} ]; then
  echo "file $mpfrFile already in $CUR_DIR, will use that"
else
  wget $wgetopts http://www.mpfr.org/mpfr-${mpfrvers}/${mpfrFile}
fi
EOF
                     else
                       cat >> $Output << "EOF"
unpack05 $SrcName
# in chapter5 and chapter6 gcc require unpacking mpfr, mpc and gmp
for i in mpfr gmp mpc
do
  ln -sfv ${LFS}${sourceloc}/${i}*.tar.*z* $CUR_DIR
done
EOF
                     fi
                   ;;
                   gccpass2)
                     if [ "$SOURCES" = atinstall ]; then
                       cat >> $Output << "EOF"
# copy the extra files from gccpass1
if [ -e ${CUR_DIR}/gmp*.tar.*z* ]; then
  echo "a gmp file is already in $CUR_DIR, will use that"
else
  cp -v ${LFS}/build/gccpass1/gmp*.tar.*z* .
fi
if [ -e ${CUR_DIR}/mpc*.tar.*z* ]; then
  echo "an mpc file is already in $CUR_DIR, will use that"
else
  cp -v ${LFS}/build/gccpass1/mpc*.tar.*z* .
fi
if [ -e ${CUR_DIR}/mpfr*.tar.*z* ]; then
  echo "an mpfr file is already in $CUR_DIR, will use that"
else
  cp -v ${LFS}/build/gccpass1/mpfr*.tar.*z* .
fi
EOF
                     else
                       cat >> $Output << "EOF"
unpack05 $SrcName
# in chapter5 and chapter6 gcc require unpacking mpfr, mpc and gmp
for i in mpfr gmp mpc
do
  ln -sfv ${LFS}${sourceloc}/${i}*.tar.*z* $CUR_DIR
done
EOF
                     fi
                   ;;
	           glibc)
                     if [ "$SOURCES" = atinstall ]; then
# download the patch
                       echo "glibcPatch=\"glibc-${glibcvers}-fhs-1.patch\"" >> $Output
                       cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${glibcPatch} ]; then
  echo "patch $glibcPatch already in $CUR_DIR, will use that"
else
  wget $wgetopts http://www.linuxfromscratch.org/patches/lfs/development/${glibcPatch}
fi
EOF
                     else
                       cat >> $Output << "EOF"
unpack05 $SrcName
EOF
                     fi
		   ;;
                   *)
                     echo "unpack05 \$SrcName" >> $Output
                   ;;
                esac
              else # as pkguser
                TestBuiltCh56
		echo "starttime=\$( date +%s )" >> $Output
	        uidVal=0
      	        gidVal=0
                if [ "$FuncName" = binutilspass1 ]; then # set initial value of 10000
  		  uidVal=10000 
		  gidVal=10000
		elif [ "$FuncName" = openssl ]; then # set the GID to 10057, the value in Ch8
                  uidVal=10057
                  gidVal=10057
                elif [ "$FuncName" = wget ]; then # set the GID to 11000, it is deleted at end of LFS
# because it is reinstalled in BLFS
                  uidVal=11000
                  gidVal=11000
	        fi
                echo "uidVal=$uidVal
gidVal=$gidVal" >> $Output
                cat >> $Output << "EOF"
createPkguser $uidVal $gidVal
chown -h -R $PkgName:$PkgName ${PkgUserDir}/${PkgName}
EOF
	        cat >> $Output << "EOF"
# create the install script
cat > ${LFS}/install${PkgName}.sh << "IPS"
EOF
                cat >> $Output << "EOF"
#!/bin/bash -e
#
if [ $UID -eq 0 ]; then 
  echo "Running as root."
EOF
                echo "  echo \"Please run this script as user $PkgName.\"" >> $Output
                cat >> $Output << "EOF"
  exit 1
fi
echo "Running as $(whoami)"
LFS=/mnt/lfs
PkgUserDir=${LFS}/usr/src/core
buildDir=${LFS}/build
BuildLog=${LFS}/LFS-build.log
sourcedir=${LFS}/sources
sourceloc=${sourcedir}/BOOK
EOF
                case $SrcName in
		   libstdc++-)
		     SrcName=gcc-
		   ;;
      	           python-)
	    	     SrcName=Python-
		   ;;
                esac	 
                echo "Chapter=$Chapter
AS_ROOT=$as_root
#" >> $Output
                cat >> $Output << "EOF"
unpack05 () {
# $1 is the source name
# $2 is the url to download the source file
# $3, if present, is the sourceloc of the file already downloaded
sourcelocOld=$sourceloc # sourceloc is global - store it to reset it at the end
local srcname=$1
local srcURL=$2
local altSourceloc=${3:-""}
if [ ! -z "$altSourceloc" ]; then # set sourceloc to this location
  sourceloc=$altSourceloc
fi
echo "sourceloc is $sourceloc"
starttime=$( date +%s )
if [ -e ${CUR_DIR}/${srcname}*.tar.*z* ]; then # src exists in current dir - use that
  echo "$srcname already in current dir - will use that one"
elif [ -e ${LFS}${sourceloc}/${srcname}*.tar.*z* ]; then # src exists so copy it to current dir
  cp -v ${LFS}${sourceloc}/${srcname}*.* . # copy any patches as well
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on the host
    wget $wgetopts $srcURL
  else
    echo "Install wget on the host to continue"
    echo "Aborting"
    exit 1
  fi
fi
cd $(tar vxf ${srcname}*z* | awk -F\/ 'END{print $1}')
curdir=$(echo $PWD)
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
sourceloc=$sourcelocOld
} # end unpack05
#
EOF
                case $FuncName in
                   make|tar|wget) # can't use any name that is a linux command
                     echo "${FuncName}Make () {
FuncName=$FuncName
PkgName=$PkgName
SrcName=$SrcName" >> $Output
                   ;;
                   *)
                     echo "${FuncName} () {
FuncName=$FuncName
PkgName=$PkgName
SrcName=$SrcName" >> $Output
                   ;;
                esac
                cat >> $Output << "EOF"
starttime=$( date +%s )
BuildDir=${buildDir}/${FuncName}
if [ ! -d $BuildDir ]; then mkdir -pv $BuildDir; fi
cd $BuildDir
CUR_DIR=$(echo $PWD) # will write logs to this dir
EOF
                case $FuncName in
                   gccpass1)
                     if [ "$SOURCES" = atinstall ]; then
                       echo "gmpvers=$gmpvers
mpcvers=$mpcvers
mpfrvers=$mpfrvers" >> $Output
                       cat >> $Output << "EOF"
# download the extra files
gmpFile="gmp-${gmpvers}.tar.xz"
mpcFile="mpc-${mpcvers}.tar.gz"
mpfrFile="mpfr-${mpfrvers}.tar.xz"
if [ -e ${CUR_DIR}/${gmpFile} ]; then
  echo "file $gmpFile already in $CUR_DIR, will use that"
else
  wget $wgetopts http://ftp.gnu.org/gnu/gmp/${gmpFile}
fi
if [ -e ${CUR_DIR}/${mpcFile} ]; then
  echo "file $mpcFile already in $CUR_DIR, will use that"
else
  wget $wgetopts https://ftp.gnu.org/gnu/mpc/${mpcFile}
fi
if [ -e ${CUR_DIR}/${mpfrFile} ]; then
  echo "file $mpfrFile already in $CUR_DIR, will use that"
else
  wget $wgetopts http://www.mpfr.org/mpfr-4.1.0/${mpfrFile}
fi
EOF
                     else
                       cat >> $Output << "EOF"
# in chapter5 and chapter6 gcc require unpacking mpfr, mpc and gmp
for i in mpfr gmp mpc
do
  ln -sfv ${LFS}${sourceloc}/${i}*.tar.*z* .
done
EOF
                     fi
                   ;;
                   gccpass2)
                     if [ "$SOURCES" = atinstall ]; then
                       cat >> $Output << "EOF"
# copy the extra files from gccpass1
if [ -e ${CUR_DIR}/gmp*.tar.*z* ]; then
  echo "a gmp file is already in $CUR_DIR, will use that"
else
  cp -v ${LFS}/build/gccpass1/gmp*.tar.*z* .
fi
if [ -e ${CUR_DIR}/mpc*.tar.*z* ]; then
  echo "an mpc file is already in $CUR_DIR, will use that"
else
  cp -v ${LFS}/build/gccpass1/mpc*.tar.*z* .
fi
if [ -e ${CUR_DIR}/mpfr*.tar.*z* ]; then
  echo "an mpfr file is already in $CUR_DIR, will use that"
else
  cp -v ${LFS}/build/gccpass1/mpfr*.tar.*z* .
fi
EOF
                     else
                       cat >> $Output << "EOF"
# in chapter5 and chapter6 gcc require unpacking mpfr, mpc and gmp
for i in mpfr gmp mpc
do
  ln -sfv ${LFS}${sourceloc}/${i}*.tar.*z* .
done
EOF
                     fi
                   ;;
                   glibc)
                     if [ "$SOURCES" = atinstall ]; then
# download the patch
                       echo "glibcPatch=\"glibc-${glibcvers}-fhs-1.patch\"" >> $Output
                       cat >> $Output << "EOF"
if [ -e ${CUR_DIR}/${glibcPatch} ]; then
  echo "patch $glibcPatch already in $CUR_DIR, will use that"
else
  wget $wgetopts http://www.linuxfromscratch.org/patches/lfs/development/${glibcPatch}
fi
EOF
                     fi
                   ;;
                esac
                case $FuncName in
                   wget) # special case for wget because it's not in LFS
                     srcURL="https://ftp.gnu.org/gnu/wget/wget-1.21.1.tar.gz"
                     useThisSrcLoc=""
                     echo "unpack05 \$SrcName \"$srcURL\" \"$useThisSrcLoc\"" >> $Output
                   ;;
                   *)
                     for srcURL in ${sourceURL[@]}; do # find the url for this src file
#echo "srcURL is $srcURL"
#echo "srcname is $SrcName"
                       serchstr="*$SrcName*"
                       useThisSrcLoc=""
                       case $FuncName in # modify some of the src file names to search for
                          binutilspass2)
                            useThisSrcLoc="/build/binutilspass1"
                          ;;
                          gccpass2|libstdc++)
                            useThisSrcLoc="/build/gccpass1"
                          ;;
                          linuxheaders)
                            serchstr="*linux-[0-9]*"
                          ;;
                          make) # make not automake
                            serchstr="*/make-[0-9]*"
                          ;;
                       esac
                       case $srcURL in
                          $serchstr)
                            echo "unpack05 \$SrcName \"$srcURL\" \"$useThisSrcLoc\"" >> $Output
                            break
                          ;;
                       esac
                     done
		   ;;
		esac
                cat >> $Output << "EOF"
# source the environment variables in the home dir
EOF
echo ". \${PkgUserDir}/\${PkgName}/.bashrc" >> $Output
                cat >> $Output << "EOF"
# check some env variable values
#echo "LFS is $LFS"
#echo "LFS_TGT is $LFS_TGT"
if [ -z "$LFS_TGT" ]; then # not set. This will not work so abort
  exit 1
fi
EOF
              fi
            ;;
            chapter07|chapter08|chapter10)
              case $PkgName in
                 chroot|kernfs|stripping|revisedchroot|strippingagain|creatingdirs|createfiles)
                   echo "FuncName=$FuncName" >> $Output
                   cat >> $Output << "EOF"
if [ "$(grep -q ^$FuncName $BuildLog;echo $?)" == 0 ]; then
  echo "skipping $FuncName"
  return 0
else
  echo "In function $FuncName"
fi
EOF
                 ;;
	         *)
                   addPattern="" # extra bit to add to the cd line in unpack
	           case $PkgName in
                      glibc)
                        addPattern="*.tar"
                      ;;
		      kernel)
		        SrcName="linux-"
		      ;;
	              python)
		        PkgName=python3
		        SrcName="Python-"
		      ;;
                      systemd) # need the srcfile, not the man file
                        addPattern="[0-9]"
                      ;;
                      tcl)
                        addPattern="*-src"
                      ;;
                   esac
                   echo "PkgName=$PkgName" >> $Output
		   TestBuiltCh78
                   if ! $as_root; then
                     cat >> $Output << "EOF"
install -v -m0755 -d ${PkgUserDir}/${PkgName}
touch ${PkgUserDir}/${PkgName}/build
echo "BuildLog=$BuildLog" > ${PkgUserDir}/${PkgName}/build
cat >> ${PkgUserDir}/${PkgName}/build << "IPS"
set +h
EOF
                     echo "Chapter=$Chapter
PkgName=\$LOGNAME
CUR_DIR=\$HOME" >> $Output
                     echo "SrcName=$SrcName
sourcedir=$sourcedir
sourceloc=$sourceloc
wgetopts=\"$wgetopts\"
ncc=\"$ncc\"
BuildLog="/$BuildLog"" >> $Output
                     unpack >> $Output
		     getUrlSrcDnld "unpack"
# download any additional files
                     dnldAddFiles
                   else # building as root
                     echo "CreateBuildDirasroot \$PkgName
SrcName=$SrcName" >> $Output
                     if [[ "$SOURCES" = download || "$SOURCES" = local ]]; then
                       case $PkgName in
                          glibc)
                            echo "unpack07 \$SrcName \"\" \"\" \"$addPattern\"" >> $Output
# get the tzdata file
                            cat >> $Output << "EOF"
if [ -e ${sourceloc}/tzdata*.tar.*z* ]; then
  cp -v ${sourceloc}/tzdata*.tar.*z* ..
else
  echo "*** No tzdata file found in $sourceloc ***"
  echo "Place it there in order to continue."
  exit 1
fi
EOF
                          ;;
                          systemd) # distinguish the srcfile from the manpage file
                            echo "unpack07 \$SrcName \"\" \"\" \"$addPattern\" true" >> $Output
                          ;;
                          *)
                            echo "unpack07 \$SrcName \"\" \"\" \"$addPattern\"" >> $Output
                          ;;
                       esac
                     elif [[ "$SOURCES" = atinstall ]]; then # get the srcURL and download any extra files
                       getUrlSrcDnld "unpack07"
                       dnldAddFiles
                     fi
                   fi # end test building as root
                 ;;
              esac
          ;;
        esac
    ;;
    update)
      echo "PkgName=$PkgName" >> $Output
      case $PkgName in
         autoconf|automake|bc|coreutils|diffutils|findutils|flex|gawk|gdbm|gettext|gperf|groff|grub|gzip|libtool|m4|make|shadow|systemd|tar|texinfo) # need pkguserdir to add the .INSTALL file
           echo "pkguserdir=/tools/${pkgFileName}" >> $Output
         ;;
      esac
      TestBuiltUpdate
      if ! $as_root; then
        cat >> $Output << "EOF"
if [ -d ${PkgUserDir}/${PkgName} ]; then # clean it
  cleanpkgdir ${PkgUserDir}/${PkgName} $PkgName
else
  install -v -m0755 -d ${PkgUserDir}/${PkgName}
fi
touch ${PkgUserDir}/${PkgName}/build
echo "BuildLog=$BuildLog" > ${PkgUserDir}/${PkgName}/build
cat >> ${PkgUserDir}/${PkgName}/build << "IPS"
set +h
EOF
        echo "Chapter=$Chapter
PkgName=\$LOGNAME
CUR_DIR=\$HOME" >> $Output
        echo "SrcName=$SrcName
sourcedir=$sourcedir
sourceloc=$sourceloc
wgetopts=\"$wgetopts\"
ncc=\"$ncc\"
BuildLog="/$BuildLog"" >> $Output
        if $useDESTDIR; then # add location of pkguser data if glibc
          if [ "$SrcName" = "glibc-" ]; then echo "pkguserdir=/tools/${pkgFileName}" >> $Output; fi
        fi
        unpack >> $Output
        getUrlSrcDnld "unpack"
        dnldAddFiles
      else # building as root
        cat >> $Output << "EOF"
if [ ! -d ${PkgUserDir}/${PkgName} ]; then # create it
  CreateBuildDirasroot $PkgName
else # clean it
  cleanpkgdir ${PkgUserDir}/${PkgName} $PkgName
fi
EOF
        echo "SrcName=$SrcName" >> $Output
        getUrlSrcDnld "unpack07"
        dnldAddFiles
      fi # end root test
    ;;
esac
# add seds here to alter Makefiles
case $PkgName in
   man-pages)
     echo "sed -i '/install -d -m 755 \\\\\$(DESTDIR)\\\\\$(MANDIR)/d ' Makefile" >> $Output
   ;;
esac
WriteScript
closefunction
} # end of Function
closefunction () {
case "$Chapter" in
    chapter05|chapter06)
       cat >> $Output << "EOF"
touch ${curdir}/../.${Chapter/apter/}${PkgName}
endtime=$( date +%s )
set +e
cd $curdir/..
rm -rf $curdir
elapsedtime=$( expr $endtime - $starttime )
set -e
EOF
       if $as_root; then
         cat >> $Output << "EOF"
echo "$FuncName $unpacktime $elapsedtime" >> ${LFS}${BuildLog}
EOF
echo "} # end $FuncName" >> $Output
       else
         cat >> $Output << "EOF"
echo "$FuncName $unpacktime $elapsedtime" >> ${BuildLog}
EOF
echo "} # end $FuncName" >> $Output
       fi
       if ! $as_root; then
         case $FuncName in
    	    make|tar|wget) # can't use any name that is a linux command  
              makeName="${FuncName}Make"
              echo "$makeName" >> $Output
	    ;;
            *)
              echo "$FuncName" >> $Output
            ;;
         esac	  
         cat >> $Output << "EOF"
IPS
chmod 755 "${LFS}/install${PkgName}.sh"
# run the script specified in .bash_profile
su - $PkgName -c "${LFS}/install${PkgName}.sh"
# set required dirs to be install dirs
EOF
#set required dirs to be install dirs
         case $FuncName in
            bash)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/lib/pkgconfig
chmod 1775 $LFS/usr/lib/pkgconfig
chgrp install $LFS/usr/share/doc
chmod 1775 $LFS/usr/share/doc
EOF
              fi
            ;;
            binutilspass1)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/tools/{bin,lib,share/{,info,man/{,man1}},x86_64-lfs-linux-gnu/{,bin,lib/{,ldscripts}}}
chmod 1775 $LFS/tools/{bin,lib,share/{,info,man/{,man1}},x86_64-lfs-linux-gnu/{,bin,lib/{,ldscripts}}}
EOF
              fi
            ;;
            coreutils)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/share/man/man8
chmod 1775 $LFS/usr/share/man/man8
EOF
              fi
	    ;;
            file)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/share/man/{man3,man4,man5}
chmod 1775 $LFS/usr/share/man/{man3,man4,man5}
EOF
              fi
            ;;
            gccpass1)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/tools/{include,lib,libexec}
chmod 1775 $LFS/tools/{include,lib,libexec}
EOF
              fi
	    ;;
            glibc)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/libexec
chmod 1775 $LFS/usr/libexec
chgrp install $LFS/usr/share/{,i18n,locale}
chmod 1775 $LFS/usr/share/{,i18n,locale}
rm -rf $LFS/usr/share/locale/* # don't need these in chapter 5 or 6
mkdir -pv $LFS/usr/share/info # for m4 in chap 6
chgrp install $LFS/usr/share/info
chmod 1775 $LFS/usr/share/info
# run this as root and set resulting files owned by gcc
LFS_TGT="x86_64-lfs-linux-gnu"
EOF
echo '$LFS/tools/libexec/gcc/$LFS_TGT/"'$gccvers'"/install-tools/mkheaders
chown gcc:gcc /mnt/lfs/tools/lib/gcc/x86_64-lfs-linux-gnu/"'$gccvers'"/include-fixed/{bits/{,statx.h},limits.h,syslimits.h}' >> $Output
              fi
            ;;
            linuxheaders)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/include/{,scsi}
chmod 1775 $LFS/usr/include/{,scsi}
EOF
              fi
            ;;
            m4)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/share/man/{,man1}
chmod 1775 $LFS/usr/share/man/{,man1}
EOF
              fi
	    ;;
            ncurses)
              if ! $useDESTDIR; then
                cat >> $Output << "EOF"
chgrp install $LFS/usr/share/man/{man3,man5,man7}
chmod 1775 $LFS/usr/share/man/{man3,man5,man7}
EOF
              fi
            ;;
         esac
         cat >> $Output << "EOF"
# delete the install script
rm -v "${LFS}/install${PkgName}.sh"
EOF
         case $FuncName in
            wget) # add the /etc/resolv.conf file as root
              cat >> $Output << "EOF"
cat > ${LFS}/etc/resolv.conf << "RESOLVEOF"
nameserver 192.168.1.1
search mynet
RESOLVEOF
EOF
            ;;
         esac
         echo "} # end $FuncName" >> $Output
       fi
    ;;
    chapter07|chapter08)
       case $PkgName in
           chroot|kernfs|stripping|readjusting|revisedchroot|strippingagain|creatingdirs|createfiles)
             if [ "$Chapter" != update ]; then
               cat >> $Output << "EOF"
echo "${FuncName}" >> $BuildLog
}
EOF
             fi
           ;;
           *)
             case $PkgName in
               ncurses) # need the non-wide libs for chromium
                 cat >> $Output << "EOF"
make distclean
non-wideconfigure_commands()
{ :
  ./configure --prefix=/usr    \
              --with-shared    \
              --without-normal \
              --without-debug  \
              --without-cxx-binding \
              --with-abi-version=5
}
non-widemake_commands()
{ :
  make sources libs
}
non-wideinstall_commands()
{ :
  cp -av lib/lib*.so.5* /usr/lib
}
echo -n non-wideConfigure...
{ non-wideconfigure_commands 3>&1 1>&2 2>&3 | tee "$CUR_DIR/non-wideconfigure.err" ;} &>"$CUR_DIR/non-wideconfigure.log"
test_pipe
echo -n non-wideCompile...
{ non-widemake_commands 3>&1 1>&2 2>&3 | tee "$CUR_DIR/non-widemake.err" ;} &>"$CUR_DIR/non-widemake.log"
test_pipe
echo -n non-wideInstall...
{ non-wideinstall_commands 3>&1 1>&2 2>&3 | tee "$CUR_DIR/non-wideinstall.err" ;} &>"$CUR_DIR/non-wideinstall.log"
test_pipe
ln -sv libncurses.so.5.9 /usr/lib/libtinfo.so.5 # this link is for the chromium build
EOF
               ;;
             esac
             if ! $as_root; then
               if $useDESTDIR; then
                 cat >> $Output << "EOF"
touch ~/.${PkgName}-destdir
endtime=$( date +%s )
set +e
EOF
               else
                 cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}"
touch ~/${testBuilt}
endtime=$( date +%s )
set +e
EOF
               fi
             else # as root
                cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}"
touch ${PkgUserDir}/${PkgName}/${testBuilt}
endtime=$( date +%s )
set +e
EOF
             fi # as root test
             delSrcFile >> $Output
             if [ "$PkgName" = glibc ]; then #also delete glibc-build
               echo "rm -rf glibc-build" >> $Output
             elif [ "$PkgName" = binutils ]; then #also delete binutils-build
               echo "rm -rf binutils-build" >> $Output
             elif [ "$PkgName" = gcc ]; then #also delete gcc-build
               echo "rm -rf gcc-build" >> $Output
             fi
             cat >> $Output << "EOF"
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "$PkgName $unpacktime $elapsedtime" >> $BuildLog
EOF
             if ! $as_root; then
               echo "IPS" >> $Output
               setuplinks # setup any preprocessing commands
               if [[ ! -z "$doFirst" || ! -z "$links" ]]; then resolvelinks; fi # not null
               cat >> $Output << "EOF"
if [ "$(grep -q ^$PkgName\: /etc/passwd;echo $?)" != 0 ]; then
  installpkg $PkgName
fi
EOF
               if [[ ! -z "$doFirst" || ! -z "$links" ]]; then # preprocessing
cat >> $Output << "EOF"
resolvelinks
EOF
               fi
	       cat >> $Output << "EOF"
chmod 755 ${PkgUserDir}/${PkgName}/build
# make sure .bash_profile and .bashrc are symlinks to /etc/pkgusr
setUserEnv $PkgUserDir $PkgName
su $PkgName -c "source ${PkgUserDir}/${PkgName}/.bash_profile"
EOF
               if $useDESTDIR; then
                   cat >> $Output << "EOF"
if [ ! -e ${PkgUserDir}/${PkgName}/.${PkgName}-destdir ]; then
  echo "$PkgName using DESTDIR failed"
  exit 1
fi
EOF
               else
                 cat >> $Output << "EOF"
if [ ! -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
  echo "$PkgName failed"
  exit 1
fi
EOF
               fi
               echo "chown \$PkgName:\$PkgName \${PkgUserDir}/\${PkgName}/$build" >> $Output
               case $PkgName in
                  linux-headers|man-pages) # do not ldconfig - not installed until glibc
                    :
                  ;;
                  *)
                    if ! $useDESTDIR; then
                      cat >> $Output << "EOF"
if [ -e "/etc/ld.so.cache~" ]; then # make sure owner is root
  chown 0 /etc/ld.so.cache~
fi
ldconfig
EOF
                    fi
                  ;;
               esac
#set required dirs to be install dirs
               setInstallDirs
               if $useDESTDIR; then
                 case $PkgName in
                    linux-headers)
                        if [ -z "$linuxvers" ]; then # get the linux version no.
                          GetLinuxVersion $SourceDir
                        fi 
                        echo "createPkgfile $linuxvers" >> $Output
                    ;;
                    *)
                        echo "createPkgfile" >> $Output
                    ;;
                 esac
               fi
               echo "} # end $FuncName" >> $Output
             else # as root
               case $PkgName in
                  meson)
                    cat >> $Output << "EOF"
cat > /usr/bin/arch-meson << "MESONEOF"
#!/bin/bash -ex
# Arch Linux Meson wrapper

exec meson setup \
  --prefix         /usr \
  --libdir         /usr/lib \
  --libexecdir     /usr/lib \
  --bindir         /usr/bin \
  --sbindir        /usr/bin \
  --includedir     /usr/include \
  --datadir        /usr/share \
  --mandir         /usr/share/man \
  --infodir        /usr/share/info \
  --localedir      /usr/share/locale \
  --sysconfdir     /etc \
  --localstatedir  /var \
  --sharedstatedir /var/lib \
  --buildtype      plain \
  --warnlevel      2 \
  --auto-features  enabled \
  --wrap-mode      nodownload \
  -D               b_lto=true \
  "$@"
MESONEOF
chmod 755 /usr/bin/arch-meson
EOF
                  ;;
               esac
               echo "} # end $FuncName" >> $Output
             fi # end of as_root test
         ;; #name loop
       esac
    ;; # close chapter07/08 loop
    chapter10)
      if ! $as_root; then
         if $useDESTDIR; then
echo "touch ~/.\${PkgName}-destdir" >> $Output
         else
           cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}"
touch ~/${testBuilt}
EOF
         fi
         cat >> $Output << "EOF"
endtime=$( date +%s )
set +e
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "$PkgName $unpacktime $elapsedtime" >> $BuildLog
EOF
         echo "IPS" >> $Output
         setuplinks # setup any preprocessing commands
         if [[ ! -z "$doFirst" || ! -z "$links" ]]; then resolvelinks; fi
         cat >> $Output << "EOF"
if [ "$(grep -q ^$PkgName\: /etc/passwd;echo $?)" != 0 ]; then
  installpkg $PkgName
fi
EOF
         if [[ ! -z "$doFirst" || ! -z "$links" ]]; then # preprocessing
cat >> $Output << "EOF"
resolvelinks
EOF
         fi
         echo "if ! \$AS_ROOT; then chown \$PkgName:\$PkgName \${PkgUserDir}/\${PkgName}/build; fi
chmod 755 \${PkgUserDir}/\${PkgName}/build
# make sure .bash_profile and .bashrc are symlinks to /etc/pkgusr
setUserEnv \$PkgUserDir \$PkgName
su \$PkgName -c \"source \${PkgUserDir}/\${PkgName}/.bash_profile\"" >> $Output
#         echo "su \$PkgName" >> $Output
         if $useDESTDIR; then
           cat >> $Output << "EOF"
if [ ! -e ${PkgUserDir}/${PkgName}/.${PkgName}-destdir ]; then
  echo "${PkgName}-destdir failed"
  exit 1
fi
EOF
         else
           cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}"
if [ ! -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
  echo "$PkgName failed"
  exit 1
fi
ldconfig
EOF
         fi
         if [ "$SYSTEMD" = yes ]; then
           cat >> $Output << "EOF"
rm -rf ${PkgUserDir}/{dbus/build,systemd/build,libcap/build,shadow/build} # in prep for blfs
if [ -e ${PkgUserDir}/libcap/.libcap ]; then
  rm ${PkgUserDir}/libcap/.libcap
fi
if [ -e ${PkgUserDir}/shadow/.shadow ]; then
  rm ${PkgUserDir}/shadow/.shadow
fi
EOF
         else
           cat >> $Output << "EOF"
rm ${PkgUserDir}/{eudev/build,libcap/build,shadow/build} # in prep for blfs
if [ -e ${PkgUserDir}/libcap/.libcap ]; then
  rm ${PkgUserDir}/libcap/.libcap
fi
if [ -e ${PkgUserDir}/shadow/.shadow ]; then
  rm ${PkgUserDir}/shadow/.shadow
fi
EOF
         fi
      else # as root
         if $useDESTDIR; then
echo "touch \${PkgUserDir}/\${PkgName}/.\${PkgName}-destdir" >> $Output
         else
echo "touch \${PkgUserDir}/\${PkgName}/.\${PkgName}" >> $Output
         fi
         cat >> $Output << "EOF"
endtime=$( date +%s )
set +e
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "$PkgName $unpacktime $elapsedtime" >> $BuildLog
EOF
         cat >> $Output << "EOF"
rm -rf ${PkgUserDir}/{dbus/build,systemd/build,libcap/build,shadow/build} # in prep for blfs
if [ -e ${PkgUserDir}/libcap/.libcap ]; then
  rm ${PkgUserDir}/libcap/.libcap
fi
if [ -e ${PkgUserDir}/shadow/.shadow ]; then
  rm ${PkgUserDir}/shadow/.shadow
fi
EOF
      fi # end as_root test
#
      if [ "$MAKE_KERNEL" = yes ]; then
      # write out the cp commands
        IFS='
' # set to CRLF
        kerneldir=${PkgUserDir}/kernel/linux*
        rtrnCom=""
        CmdName=kernel
        getComms $Chapter $PkgName
        for line in ${rtrnCom[@]}; do
          case $line in
             *bzImage*) # cp the bzImage
                    lineNoCP=${line#"cp -iv "} # remove the cp -v
                    if $useDESTDIR; then
                      echo "mkdir -pv \${PkgUserDir}/\${PkgName}/boot" >> $Output
                      linout=$(echo "cp -iv ${kerneldir}/${lineNoCP}" | sed -e 's/\/boot\/vmlinuz/${PkgUserDir}\/${PkgName}\/boot\/vmlinuz/')
                    else
                      linout=$(echo "cp -iv ${kerneldir}/${lineNoCP}")
                    fi
                    if [ ! -z "$linuxvers" ]; then
                      echo $linout | sed -e 's/'"$linuxcomvers"'/'"$linuxvers"'/' >> $Output
                    else
                      echo $linout >> $Output
                    fi
              ;;
              "cp -iv"*) # cp the System.map and the .config file
                    lineNoCP=${line#"cp -iv "}
                    if $useDESTDIR; then
                      linout=$(echo "cp -iv ${kerneldir}/${lineNoCP}" | sed -e 's/\/boot/${PkgUserDir}\/${PkgName}\/boot/')
                    else
                      linout=$(echo "cp -iv ${kerneldir}/${lineNoCP}")
                    fi
                    if [ ! -z "$linuxvers" ]; then
                      echo $linout | sed -e 's/'"$linuxcomvers"'/'"$linuxvers"'/' \
                      >> $Output
                    else
                      echo $linout >> $Output
                    fi
              ;;
          esac
        done
	echo "# finally change the name of the vmlinuz file
if [ -e /boot/vmlinuz-$linuxvers-lfs-* ]; then
  mv -v /boot/vmlinuz-$linuxvers-lfs-* /boot/vmlinuz-$linuxvers-lfs
fi " >> $Output
        rtrnCom=""
        CmdName=theend
        getComms "chapter11" $PkgName
        for line in ${rtrnCom[@]}; do
          case $line in
            DISTRIB_CODENAME*|VERSION_CODENAME*)
              echo $line | sed -e 's@<your name here>@LFS@' \
              >> $Output
            ;;
            *)
              echo $line >> $Output
            ;;
          esac
        done
      fi # end MAKE_KERNEL
      cat >> $Output << "EOF"
if ! $AS_ROOT; then chown $PkgName:$PkgName ${PkgUserDir}/${PkgName}/build; fi
if [ -d ${PkgUserDir}/${PkgName}/.subversion ]; then rm -rf ${PkgUserDir}/${PkgName}/.subversion; fi
EOF
      if $useDESTDIR; then echo "createPkgfile $linuxvers" >> $Output; fi
# delete files with UID=11000. used by wget in Ch6
      cat >> $Output << "EOF"
# delete files owned by wget  in Ch. 6
/usr/bin/listdelpkg.sh 11000 11000 delete
rm -rf /usr/src/core/wget
# delete the build dir from Ch. 5 and 6
rm -rf /build
# change owner of /usr/share/locale/en_GB installed by wget
chown -R bash:bash /usr/share/locale/en_GB
EOF
      echo "}" >> $Output
    ;;
    update)
      testBuilt=".\${PkgName}-\${Chapter}"
      if ! $as_root; then
        echo "touch ~/${testBuilt}" >> $Output
      else # as root
         echo "touch \${PkgUserDir}/\${PkgName}/${testBuilt}" >> $Output
      fi
      cat >> $Output << "EOF"
endtime=$( date +%s )
set +e
EOF
      delSrcFile >> $Output
      if [ "$PkgName" = glibc ]; then #also delete glibc-build
        echo "rm -rf glibc-build" >> $Output
      elif [ "$PkgName" = binutils ]; then #also delete binutils-build
        echo "rm -rf binutils-build" >> $Output
      elif [ "$PkgName" = gcc ]; then #also delete gcc-build
        echo "rm -rf gcc-build" >> $Output
      fi
      cat >> $Output << "EOF"
elapsedtime=$( expr $endtime - $starttime )
set -e
echo "$PkgName $unpacktime $elapsedtime" >> $BuildLog
EOF
      if ! $as_root; then
        echo "IPS" >> $Output
        setuplinks # setup any preprocessing commands
        if [[ ! -z "$doFirst" || ! -z "$links" ]]; then
          resolvelinks
          cat >> $Output << "EOF"
resolvelinks
EOF
        fi
        cat >> $Output << "EOF"
chmod 755 ${PkgUserDir}/${PkgName}/build
# make sure .bash_profile and .bashrc are symlinks to /etc/pkgusr
setUserEnv $PkgUserDir $PkgName
su $PkgName -c "source ${PkgUserDir}/${PkgName}/.bash_profile"
EOF
        if $useDESTDIR; then
          cat >> $Output << "EOF"
if [ ! -e ${PkgUserDir}/${PkgName}/.${PkgName}-destdir ]; then
  echo "$PkgName using DESTDIR failed"
  exit 1
fi
EOF
        else
          cat >> $Output << "EOF"
if [ ! -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
  echo "$PkgName failed"
  exit 1
fi
chown $PkgName:$PkgName ${PkgUserDir}/${PkgName}/build
EOF
        fi
      fi
# set install dirs
      setInstallDirs
      echo "} # end $FuncName" >> $Output 
    ;;
esac
} #end closefunction
#
setuplinks () { # setup preprocessing
case $PkgName in
    gcc)
        doFirst=""
	links=""
        if ! $useDESTDIR; then
          links="/usr/lib/libstdc++.{a,la} /usr/lib/libgcc_s.so{,.1} /usr/lib/libstdc++.so{,.6} /usr/lib/gcc"
        fi
    ;;
    glibc)
        doFirst=""
        links=""
        if ! $useDESTDIR; then
          doFirst="if [ -d /lib64 ]; then chgrp install /lib64 && chmod 1775 /lib64; fi"
        fi
        if [ "$WHICH_CHAPTER" = update ]; then # /info/dir is owned by root
          links="/usr/share/info/dir"
        fi
    ;;
    bash)
        doFirst=""
        links=""
        if ! $useDESTDIR; then
          links="/bin/bash /bin/sh"
        fi
    ;;
    coreutils)
        doFirst=""
        links=""
        if ! $useDESTDIR; then
          links="/bin/{cat,chmod,dd,echo,env,false,install,ln,mkdir,printf,pwd,rm,stty,touch} /etc/group"
        fi
    ;;
    flex)
        doFirst=""
        links=""
        if ! $useDESTDIR; then
          doFirst="if [ -L /usr/bin/lex ]; then rm /usr/bin/lex; fi"
          links="/usr/lib/libfl.so.2.0.0"
        fi
    ;;
    inetutils)
        doFirst=""
        links=""
        if ! $useDESTDIR; then
          links="/usr/bin/{dnsdomainname,hostname,ping,ping6,traceroute} /usr/share/man/man1/dnsdomainname.1"
        fi
    ;;
    kernel) # install /lib/firmware dir
        doFirst=""
        links=""
        if [ "$Chapter" != update ]; then
          doFirst="mkdir -pv /usr/lib/firmware && chgrp install /usr/lib/firmware && chmod 1775 /usr/lib/firmware"
        fi
    ;;
    man-pages) # in update mode, need to own some man pages
        doFirst=""
        links=""
        if [ "$WHICH_CHAPTER" = update ]; then
          if ! $useDESTDIR; then
            doFirst="chown man-pages:man-pages /usr/share/man/man{1..8}" 
            links="/usr/share/man/{man3/getspnam.3,man5/{attr.5,passwd.5}} "
          fi
        fi
    ;;
    ncurses)
        doFirst=""
        links=""
        if ! $useDESTDIR; then
          links="/etc/ld.so.cache /usr/lib/libncurses.so"
        fi
    ;;
    perl)
        doFirst=""
        links="/usr/bin/perl"
    ;;
    shadow)
        doFirst=""
        links=""
        if ! $useDESTDIR; then
          links="/usr/share/man/man{5/passwd.5,3/getspnam.3} /etc/{passwd,shadow,group,gshadow}{,-} /usr/bin/{chage,chfn,chsh,expiry,gpasswd,groupadd,newgidmap,newgrp,newuidmap,passwd,su,useradd}"
        fi
    ;;
    sysklogd)
        doFirst=""
        links="/usr/share/man/man8/sysklogd.8"
    ;;
    systemd)
        doFirst="if [ \"\$(grep -q ^systemd-journal\: /etc/group;echo \$?)\" != 0 ]; then
  groupadd -g 23 systemd-journal
fi"
        links="/usr"
    ;;
    eudev)
        doFirst=""
        links="/lib/{firmware,udev,udev/devices,udev/devices/pts}"
    ;;
    util-linux)
        doFirst=""
        links=""
        if [ "$WHICH_CHAPTER" = update ]; then
          if ! $useDESTDIR; then
            links="/usr/bin/{mount,su,umount,wall} /usr/share/man/man1/su.1"
          fi
        else
          doFirst="rm -rf /usr/{lib/{libmount.a,libuuid.a,libblkid.a,pkgconfig/{blkid,fdisk,mount,uuid}.pc},include/{blkid,libfdisk,libmount,uuid}}"
          links="/usr/lib/lib{blkid,fdisk,mount,uuid}.so* /usr/bin/{mount,nologin,umount,wall} /usr/share/man/man8/nologin.8"
        fi
    ;;
    vim)
        doFirst=""
        links="/usr/share/vim/vim80/syntax/ninja.vim"
    ;;
    xz)
        doFirst="rm -rf /usr/lib/liblzma.a"
        links="/usr/lib/liblzma.*"
    ;;
    zlib)
        links=""
        doFirst="chgrp install /usr/lib/pkgconfig && chmod 1775 /usr/lib/pkgconfig"
    ;;
    *)
        doFirst=""
        links=""
    ;;
esac
} # end setuplinks
#
resolvelinks () {
# At the beginning of chapter 6 there are symlinks that point to the tools dir
# These are owned by root so need to change owner to the package user
echo "resolvelinks () {" >> $Output
if [ ! -z "$doFirst" ]; then echo "$doFirst" >> $Output; fi
echo "for link in $links; do
  if [ -e "\$link" -o -L "\$link" ]; then
    chown -h \$PkgName:\$PkgName \$link # change owner to package user so can overwrite
  fi
done
return
}" >> $Output
} #end resolvelinks
#
CreateBuildDir () {
# only used in chapter 5 and 6
cat >> $Output << "EOF"
CreateBuildDir () {
BuildDir=${buildDir}/${1}
if [ ! -e $BuildDir ]; then install -d $BuildDir; fi
cd $BuildDir
CUR_DIR=$(echo $PWD)
}
EOF
} #end CreateBuildDir
#
CreateBuildDirasroot () {
cat >> $Output << "EOF"
CreateBuildDirasroot () {
# $1 is the package name, PkgName
BuildDirasroot=${PkgUserDir}/${1}
if [ ! -e $BuildDirasroot ]; then install -d -m755 $BuildDirasroot; fi
cd $BuildDirasroot
CUR_DIR=$(echo $PWD)
} # end CreateBuildDirasroot
EOF
} # end CreateBuildDirasroot
#
unpack05 () {
cat >> $Output << "EOF"
unpack05 () {
# $1 is the source name
# $2, if present, is the url to download the source file
# $3, if present, is the sourceloc of the file already downloaded
sourcelocOld=$sourceloc # sourceloc is global - store it to reset it at the end
local srcname=$1
local srcURL=${2:-""}
local altSourceloc=${3:-""}
if [ ! -z "$altSourceloc" ]; then # set sourceloc to this location
  sourceloc=$altSourceloc
fi
echo "sourceloc is $sourceloc"
starttime=$( date +%s )
if [ -e ${CUR_DIR}/${srcname}*.tar.*z* ]; then # src exists in current dir - use that
  echo "$srcname already in current dir - will use that one"
elif [ -e ${LFS}${sourceloc}/${srcname}*.tar.*z* ]; then # src exists so copy it to current dir
  cp -v ${LFS}${sourceloc}/${srcname}*.* . # copy any patches as well
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on the host
    if [ ! -z "$srcURL" ]; then
      wget $wgetopts $srcURL
    else
      echo "No srcURL given. You need to download the source file"
      echo "Aborting"
      exit 1
    fi
  else
    echo "Install wget on the host to continue"
    echo "Aborting"
    exit 1
  fi
fi
cd $(tar vxf ${srcname}*z* | awk -F\/ 'END{print $1}')
curdir=$(echo $PWD)
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
sourceloc=$sourcelocOld
}
EOF
} #end unpack05
#
unpack07 () {
# used when installing as root for chapter07, 8 and 10
cat >> $Output << "EOF"
unpack07 () {
# $1 is the source name
# $2, if present, is the url to download the source file
# $3, if present, is the sourceloc of the file already downloaded
# $4, if present, is the pattern to add to the cd line to untar the correct file
# $5, if true, add this pattern to the tests
sourcelocOld=$sourceloc # sourceloc is global - store it to reset it at the end
local srcname=$1
local srcURL=${2:-""}
local altSourceloc=${3:-""}
local pattern=${4:-""}
local tstPat="${5:-false}"
if [ ! -z "$altSourceloc" ]; then # set sourceloc to this location
  sourceloc=$altSourceloc
fi
echo "sourceloc is $sourceloc"
addPat=""
if $tstPat; then addPat=$pattern; fi
starttime=$( date +%s )
if [ -e ${CUR_DIR}/${srcname}${addPat}*.tar.*z* ]; then # src exists in current dir - use that
  echo "$srcname already in current dir - will use that one"
elif [ -e ${sourceloc}/${srcname}${addPat}*.tar.*z* ]; then # src exists so copy it to current dir
  cp -v ${sourceloc}/${srcname}*.* . # copy any patches as well
else # download it
  if [ -e /usr/bin/wget ]; then # wget exists on the target machine
    if [ ! -z "$srcURL" ]; then
      wget $wgetopts $ncc $srcURL
    else
      echo "No srcURL given. You need to download the source file"
      echo "Aborting"
      exit 1
    fi
  else
    echo "/usr/bin/wget not present on the target machine"
    echo "Install it in order to continue"
    echo "Aborting"
    exit 1
  fi
fi
cd $(tar vxf ${srcname}${pattern}*z* | awk -F\/ 'END{print $1}')
curdir=$(echo $PWD)
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
sourceloc=$sourcelocOld
} # end unpack07
#
EOF
}
# the unpack used in update
unpack () {
     cat << "EOF"
unpack () {
# $1 is the source name
# $2 is the url to download the source file
# $3, if present, is the sourceloc of the file already downloaded
sourcelocOld=$sourceloc # sourceloc is global - store it to reset it at the end
local srcname=$1
local srcURL=$2
local altSourceloc=${3:-""}
if [ ! -z "$altSourceloc" ]; then # set sourceloc to this location
  sourceloc=$altSourceloc
fi
echo "sourceloc is $sourceloc"
local srcFile=${srcURL##*/}
echo "srcFile to install is $srcFile"
# is this file already in $CUR_DIR
starttime=$( date +%s )
if [ -f ${CUR_DIR}/${srcFile} ]; then # do nothing
  echo "srcFile $srcFile in current dir - will use that one"
else
EOF
     case $SrcName in
        systemd-) # distinguish from the man-pages file
          cat << "EOF"
  if [ -e ${CUR_DIR}/${srcname}[0-9]*.tar.*z* ]; then # a srcfile exists in current dir - use that
    echo "$srcname already in current dir - will use that one"
  elif [ -e ${sourceloc}/${srcname}[0-9]*.tar.*z* ]; then # src exists so copy it to current dir
EOF
        ;;
        tcl8.) # need to specify -src to distinguish from the html file
	  cat << "EOF"
  if [ -e ${CUR_DIR}/${srcname}*-src.tar.*z* ]; then # a srcfile exists in current dir - use that
    echo "$srcname already in current dir - will use that one"
  elif [ -e ${sourceloc}/${srcname}*-src.tar.*z* ]; then # src exists so copy it to current dir
EOF
        ;;
        *)
          cat << "EOF"
  if [ -e ${CUR_DIR}/${srcname}*.tar.*z* ]; then # a srcfile exists in current dir - use that
    echo "$srcname already in current dir - will use that one"
  elif [ -e ${sourceloc}/${srcname}*.tar.*z* ]; then # src exists so copy it to current dir
EOF
        ;;
     esac
     if [[ "$Chapter" = update && "$PkgName" = "linux-headers" ]]; then # the linux src dir is open
       echo "    cp -v \${sourceloc}/\${srcname}*.tar.*z* ." >> $Output
     else
       echo "    cp -v \${sourceloc}/\${srcname}*.* . # copy any patches as well" >> $Output
     fi
     cat << "EOF"
  else # download it
    if [ -e /usr/bin/wget ]; then # wget exists on the target machine
      wget $wgetopts $ncc $srcURL
    else
      echo "Install wget on the target machine in order to continue"
      echo "Aborting"
      exit 1
    fi
  fi
fi
EOF
     case $SrcName in
        systemd-) # distinguish from the man-pages file
          cat << "EOF"
cd $(tar vxf ${srcname}[0-9]*.tar.*z* | awk -F\/ 'END{print $1}')
EOF
        ;;
        tcl8.) # need to specify -src to distinguish from the html file
          cat << "EOF"
cd $(tar vxf ${srcname}*-src.tar.*z* | awk -F\/ 'END{print $1}')
EOF
        ;;
        *)
          cat << "EOF"
cd $(tar vxf ${srcname}*z* | awk -F\/ 'END{print $1}')
EOF
        ;;
     esac
     cat << "EOF"
curdir=$( echo $PWD ) #store the source dir for later deletion
endtime=$( date +%s )
set +e
unpacktime=$( expr $endtime - $starttime )
set -e
starttime=$( date +%s )
sourceloc=$sourcelocOld
} # end unpack
EOF
} # end unpack
#
TestBuiltCh56 () {
    cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}"
if [ -e ${buildDir}/${FuncName}/${testBuilt} ]; then
  echo "skipping $FuncName"
  return 0
  echo "Building $FuncName"
fi
EOF
} #end TestBuiltCh56
#
TestBuiltCh78 () {
    cat >> $Output << "EOF"
testBuilt=".${Chapter/apter/}${PkgName}"
if [ -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
  echo "skipping $PkgName"
  return 0
else
  echo "Building $PkgName"
fi
EOF
} # end TestBuiltCh78
#
TestBuiltUpdate () {
    cat >> $Output << "EOF"
testBuilt=".${PkgName}-update"
if [ -e ${PkgUserDir}/${PkgName}/${testBuilt} ]; then
  echo "Updated $PkgName"
  return 0
else
  echo "Updating $PkgName"
fi
EOF
} # end TestBuiltUpdate
#
WriteScript () {
case $PkgName in
    acl)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/make install install-dev/make DIST_ROOT="$CUR_DIR" install install-dev/' \
                 -e 's/chmod -v 755 \/usr\/lib\/libacl.so/chmod -v 755 ${CUR_DIR}\/usr\/lib\/libacl.so/' \
                 -e '/mv -v/,/ln -sfv/d' \
           >> $Output
        else
          GetCommands \
           | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
                 -e '/prefix=\/usr/a\              --libdir=\/usr\/lib \\' \
                 -e '/mv -v/,/ln -sfv/d' \
           >> $Output
        fi
    ;;
    attr)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/make install install-dev/make DIST_ROOT="$CUR_DIR" install install-dev/' \
                 -e '/chmod -v 755 \/usr\/lib\/libattr.so/i rm -f ${CUR_DIR}\/usr\/lib\/libattr.a' \
                 -e 's/chmod -v 755 \/usr\/lib\/libattr.so/chmod -v 755 ${CUR_DIR}\/usr\/lib\/libattr.so/' \
                 -e '/mv -v/,/ln -sfv/d' \
           >> $Output 
        else
          if [ "$SYSTEMD" = yes -a "$isSystemdBook" = false ]; then
            GetCommands \
             | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
                   -e '/prefix=\/usr/a\              --libdir=\/usr\/lib \\' \
                   -e '/mv -v/,/ln -sfv/d' \
             >> $Output
          else # book is systemd
            GetCommands \
             | sed -e 's/disable-static/disable-static --bindir=\/usr\/bin --libdir=\/usr\/lib/' \
                   -e '/mv -v/,/ln -sfv/d' \
             >> $Output
          fi
        fi
    ;;
    bash)
        if [ "$Chapter" = chapter06 ]; then
	  GetCommands \
	   | sed -e '/mv $LFS\/usr\/bin\/bash/d' \
	         -e 's/bin\/sh/usr\/bin\/sh/' \
	   >> $Output
	else # chapter08
          if [ "$SYSTEMD" = yes ]; then
            if $useDESTDIR; then
              GetCommands \
              | sed -e '/docdir=\/usr\/share\/doc/i\              --bindir=\/usr\/bin            \\' \
                    -e '/chown -Rv/,/EOF/d' \
                    -e '/EOF/d' \
                    -e '/exec \/bin\/bash/i ln -s bash ${CUR_DIR}\/usr\/bin\/sh' \
                    -e '/mv -vf \/usr\/bin\/bash/,/--login/d' \
              >> $Output
            else
              GetCommands \
              | sed -e '/docdir=\/usr\/share\/doc/i\              --bindir=\/usr\/bin            \\' \
                    -e '/chown -Rv/,/EOF/d' \
	            -e '/EOF/d' \
                    -e '/exec \/bin\/bash/i rm -rf \/usr\/bin\/sh\n\ln -s bash \/usr\/bin\/sh' \
                    -e '/mv -vf \/usr\/bin\/bash/,/--login/d' \
              >> $Output
            fi
          else
            GetCommands \
            | sed -e '/chown -Rv/,/EOF/d' \
         	  -e '/EOF/d' \
                  -e '/--login/d' \
            >> $Output
          fi
	fi
    ;;
    bc)
       GetCommands \
        | sed -e '/echo "quit"/d' \
        >> $Output
    ;;
    binutils)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/expect -c/d' \
                 -e 's/make tooldir=\/usr install/make prefix=${CUR_DIR}\/usr  tooldir=${CUR_DIR}\/usr install/' \
           | awk '{
if ($1 == "mkdir" && $2 =="-v")
  print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
  print $0;
}' \
           >> $Output
        else
          GetCommands \
           | sed -e '/expect -c/d' \
           | awk '{
if ($1 == "mkdir" && $2 =="-v")
  print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
  print $0;
}' \
           >> $Output
        fi
    ;;
    bzip2) # ch6 only
        if [ "$Chapter" != update ]; then
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e '/make PREFIX=\/usr/i\  make bzip2 bzip2recover' \
                   -e 's/cp -v bzip2-shared \/bin\/bzip2/cp -v bzip2-shared \/usr\/bin\/bzip2/' \
                   -e 's/cp -av libbz2.so\* \/lib/cp -av libbz2.so\* \/usr\/lib/' \
                   -e '/ln -sv ..\/..\/lib/d' \
                   -e '/rm -v/i ln -sv libbz2.so.1.0 /usr/lib/libbz2.so' \
                   -e 's/bunzip2,bzcat,bzip2/bunzip2,bzcat/' \
                   -e 's/\/bin\/bunzip2/\/usr\/bin\/bunzip2/' \
                   -e 's/\/bin\/bzcat/\/usr\/bin\/bzcat/' \
             >> $Output
          else
            GetCommands \
             | sed -e "/patch/i sed -e 's\/^CFLAGS=\\\(.\*\\\)\$\/CFLAGS=\\\1 \\\\\$(BIGFILES)\/' -i ./Makefile-libbz2_so" \
                   -e '/make PREFIX=\/usr/i\  make bzip2 bzip2recover' \
             >> $Output
          fi
        else # update
          if $useDESTDIR; then
            GetCommands \
             | sed -e "/patch/i sed -e 's\/^CFLAGS=\\\(.\*\\\)\$\/CFLAGS=\\\1 \\\\\$(BIGFILES)\/' -i ./Makefile-libbz2_so" \
                   -e '/make PREFIX=\/usr/i\  make bzip2 bzip2recover' \
                   -e 's/make PREFIX=\/usr install/make PREFIX=${CUR_DIR}\/usr install/' \
                   -e 's/cp -v bzip2-shared \/bin\/bzip2/cp -v bzip2-shared ${CUR_DIR}\/usr\/bin\/bzip2/' \
                   -e 's/cp -av libbz2.so\* \/lib/cp -av libbz2.so\* ${CUR_DIR}\/usr\/lib/' \
                   -e '/ln -sv ..\/..\/lib/d' \
                   -e '/rm -v/i ln -sv libbz2.so.1.0 ${CUR_DIR}/usr/lib/libbz2.so\nln -sv libbz2.so.1.0 ${CUR_DIR}/usr/lib/libbz2.so.1' \
                   -e 's/rm -v \/usr\/bin\/{bunzip2,bzcat,bzip2}/rm -v ${CUR_DIR}\/usr\/bin\/{bunzip2,bzcat}/' \
                   -e 's/\/bin\/bunzip2/${CUR_DIR}\/usr\/bin\/bunzip2/' \
                   -e 's/\/bin\/bzcat/${CUR_DIR}\/usr\/bin\/bzcat/' \
             >> $Output
          else
            GetCommands \
             | sed -e "/patch/i sed -e 's\/^CFLAGS=\\\(.\*\\\)\$\/CFLAGS=\\\1 \\\\\$(BIGFILES)\/' -i ./Makefile-libbz2_so" \
                   -e '/make PREFIX=\/usr/i\  make bzip2 bzip2recover' \
                   -e 's/cp -v bzip2-shared \/bin\/bzip2/cp -v bzip2-shared \/usr\/bin\/bzip2/' \
                   -e 's/cp -av libbz2.so\* \/lib/cp -av libbz2.so\* \/usr\/lib/' \
                   -e '/ln -sv ..\/..\/lib/d' \
                   -e '/rm -v/i ln -sv libbz2.so.1.0 /usr/lib/libbz2.so.1' \
                   -e 's/bunzip2,bzcat,bzip2/bunzip2,bzcat/' \
                   -e 's/\/bin\/bunzip2/\/usr\/bin\/bunzip2/' \
                   -e 's/\/bin\/bzcat/\/usr\/bin\/bzcat/' \
             >> $Output
          fi
        fi
    ;;
    changingowner) # add this if running as root
	if $as_root; then
          GetCommands \
           | sed -e 's/usr,lib,var,etc,bin,sbin,tools/build,"LFS-build.log",etc,var,tools,usr/' \
            >> $Output; fi
    ;;
    check)
        GetCommands \
         | sed -e 's/\(.*\)&&$/\1/' \
         >> $Output
    ;;
    coreutils)
	if [ "$Chapter" = chapter06 ]; then
	  GetCommands \
	   | sed -e '/mv -v $LFS\/usr\/bin\/{cat/,/mv -v $LFS\/usr\/bin\/chroot/d' \
	   >> $Output
	else # chapter08
          if $useDESTDIR; then
            if [ "$SYSTEMD" = yes ]; then
              GetCommands \
               | sed -e 's/uptime/uptime \\\n\              --libexecdir=\/usr\/lib/' \
                     -e "/make NON_ROOT_USERNAME=nobody/,/sed -i '\/dummy\/d' \/etc\/group/d" \
                     -e '/mv -v \/usr\/bin\/{cat/,/mv -v \/usr\/bin\/chroot/d' \
                     -e '/mv -v \/usr\/bin\/{head/d' \
                     -e '/chroot.1/i mkdir -pv ${CUR_DIR}\/usr\/share\/man\/man8' \
                     -e 's/\/usr\/share\/man/${CUR_DIR}\/usr\/share\/man/g' \
               >> $Output
            else
              GetCommands \
               | sed -e "/make NON_ROOT_USERNAME=nobody/,/sed -i '\/dummy\/d' \/etc\/group/d" \
                     -e '/mv -v \/usr\/bin\/chroot \/usr\/sbin/d' \
                     -e 's/\/usr\/bin\//${CUR_DIR}\/usr\/bin\//g' \
                     -e '/chroot.1/i mkdir -pv ${CUR_DIR}\/usr\/share\/man\/man8' \
                     -e 's/\/usr\/share\/man/${CUR_DIR}\/usr\/share\/man/g' \
               >> $Output
            fi
          else # not useDESTDIR
            if [ "$SYSTEMD" = yes ]; then
              GetCommands \
               | sed -e 's/uptime/uptime \\\n\              --libexecdir=\/usr\/lib/' \
                     -e "/make NON_ROOT_USERNAME=nobody/,/sed -i '\/dummy\/d' \/etc\/group/d" \
                     -e '/mv -v \/usr\/bin\/{cat/,/mv -v \/usr\/bin\/chroot/d' \
                     -e '/mv -v \/usr\/bin\/{head/d' \
               >> $Output
            else
              GetCommands \
               | sed -e "/make NON_ROOT_USERNAME=nobody/,/sed -i '\/dummy\/d' \/etc\/group/d" \
                     -e '/mv -v \/usr\/bin\/chroot \/usr\/sbin/d' \
               >> $Output
            fi
          fi
	fi
    ;;
    createfiles)
	if ! $as_root; then
          GetCommands \
           | sed -e '/nobody/ibinutils:x:10000:10000::/mnt/lfs/usr/src/core/binutils:/bin/bash\ngcc:x:10001:10001::/mnt/lfs/usr/src/core/gcc:/bin/bash\nlinux-headers:x:10002:10002::/mnt/lfs/usr/src/core/linux-headers:/bin/bash\nglibc:x:10003:10003::/mnt/lfs/usr/src/core/glibc:/bin/bash\nm4:x:10004:10004::/mnt/lfs/usr/src/core/m4:/bin/bash\nncurses:x:10005:10005::/mnt/lfs/usr/src/core/ncurses:/bin/bash\nbash:x:10006:10006::/mnt/lfs/usr/src/core/bash:/bin/bash\ncoreutils:x:10007:10007::/mnt/lfs/usr/src/core/coreutils:/bin/bash\ndiffutils:x:10008:10008::/mnt/lfs/usr/src/core/diffutils:/bin/bash\nfile:x:10009:10009::/mnt/lfs/usr/src/core/file:/bin/bash\nfindutils:x:10010:10010::/mnt/lfs/usr/src/core/findutils:/bin/bash\ngawk:x:10011:10011::/mnt/lfs/usr/src/core/gawk:/bin/bash\ngrep:x:10012:10012::/mnt/lfs/usr/src/core/grep:/bin/bash\ngzip:x:10013:10013::/mnt/lfs/usr/src/core/gzip:/bin/bash\nmake:x:10014:10014::/mnt/lfs/usr/src/core/make:/bin/bash\npatch:x:10015:10015::/mnt/lfs/usr/src/core/patch:/bin/bash\nsed:x:10016:10016::/mnt/lfs/usr/src/core/sed:/bin/bash\ntar:x:10017:10017::/mnt/lfs/usr/src/core/tar:/bin/bash\nxz:x:10018:10018::/mnt/lfs/usr/src/core/xz:/bin/bash' \
                 -e '/nogroup/iinstall:x:9999:binutils,gcc,linux-headers,glibc,m4,ncurses,bash,coreutils,diffutils,file,findutils,gawk,grep,gzip,make,patch,sed,tar,xz\nbinutils:x:10000:\ngcc:x:10001:\nlinux-headers:x:10002:\nglibc:x:10003:\nm4:x:10004:\nncurses:x:10005:\nbash:x:10006:\ncoreutils:x:10007:\ndiffutils:x:10008:\nfile:x:10009:\nfindutils:x:10010:\ngawk:x:10011:\ngrep:x:10012:\ngzip:x:10013:\nmake:x:10014:\npatch:x:10015:\nsed:x:10016:\ntar:x:10017:\nxz:x:10018:' \
	         -e 's/nobody:x:99:99/nobody:x:65534:65534/' \
	         -e 's/nogroup:x:99/nogroup:x:65534/' \
                 -e '/tester/d' \
                 -e '/exec \/bin\/bash --login +h/d' \
	         -e "/600  \/var\/log\/btmp/ased -i 's/\\\/mnt\\\/lfs//' /etc/passwd" \
             >> $Output
	else # as root
	  GetCommands \
           | sed -e '/mounts \/etc\/mtab/iif [ ! -L \/etc\/mtab ]; then' \
	         -e '/mounts \/etc\/mtab/afi' \
	         -e '/exec \/bin\/bash --login +h/d' \
	   >> $Output
	fi
    ;;
    creatingdirs)
        if [ "$SYSTEMD" = yes ]; then # symlink /bin, /lib and /sbin to /usr...
          GetCommands \
           | sed -e 's/\/lib\/firmware/\/usr\/lib\/firmware/' \
                 -e 's/bin,include,lib,sbin,src/bin,include,lib,src/' \
                 -e 's/cache,local,log/cache,local\/{,la-files},log/' \
           >> $Output
        else
          GetCommands \
           | sed -e 's/cache,local,log/cache,local\/{,la-files},log/' \
           >> $Output
        fi
    ;;
    dbus)
        if $useDESTDIR; then
          GetInternalCommands dbusComms \
           | sed -e 's/\/var\/lib\/dbus/${CUR_DIR}\/var\/lib\/dbus/' \
           >> $Output
        else
          GetInternalCommands dbusComms >> $Output
        fi
    ;;
    e2fsprogs)
        if $useDESTDIR; then
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/mkdir -v build/mkdir -v e2fsprogs-build/' \
                   -e 's/cd       build/cd e2fsprogs-build/' \
                   -e 's/bindir=\/bin    /bindir=\/usr\/bin/' \
                   -e '/with-root-prefix/i\               --libdir=\/usr\/lib       \\\n\               --sbindir=\/usr\/bin      \\' \
                   -e 's/chmod -v u+w \/usr/chmod -v u+w ${CUR_DIR}\/usr/' \
                   -e 's/\/usr\/share\/info/${CUR_DIR}\/usr\/share\/info/g' \
                   -e '/makeinfo -o      doc/,/install-info --dir-file=\/usr/d' \
             >> $Output
          else
            GetCommands \
             | sed -e 's/mkdir -v build/mkdir -v e2fsprogs-build/' \
                   -e 's/cd       build/cd e2fsprogs-build/' \
                   -e 's/chmod -v u+w \/usr/chmod -v u+w ${CUR_DIR}\/usr/' \
                   -e 's/\/usr\/share\/info/${CUR_DIR}\/usr\/share\/info/' \
                   -e '/makeinfo -o      doc/,/install-info --dir-file=\/usr/d' \
             >> $Output
           fi
        else
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/mkdir -v build/mkdir -v e2fsprogs-build/' \
                   -e 's/cd       build/cd e2fsprogs-build/' \
                   -e 's/bindir=\/bin    /bindir=\/usr\/bin/' \
                   -e '/with-root-prefix/i\               --libdir=\/usr\/lib       \\\n\               --sbindir=\/usr\/bin      \\' \
             >> $Output
          else
            GetCommands \
             | sed -e 's/mkdir -v build/mkdir -v e2fsprogs-build/' \
                   -e 's/cd       build/cd e2fsprogs-build/' \
             >> $Output
           fi
        fi
    ;;
    eudev)
        GetCommands \
         | sed -e '/make LD_LIBRARY_PATH=\/tools\/lib check/d' \
         >> $Output
    ;;
    findutils)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/locate/locate --libexecdir=\/usr\/lib\/findutils/' \
                 -e '/mv -v/,/sed -i/d' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    flex)
        if [ "$currentChapter" = update ]; then # don't re-create /usr/bin/lex
          if $useDESTDIR; then
            GetCommands \
             | sed -e 's/ln -sv flex \/usr/ln -sv flex ${CUR_DIR}\/usr/' \
             >> $Output
          else
            GetCommands \
             | sed -e '/ln -s flex/d' \
             >> $Output
          fi
        else
          GetCommands >> $Output
        fi
    ;;
    gawk)
	if [ "$Chapter" = chapter08 ]; then
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/prefix=\/usr/prefix=\/usr \\\n\              --libexecdir=\/usr\/lib \\\n\              --sysconfdir=\/etc \\\n\              --localstatedir=\/var/' \
             >> $Output
          else
            GetCommands >> $Output
          fi
	else
	  GetCommands >> $Output
	fi
    ;;
    gcc)
	if [ "FuncName" = libstdc++ ]; then
          GetCommands \
           | awk '{
if ($1 == "mkdir" && $2 =="-v")
  print "if [ ! -e "$NF" ]; then\n  "$0"\nfi\n";
else
  print $0;
}' \
           >> $Output
	else # gcc not libstdc++
        if [ "$Chapter" != update ]; then
        if [ "$SYSTEMD" = yes ]; then
          if $useDESTDIR; then
            GetCommands \
             | sed -e 's/with-system-zlib/with-system-zlib       \\\n\              --libdir=\/usr\/lib \\\n\              --libexecdir=\/usr\/lib/' \
                   -e '/make install/a\  mv ${CUR_DIR}\/usr\/lib64\/\* ${CUR_DIR}\/usr\/lib\n\  rm -rf ${CUR_DIR}\/usr\/lib64' \
                   -e 's/ln -sv ..\/usr\/bin\/cpp \/lib/ln -sv ..\/bin\/cpp ${CUR_DIR}\/usr\/lib/' \
                   -e "/ln -sv gcc/ a set +e" \
                   -e 's/ln -sv gcc \/usr\/bin\/cc/ln -sv gcc ${CUR_DIR}\/usr\/bin\/cc/' \
                   -e 's/install -v -dm755 \/usr\/lib\/bfd-plugins/install -v -dm755 ${CUR_DIR}\/usr\/lib\/bfd-plugins/' \
                   -e "/echo 'main(){}' > dummy.c/,/rm -v dummy.c a.out dummy.log/d" \
                   -e 's/..\/..\/libexec/../' \
                   -e 's/so \/usr\/lib\/bfd-plugins/so ${CUR_DIR}\/usr\/lib\/bfd-plugins/' \
                   -e 's/\/usr\/share\/gdb\/auto-load/${CUR_DIR}\/usr\/share\/gdb\/auto-load/' \
                   -e 's/\/usr\/lib\/\*gdb.py/${CUR_DIR}\/usr\/lib\/libstdc++.so.6.0.21-gdb.py/' \
             | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0;
}' \
             >> $Output
          else
            if [ "$currentChapter" = update ]; then
              GetCommands \
               | sed -e 's/with-system-zlib/with-system-zlib       \\\n\       --libdir=\/usr\/lib --libexecdir=\/usr\/lib/' \
                     -e '/ln -sv ..\/usr\/bin\/cpp/,/ln -sfv ..\/..\/libexec/d' \
                     -e 's/\/usr\/lib\/\*gdb.py/\/usr\/lib\/libstdc++.so.6.0.21-gdb.py/' \
               | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0;
}' \
               >> $Output
            elif [ "$Chapter" = chapter05 ]; then 
              GetCommands \
               | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0;
}' \
               >> $Output
            else # chapter 6 and 8
              GetCommands \
               | sed -e 's/--prefix=\/usr/--prefix=\/usr \\\n\      --libdir=\/usr\/lib \\\n\      --libexecdir=\/usr\/lib/' \
                     -e '/chown -v -R root:root/,/\/usr\/lib\/gcc\/\*linux-gnu/d' \
                     -e 's/ln -sv ..\/usr\/bin\/cpp \/lib/ln -sv ..\/bin\/cpp \/usr\/lib\/cpp/' \
                     -e 's/\.\.\/libexec\///' \
                     -e '/ln -sv gcc/a set +e' \
		     -e 's/cc dummy.c/\/usr\/bin\/cc dummy.c/' \
               | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0;
}' \
               >> $Output
            fi
          fi
        else # SYSTEMD is no
          GetCommands \
           | sed -e "/ln -sv gcc/ a set +e" \
           | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0;
}' \
           >> $Output
        fi
        else # Chapter is update
          GetInternalCommands gccComms >> $Output
        fi
	fi # end test of gcc or libstdc
        echo "set -e" >> $Output
    ;;
    glibc)
        if [ "$Chapter" != update ]; then
          if [ "$Chapter" = chapter08 ]; then
# set up glibc's timezone
# test if the build dir exists
# if SYSTEMD=yes, but the book is not systemd, then need to add the nscd systemd files
            if [ "$SYSTEMD" = yes -a "$isSystemdBook" = false ]; then
              GetCommands \
               | sed -e 's/prefix=\/usr/prefix=\/usr --libexecdir=\/usr\/lib/' \
                     -e '/mkdir -pv \/usr\/lib\/locale/i install -v -Dm644 ..\/nscd\/nscd.tmpfiles \/usr\/lib\/tmpfiles.d\/nscd.conf\ninstall -v -Dm644 ..\/nscd\/nscd.service \/usr\/lib\/systemd\/system\/nscd.service' \
                     -e '/tzselect/d' \
                     -e 's/zic/\/usr\/sbin\/zic/' \
                     -e 's[\*\*EDITME<xxx>EDITME\*\*['$TZ'[' \
               | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0
}' \
               | awk '{if ($1 == "mkdir" && $NF =="/etc/ld.so.conf.d")
print "if [ ! -e "$NF" ]; then\n  "$1" -v "$NF"\nfi";
else
print $0
}' \
               >> $Output
            else
              GetCommands \
               | sed -e 's/prefix=\/usr/prefix=\/usr --libexecdir=\/usr\/lib/' \
	             -e 's/libc_cv_slibdir=\/lib/libc_cv_slibdir=\/usr\/lib/' \
		     -e 's/ld-linux.so.2        \/lib/ld-linux.so.2        \/usr\/lib/' \
		     -e 's/ld-linux-x86-64.so.2 \/lib/ld-linux-x86-64.so.2 \/usr\/lib/' \
		     -e 's/service \/lib\/systemd\/system/service \/usr\/lib\/systemd\/system/' \
                     -e '/tzselect/d' \
                     -e 's/zic/\/usr\/sbin\/zic/' \
                     -e 's[\*\*EDITME<xxx>EDITME\*\*['$TZ'[' \
               | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0
}' \
               | awk '{if ($1 == "mkdir" && $NF =="/etc/ld.so.conf.d")
print "if [ ! -e "$NF" ]; then\n  "$1" -v "$NF"\nfi";
else
print $0
}' \
               >> $Output
            fi
          else # chapter05
	    if ! $as_root; then
              GetCommands \
	       | sed -e '/install-tools\/mkheaders/d' \
               | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0
}' \
               >> $Output
            else
              GetCommands \
               | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0
}' \
               >> $Output
            fi
          fi
        else # update so modify some of the commands
          if $useDESTDIR; then
            GetCommands \
             | sed -e '/configure_commands()/i echo "slibdir=\/usr\/lib" >> configparms\necho "rtlddir=\/usr\/lib" >> configparms\necho "sbindir=\/usr\/bin" >> configparms\necho "rootsbindir=\/usr\/bin" >> configparms' \
                   -e '/--disable-werror/i\               --libdir=\/usr\/lib --libexecdir=\/usr\/lib                \\' \
                   -e '/touch \/etc\/ld.so.conf/i\  install -dm755 ${CUR_DIR}/etc' \
                   -e 's/touch \/etc\/ld.so.conf/touch ${CUR_DIR}\/etc\/ld.so.conf/' \
                   -e 's/\/etc\/nscd.conf/${CUR_DIR}\/etc\/nscd.conf/' \
                   -e 's/\/var\/cache\/nscd/${CUR_DIR}\/var\/cache\/nscd/' \
                   -e'/\/usr\/lib\/tmpfiles.d/i install -dm755 ${CUR_DIR}\/usr\/lib\/{locale,systemd\/system,tmpfiles.d}' \
                   -e 's/\/usr\/lib\/tmpfiles.d\/nscd.conf/${CUR_DIR}\/usr\/lib\/tmpfiles.d\/nscd.conf/' \
                   -e 's/\/lib\/systemd\/system\/nscd.service/${CUR_DIR}\/usr\/lib\/systemd\/system\/nscd.service/' \
                   -e '/mkdir -pv \/usr\/lib\/locale/,/make localedata\/install-locales/d' \
                   -e "/cat > \/etc\/nsswitch.conf/i install -m755 \${pkguserdir}\/locale-gen \${CUR_DIR}\/usr\/bin\n# create \/etc\/locale.gen\ninstall -m644 \${pkguserdir}\/locale.gen.txt \${CUR_DIR}\/etc\/locale.gen\nsed -e '1,3d' -e 's|/| |g' -e 's|\\\\\\\\| |g' -e 's|^|#|g' \\\\\n\       ..\/glibc-'"$glibcvers"'\/localedata\/SUPPORTED >> \${CUR_DIR}\/etc\/locale.gen\nrm \${CUR_DIR}\/usr\/lib\/lib{anl,BrokenLocale,nsl,resolv,rt,util}.a" \
                   -e 's/cat > \/etc\/nsswitch.conf/cat > ${CUR_DIR}\/etc\/nsswitch.conf/' \
                   -e 's/$ZONEINFO/${CUR_DIR}$ZONEINFO/' \
                   -e 's[\*\*EDITME<xxx>EDITME\*\*['$TZ'[' \
                   -e 's/\/etc\/localtime/${CUR_DIR}\/etc\/localtime/' \
                   -e 's/cat > \/etc\/ld.so.conf/cat > ${CUR_DIR}\/etc\/ld.so.conf/' \
                   -e 's/cat >> \/etc\/ld.so.conf/cat >> ${CUR_DIR}\/etc\/ld.so.conf/' \
                   -e 's/mkdir -pv \/etc\/ld.so.conf.d/mkdir -pv ${CUR_DIR}\/etc\/ld.so.conf.d/' \
                   -e '/tzselect/d' \
             | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0
}' \
             >> $Output
          else # not DESTDIR
            GetCommands \
             | sed -e '/--disable-werror/i\               --libexecdir=\/usr\/lib                   \\' \
	           -e '/touch \/etc\/ld.so.conf/d' \
                   -e '/install -v -Dm644 ..\/nscd\/nscd.service/,/End \/etc\/nsswitch.conf/d' \
                   -e '/EOF/d' \
                   -e '/tzselect/,/mkdir -pv \/etc\/ld.so.conf.d/d' \
             | awk '{if ($1 == "mkdir" && $2 =="-v")
print "if [ ! -e "$NF" ]; then\n  "$0"\nfi";
else
print $0
}' \
             >> $Output
           fi 
        fi
    ;;
    gmp)
        # if building for 64bit need to remove config for 32
        # remove cp commands for less capable CPU than the host
        GetCommands \
         | sed -e '/ABI=32/d' \
               -e '/cp -v configfsf/d' \
         >> $Output
    ;;
    grep)
        if [ "$SYSTEMD" = yes ]; then
           GetCommands \
            | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
            >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    groff)
        if [ "$currentChapter" = update ]; then
          GetCommands \
           | sed -e 's/\*\*EDITME<paper_size>EDITME\*\*/'$PAPER_SIZE'/' \
                 -e 's/prefix=\/usr/prefix=\/usr \\\n              --sysconfdir=\/etc \\\n              --with-appresdir=\/etc\/X11\/app-defaults/' \
                 -e '/End of editable block/d' \
                 -e '/ln -sv/d' \
           >> $Output
        else
          GetCommands \
           | sed -e 's/\*\*EDITME<paper_size>EDITME\*\*/'$PAPER_SIZE'/' \
                 -e '/End of editable block/d' \
           >> $Output
        fi
    ;;
    grub)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/--sbindir=\/sbin/--sbindir=\/usr\/bin/' \
           >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    gzip)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
                 -e '/mv -v/d' \
           >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    inetutils)
        if [ "$SYSTEMD" = yes ]; then
          if [ "$Chapter" != update -o $useDESTDIR ]; then
            GetCommands \
             | sed -e '/disable-logger/i\              --libexecdir=/usr/lib  \\' \
                   -e '/mv -v/d' \
             >> $Output
          else
            GetCommands \
             | sed -e '/disable-logger/i\              --libexecdir=/usr/lib  \\' \
                   -e 's/disable-servers/disable-servers \\\n              --disable-hostname \\\n              --disable-ifconfig/' \
                   -e '/mv -v/d' \
             >> $Output
          fi
        else
          GetCommands  >> $Output
        fi
    ;;
    iproute2)
        if $useDESTDIR; then
          GetCommands \
             | sed -e 's/make DOCDIR=/make DESTDIR="$CUR_DIR" DOCDIR=/' \
             >> $Output
        else
          GetCommands \
	   | sed -e 's/make DOCDIR/make DESTDIR=$curdir\/..\/ DOCDIR/' \
           >> $Output
        fi
    ;;
    kbd)
          GetCommands \
           | sed -e "/make install/i\  sed -i '0,/install -d -m 755 \\\$(DESTDIR)\\\$(datadir)/ s///' data/Makefile" \
           >> $Output
    ;;
    kernel)
        if [ "$MAKE_KERNEL" = yes ]; then
          if [ "$Chapter" != update ]; then
            GetCommands \
             | sed -e '/make mrproper/,/make menuconfig/d' \
                   -e '/mount --bind \/boot/,/cp -iv \.config/d' \
                   -e 's/linux-'"${linuxcomvers}"'/linux-'"${linuxvers}"'/' \
             >> $Output
          else # update, so test destdir
            if $useDESTDIR; then
              GetCommands \
               | sed -e '/make mrproper/,/make menuconfig/d' \
                     -e 's/make modules_install/make INSTALL_MOD_PATH="${CUR_DIR}\/usr" modules_install/' \
                     -e '/mount --bind \/boot/,/cp -iv \.config/d' \
                     -e 's/install -v -m755 -d \/etc/install -v -m755 -d ${CUR_DIR}\/etc/' \
                     -e 's/cat > \/etc/cat > ${CUR_DIR}\/etc/' \
               >> $Output
            else # /etc/modprobe.d/usb.conf already installed
              GetCommands \
               | sed -e '/make mrproper/,/make menuconfig/d' \
                     -e '/mount --bind \/boot/,/End \/etc\/modprobe.d\/usb.conf/d' \
                     -e '/EOF/d' \
                     -e 's/linux-'"${linuxcomvers}"'/linux-'"${linuxvers}"'/' \
               >> $Output
            fi
          fi
	else # MAKE_KERNEL is no so just do make mrproper
	  GetCommands \
           | sed -e '/make menuconfig/d' \
	         -e '/^$/d;/make$/d' \
	         -e 's/make modules_install/echo "No install script for this package"/' \
		 -e '/mount --bind /,/^EOF/d' \
           >> $Output
        fi
    ;;
    kernfs) # change permissions on /dev/shm
        GetCommands \
         | sed -e '/fi/i\  chmod 1777 $LFS\/dev\/shm/' \
         >> $Output
    ;;
    kmod)
        if [ "$SYSTEMD" = yes ]; then
          if [ "$Chapter" != update ]; then
            GetCommands \
             | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
                   -e 's/rootlibdir=\/lib/rootlibdir=\/usr\/lib/' \
                   -e 's/ln -sv ..\/bin\/kmod \/sbin/ln -sv kmod \/usr\/bin/' \
                   -e '/ln -sv kmod \/bin\/lsmod/d' \
             >> $Output
          else # update
            if $useDESTDIR; then
              GetCommands \
               | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
                     -e 's/rootlibdir=\/lib/rootlibdir=\/usr\/lib/' \
                     -e '/for target in depmod/,/ln -sv kmod/d' \
                     -e '/make install/a\  install -dm755 ${CUR_DIR}\/{etc,usr\/lib}\/{depmod,modprobe}.d\n\  for tool in {ins,ls,rm,dep}mod mod{probe,info}; do\n\   ln -s kmod ${CUR_DIR}\/usr\/bin\/${tool}\n\  done' \
               >> $Output
            else
              GetCommands \
               | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
                     -e 's/rootlibdir=\/lib/rootlibdir=\/usr\/lib/' \
                     -e '/for target in depmod/,/ln -sv kmod/d' \
               >> $Output
            fi
          fi
        else
          GetCommands >> $Output
        fi
    ;;
    libcap)
        if $useDESTDIR; then
          GetCommands \
           | sed -e "/sed -i/i sed -i '/SBINDIR/s#sbin#bin#' Make.Rules" \
                 -e 's/usr install/usr lib=\/lib DESTDIR="$CUR_DIR" install/' \
                 -e 's/chmod -v 755 \/usr/chmod -v 755 ${CUR_DIR}\/usr/' \
                 -e '/mv -v/,/ln -sfv/d' \
           >> $Output
        else
          GetCommands \
           | sed -e '/mv -v/,/ln -sfv/d' \
           >> $Output
        fi
    ;;
    linux-headers)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/cp -rv dest\/include/i\  mkdir -pv ${CUR_DIR}\/usr\/include' \
                 -e 's/\/usr\/include/${CUR_DIR}\/usr\/include/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    man-db)
        if $useDESTDIR; then
          GetCommands \
           | sed -e '/disable-setuid/i\              --libexecdir=\/usr\/lib \\\n\              --sbindir=/usr/bin \\' \
                 -e 's/\/usr\/lib\/tmpfiles.d\/man-db.conf/${CUR_DIR}\/usr\/lib\/tmpfiles.d\/man-db.conf/' \
           >> $Output
        else
          if [ "$SYSTEMD" = yes ]; then
            if $as_root; then
              GetCommands \
               | sed -e 's/bin\/grap/bin\/grap --libexecdir=\/usr\/lib/' \
               >> $Output
            else
              GetCommands \
               | sed -e 's/bin\/grap/bin\/grap --libexecdir=\/usr\/lib/' \
                     -e 's/man root:root root/man man:man-db man-db/' \
               >> $Output
            fi
          else
            GetCommands >> $Output
          fi
        fi
    ;;
    man-pages)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/make install/make prefix=${CUR_DIR}\/usr install/' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    ncurses)
        if [ "$Chapter" = chapter06 ]; then
          GetCommands \
           | sed -e '/mv -v $LFS\/usr\/lib\/libncursesw.so/d' \
                 -e '/ln -sfv ..\/..\/lib\/\$(readlink/d' \
           >> $Output
	else # chapter08
          if [ "$SYSTEMD" = yes ]; then
            if $useDESTDIR; then
              GetCommands \
               | sed -e 's/without-normal/with-normal   /' \
                     -e 's/enable-widec/enable-widec          \\\n\              --with-pkg-config=\/usr\/lib\/pkgconfig/' \
                     -e '/mv -v \/usr\/lib\/libncursesw.so/d' \
                     -e '/ln -sfv ..\/..\/lib\/\$(readlink/d' \
                     -e '/for lib in ncurses/i install -m755 -d ${CUR_DIR}\/usr\/lib\/pkgconfig' \
                     -e 's/\/usr\/lib\/lib/${CUR_DIR}\/usr\/lib\/lib/' \
                     -e 's/\/usr\/lib\/pkgconfig\/\${lib}.pc/${CUR_DIR}\/usr\/lib\/pkgconfig\/\${lib}.pc/' \
                     -e '/make distclean/,/cp -av lib\/lib/d' \
               >> $Output
            else
              GetCommands \
               | sed -e '/mv -v \/usr\/lib\/libncursesw.so/d' \
                     -e '/ln -sfv ..\/..\/lib\/\$(readlink/d' \
                     -e '/make distclean/,/cp -av lib\/lib/d' \
               >> $Output
            fi
          else # sysv
             GetCommands \
              | sed -e '/make distclean/,/cp -av lib\/lib/d' \
              >> $Output
          fi
	fi # chapter06 or 08
    ;;
    ninja)
        GetCommands \
         | sed '0,/python3 configure.py/! s/python3 configure.py//' \
         >> $Output
    ;;
    procps-ng)
        if [ "$SYSTEMD" = yes ]; then # add the sysctl.conf file
          if [ "$Chapter" != update ]; then
            GetCommands \
             | sed -e '/libdir=\/usr\/lib/i\              --bindir=\/usr\/bin \\\n\              --sbindir=\/usr\/bin \\\n\              --with-systemd                           \\' \
                   -e '/sed -i/,/make check/d' \
                   -e '/ln -sfv/a touch \/etc\/sysctl.conf' \
                   -e '/mv -v/,/ln -sfv/d' \
             >> $Output
          else # update
            GetCommands \
             | sed -e '/libdir=\/usr\/lib/i\              --bindir=\/usr\/bin \\\n\              --sbindir=\/usr\/bin \\\n\              --with-systemd                           \\' \
                   -e '/sed -i/,/make check/d' \
                   -e '/mv -v/,/ln -sfv/d' \
             >> $Output
          fi
        else
           GetCommands >> $Output
        fi
    ;;
    psmisc)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e '/mv -v/d' \
           >> $Output
        else
           GetCommands >> $Output
        fi
    ;;
    python3) # remove doc commands
        GetCommands \
         | sed -e '/tar --strip-components/,/xvf/d' \
         >> $Output
    ;;
    readline)
        if $useDESTDIR; then
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/--libdir=\/lib/--libdir=\/usr\/lib/' \
                   -e 's/lncurses install/lncurses DESTDIR="$CUR_DIR" install/' \
                   -e '/mv -v/d' \
                   -e '/ln -sfv/d' \
             >> $Output
          else
             GetCommands \
             | sed -e 's/lncurses install/lncurses DESTDIR="$CUR_DIR" install/' \
             >> $Output
          fi
        else
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/--libdir=\/lib/--libdir=\/usr\/lib/' \
                   -e '/mv -v/d' \
                   -e '/ln -sfv/d' \
             >> $Output
          else
             GetCommands >> $Output
          fi
        fi
    ;;
    sed)
        if $useDESTDIR; then
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
                   -e 's/make -C doc install/make -C doc DESTDIR="$CUR_DIR" install/' \
             >> $Output
          else
             GetCommands \
              | sed -e 's/make -C doc install/make -C doc DESTDIR="$CUR_DIR" install/' \
              >> $Output
          fi
        else # not using DESTDIR
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/--bindir=\/bin/--bindir=\/usr\/bin/' \
             >> $Output
          else
             GetCommands >> $Output
          fi
        fi
    ;;
    shadow)
        # assume without cracklib support
        # don't install foreign man pages
        # don't set root passwd
        # setup shadow passwd files
        # delete pwconv and grpconv because cannot lock /etc/passwd
        # do pwconv and grpconv later as root
        if [ "$Chapter" != update ]; then
        if $useDESTDIR; then
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e '/DICTPATH/d' \
                   -e "/configure_commands()/i sed -i -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\\\\//' \\\\\n\       -e 's\/zh_CN zh_TW\/\/' \\\\\n\       -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr\//'  man/Makefile.in" \
                   -e 's/sysconfdir=\/etc/sysconfdir=\/etc \\\n\              --bindir=\/usr\/bin \\\n\              --sbindir=\/usr\/bin \\\n\              --libdir=\/usr\/lib/' \
                   -e '/mv -v/,/grpconv/d' \
                   -e '/passwd root/d' \
                   -e "s/sed -i 's\/yes\/no\/' \/etc\/default\/useradd/sed -i 's\/yes\/no\/' \${CUR_DIR}\/etc\/default\/useradd/" \
             >> $Output
          else
            GetCommands \
             | sed -e '/DICTPATH/d' \
                   -e "/configure_commands()/i sed -i -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\\\\//' \\\\\n\       -e 's\/zh_CN zh_TW\/\/' \\\\\n\       -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr\//'  man/Makefile.in" \
                   -e 's/sysconfdir=\/etc/sysconfdir=\/etc \\\n\              --bindir=\/usr\/bin \\\n\              --sbindir=\/usr\/bin \\\n\              --libdir=\/usr\/lib/' \
                   -e '/pwconv/,/grpconv/d' \
                   -e '/passwd root/d' \
                   -e "s/sed -i 's\/yes\/no\/' \/etc\/default\/useradd/sed -i 's\/yes\/no\/' \${CUR_DIR}\/etc\/default\/useradd/" \
             >> $Output
          fi
        else # not useDESTDIR
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e '/DICTPATH/d' \
                   -e "/configure_commands()/i sed -i -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\\\\//' \\\\\n\       -e 's\/zh_CN zh_TW\/\/' \\\\\n\       -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr\//'  man/Makefile.in" \
                   -e '/mv -v/d' \
                   -e '/passwd root/d' \
                   -e '/pwconv/ i touch /etc/shadow\nchmod 640 /etc/shadow' \
                   -e '/grpconv/ i touch /etc/gshadow\nchmod 640 /etc/gshadow' \
                   -e '/pwconv/d' \
                   -e '/grpconv/d' \
             >> $Output
          else
            GetCommands \
             | sed -e '/DICTPATH/d' \
                   -e "/configure_commands()/i sed -i -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\\\\//' \\\\\n\       -e 's\/zh_CN zh_TW\/\/' \\\\\n\       -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr\//'  man/Makefile.in" \
                   -e '/passwd root/d' \
                   -e '/pwconv/ i touch /etc/shadow\nchmod 640 /etc/shadow' \
                   -e '/grpconv/ i touch /etc/gshadow\nchmod 640 /etc/gshadow' \
                   -e '/pwconv/d' \
                   -e '/grpconv/d' \
             >> $Output
          fi
        fi
        else # update
          GetInternalCommands shadowComms \
           | sed -e "/configure_commands()/i sed -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr \\\\\\\//' \\\\\n\    -e 's\/zh_CN zh_TW\/\/' \\\\\n\    -e 's\/po cs da de es fi fr hu id it ja ko pl pt_BR ru sv tr\//' \\\\\n\    -i  man/Makefile.in" \
           >> $Output
	fi
    ;;
    stripping)
        # strip always exits with 1, so toggle bash's -e flag
        echo "set -e" >> $Output
        GetCommands \
	 | sed -e '/rm -rf \/usr/a set +e' \
	       -e '/exit/i echo "copy'\''n'\''paste the following:"' \
               -e 's/^exit/echo "exit/' \
	       -e 's/^umount/echo "umount/' \
	       -e 's/^strip/echo "strip/' \
	       -e 's/^cd/echo "cd/' \
	       -e 's/^tar/echo "tar/' \
               -e 's/\$/\\$/g' \
               -e 's/$/"/' \
	       -e 's/delete"/delete/' \
	       -e 's#doc}/\*\"#doc}/\*#' \
	 >> $Output
    ;;
    strippingagain)
     if [ "$Chapter" != update ]; then
       echo "set +e" >> $Output
       GetCommands \
	| sed -e '/exec \/tools\/bin\/bash/d' \
	      -e '/strip-all/a rm -rf \/tmp\/\*' \
	>> $Output
       echo "set -e" >> $Output
     fi
    ;;
    revisedchroot)
        if [ "$Chapter" != update ]; then
          GetCommands \
           | sed -e '/rm -rf \/tmp\/\*/d' \
	         -e '/find \/usr -depth/aecho "*** do not delete the \/tools dir, needed for chapter10 ***"' \
		 -e '/rm -rf \/tools/d' \
                 -e '/logout/ i echo "copy'\''n'\''paste the following:\n"' \
                 -e 's/^/echo "/' \
                 -e 's/\$/\\$/g' \
                 -e 's/\\$/\\\\/' \
                 -e 's/$/"/' \
           >> $Output
          cat >> $Output << "EOF"
echo "
#
# Install chapter 9 and then su kernel to install the kernel.
# Don't forget:
# 1. set a root password
# 2. check for broken symlinks with: find /usr/lib -xtype l
EOF
echo "#\"" >> $Output
        fi
    ;;
    sysklogd)
        if ! $as_root; then
        # fix the Make file to use the install wrapper and not the default install bin
          GetCommands \
           | awk '{if ($NF == "install" && $1 == "make") $1 = "  make INSTALL=install"; print $0}' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    systemd)
          if $useDESTDIR; then
            GetCommands \
             | sed -e '/systemd-machine-id-setup/d' \
                   -e 's/make LIBRARY_PATH=\/tools\/lib install/make DESTDIR="$CUR_DIR" LIBRARY_PATH=\/tools\/lib install/' \
                   -e 's/\/usr\/bin\/\$tool/\${CUR_DIR}\/usr\/bin\/\$tool/' \
                   -e 's/\/usr\/sbin\/init/\${CUR_DIR}\/usr\/bin\/init/' \
                   -e 's/\/usr\/lib\/tmpfiles.d/\${CUR_DIR}\/usr\/lib\/tmpfiles.d/' \
                   -e 's/\/usr\/lib\/rpm/\${CUR_DIR}\/usr\/lib\/rpm/' \
             >> $Output
          else
            if ! $as_root; then
              GetCommands \
               | sed -e 's/kill-path=\//kill-path=\/usr\//' \
                     -e 's/kmod-path=\//kmod-path=\/usr\//' \
                     -e 's/mount-path=\//mount-path=\/usr\//' \
                     -e 's/rootlibdir=\//rootlibdir=\/usr\//' \
                     -e 's/sulogin-path=\/sbin/sulogin-path=\/usr\/bin/' \
                     -e 's/ln -sfv ..\/bin\/systemctl \/sbin/ln -sfv systemctl \/usr\/bin/' \
                     -e 's/systemd \/sbin/systemd \/usr\/bin/' \
                     -e '/systemd-machine-id-setup/,/rm -f \/usr\/lib\/tmpfiles.d/d' \
               >> $Output
            else
              GetCommands \
               | sed -e 's/kill-path=\//kill-path=\/usr\//' \
                     -e 's/kmod-path=\//kmod-path=\/usr\//' \
                     -e 's/mount-path=\//mount-path=\/usr\//' \
                     -e 's/rootlibdir=\//rootlibdir=\/usr\//' \
                     -e 's/sulogin-path=\/sbin/sulogin-path=\/usr\/bin/' \
                     -e 's/ln -sfv ..\/bin\/systemctl \/sbin/ln -sfv systemctl \/usr\/bin/' \
                     -e 's/systemd \/sbin/systemd \/usr\/bin/' \
               >> $Output
	    fi
          fi
    ;;
    sysvinit)
        if [ "$SYSTEMD" = yes ]; then
          GetInternalCommands sysvinitComms >> $Output
        else
          GetCommands \
           | sed -e "/patch/a sed -i '/dev\\\/initctl/d' src/Makefile" \
           >> $Output
        fi
    ;;
    tar)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/bindir=\/bin/bindir=\/usr\/bin --libexecdir=\/usr\/lib\/tar/' \
                 -e 's/make -C doc install-html/make -C doc DESTDIR="$CUR_DIR" install-html/' \
           >> $Output
        else
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e 's/bindir=\/bin/bindir=\/usr\/bin --libexecdir=\/usr\/lib\/tar/' \
             >> $Output
          else
            GetCommands >> $Output
          fi
        fi
    ;;
    tcl)
        if [ "$Chapter" = update ]; then # don't mv the man page
          GetCommands \
           | sed -e '/mv \/usr\/share\/man\/man3/d' \
	   >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    texinfo)
        # tries and fails to rebuild /usr/share/info/dir
        GetCommands \
         | sed -e '/make TEXMF=/d' \
               -e '/pushd/,/popd/d' \
         >> $Output
    ;;
    util-linux)
        if $useDESTDIR; then
          GetCommands \
           | sed -e 's/mkdir -pv \/var\/lib\/hwclock/mkdir -pv ${CUR_DIR}\/var\/lib\/hwclock/' \
                 -e '/docdir=\/usr\/share\/doc/i\              --libdir=/usr/lib \\\n\              --bindir=/usr/bin \\\n\              --sbindir=/usr/bin \\' \
                 -e '/disable-login/,/disable-su/d' \
                 -e '/disable-setpriv/i\              --enable-vipw \\' \
                 -e 's/without-python/without-python     \\\n\              --with-systemdsystemunitdir=\/usr\/lib\/systemd\/system/' \
           >> $Output
        else
          if [ "$SYSTEMD" = yes ]; then
            GetCommands \
             | sed -e '/docdir=/d' \
                     -e '/disable-chfn-chsh/i\              --docdir=\/usr\/share\/doc\/util-linux-'"${utillinuxvers}"' \\' \
                     -e '/without-python/i\              --with-systemdsystemunitdir=\/usr\/lib\/systemd\/system \\\n\              --disable-makeinstall-chown \\\n\              --disable-makeinstall-setuid \\' \
             >> $Output
          else
            GetCommands \
             | sed -e '/docdir=/d' \
                   -e '/disable-chfn-chsh/i\              --docdir=\/usr\/share\/doc\/util-linux-'"${utillinuxvers}"'' \
             >> $Output
          fi
        fi
    ;;
    vim)
        if [ "$Chapter" != update ]; then
          GetCommands \
           | sed -e 's/make test/make -j1 test/' \
                 -e '/:options/d' \
           >> $Output
        else
          if $useDESTDIR; then
            GetCommands \
             | sed -e 's/ln -sv vim \/usr/ln -sv vim ${CUR_DIR}\/usr/' \
                   -e 's/for L in  \/usr/for L in  ${CUR_DIR}\/usr/' \
                   -e '/ln -sv ..\/vim\/vim74\/doc/i mkdir -pv ${CUR_DIR}\/usr\/share\/doc' \
                   -e 's/vim74\/doc \/usr/vim74\/doc ${CUR_DIR}\/usr/' \
                   -e '/cat > \/etc\/vimrc/i mkdir -pv ${CUR_DIR}\/etc' \
                   -e 's/cat > \/etc\/vimrc/cat > ${CUR_DIR}\/etc\/vimrc/' \
                   -e '/:options/d' \
             >> $Output
          else
            GetCommands \
             | sed -e '/ln -sv vim \/usr\/bin\/vi/,/:options/d' \
             >> $Output
          fi
        fi
    ;;
    xz)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e 's/prefix=\/usr/prefix=\/usr --libdir=\/usr\/lib/' \
                 -e '/mv -v/,/ln -svf/d' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    zlib)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e '/mv -v/,/ln -sfv/d' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    zstd)
        if [ "$SYSTEMD" = yes ]; then
          GetCommands \
           | sed -e '/make prefix=\/usr install/i\  set +e' \
	         -e 's/usr install/usr DESTDIR=$curdir\/..\/ install\n\  cp -a $curdir\/..\/usr\/* \/usr\n\  set -e/' \
                 -e '/mv -v \/usr\/lib\/libzstd/,/ln -sfv ../d' \
           >> $Output
        else
          GetCommands >> $Output
        fi
    ;;
    *)
        GetCommands >> $Output
        return_val=$?
        if [ $return_val -eq $RETURN_PARAM ]; then # no build file
          echo "No build file available in ${LFS}/tools/pkguser"
          echo "Please place the build file there to continue."
          exit 1
        elif [ $return_val -eq $RETURN_NO_CMNDS ]; then
          echo "*** WARNING ***"
          echo "No commands found for package $PkgName"
	  if $single_package; then
	    echo "Package $SINGLE_PACKAGE not found in $Chapter"
	    echo "You should set Chapter to the one you want and try again"
	    echo "Exiting now"
	    exit 1
	  fi
        fi
    ;;
esac
} # end WriteScript
#
cleanstart () {
# $1 is the script name to delete. Can be all
if [ "$1" = all ]; then
  scriptToDelete="$ch7asroot $ch7chroot $ch5script $ch6script $ch8script LFS-chroot.sh"
elif [[ "$1" = chapter05 || "$1" = chapter06 || "$1" = update ]]; then
  scriptToDelete=${1}.sh
elif [ "$1" = chapter07 ]; then
  scriptToDelete="$ch7asroot $ch7chroot $ch7script"
elif [ "$1" = chapter08 ]; then
  scriptToDelete="$ch8script LFS-chroot.sh"
fi
for Script in $scriptToDelete; do
  for loc in $LFS ~/; do
    if [ -e $loc/$Script ]; then rm $loc/$Script; fi
  done
done
} #end cleanstart
#
addCommands () {
# add the commands for openssl and wget to $LFS/lfs-commands/chapter06
# or the linux-header commands to $LFS/lfs-commands/chapter08 if SECTION=update
# $1 is either chapter06 or update
local isChapter=$1
if [ "$isChapter" = chapter06 ]; then
  if [ -d "$LFS/lfs-commands/chapter06" ]; then
    if [ ! -e $LFS/lfs-commands/chapter06/058-openssl ]; then
      cat > $LFS/lfs-commands/chapter06/058-openssl << "EOF"
./config --prefix=/usr         \
         --openssldir=/etc/ssl \
         --libdir=lib          \
         shared

sed -i '/install_docs:/s/install_man_docs install_html_docs//' Makefile
make

sed -i '/INSTALL_LIBS/s/libcrypto.a libssl.a//' Makefile
make DESTDIR=$LFS MANSUFFIX=ssl install
EOF
    else
      echo "file $LFS/lfs-commands/chapter06/058-openssl exists"
      echo "check that it has the correct commands"
    fi
    if [ ! -e $LFS/lfs-commands/chapter06/059-wget ]; then
      cat > $LFS/lfs-commands/chapter06/059-wget << "EOF"
PKG_CONFIG_PATH=$LFS/usr/lib/pkgconfig    \
./configure --prefix=/usr                 \
            --sysconfdir=/etc             \
            --with-ssl=openssl            \
            --without-libpsl              \
            --without-zlib                \
            --disable-pcre                \
            --disable-pcre2               \
            --host=$LFS_TGT               \
            --build=$(build-aux/config.guess)

make

make DESTDIR=$LFS install
EOF
    else
      echo "file $LFS/lfs-commands/chapter06/059-wget exists"
      echo "check that it has the correct commands"
    fi
    return 0
  else
    echo "$LFS/lfs-commands/chapter06 doesn't exist"
    echo "download the book to create it"
    echo "Aborting"
    return $RETURN_PARAM
  fi
elif [ "$isChapter" = update ]; then # add linux-header commands to chapter08
  if [ -d "$LFS/lfs-commands/chapter08" ]; then
    if [ ! -e $LFS/lfs-commands/chapter08/072-linux-headers ]; then
      cat > $LFS/lfs-commands/chapter08/072-linux-headers << "EOF"
make mrproper
make headers
find usr/include -name '.*' -delete
rm usr/include/Makefile
cp -rv usr/include /usr
EOF
    else
      echo "file $LFS/lfs-commands/chapter08/072-linux-headers exists"
      echo "check that it has the correct commands"
      return 0
    fi
  else
    echo "$LFS/lfs-commands/chapter08 doesn't exist"
    echo "download the book to create it"
    echo "Aborting"
    return $RETURN_PARAM
  fi
else
  echo "** WARNING ** isChapter must either be "chapter06" or "update""
  echo "Aborting"
  return $RETURN_PARAM
fi
} # end addCommands
#
arrangeOrder () {
# $1 is the script to arrange
tmpfile=/tmp/$(date +%d%B%Y_%H:%M)tmp.file
local IFS=' ' # set the separator to a space
local WHICH_CHAPTER=$1
if [ "$WHICH_CHAPTER" = all ]; then
  scriptToArrange="${LFS}/${ch7script} ${LFS}/${ch8script}"
elif [ "$WHICH_CHAPTER" = chapter07 ]; then
  scriptToArrange="${LFS}/${ch7script}"
elif [ "$WHICH_CHAPTER" = chapter08 ]; then
  scriptToArrange="${LFS}/${ch8script}"
elif [ "$WHICH_CHAPTER" = update ]; then
  scriptToArrange="${LFS}/${updateScript}"
fi
for scrpt in $scriptToArrange; do
  Output=$scrpt
# match the start line for each function and output it
  awk '/_[[:space:]]\(\)[[:space:]]\{/ {print $1}' $Output >> $tmpfile

#
# the install order for Chapter08 in book version sysv is different from version systemd
# need to change the install order here
#
# TODO - this is a mess, but not sure there is an elegant solution to rearranging
#
  while read eachFunc; do
    if [[ "$WHICH_CHAPTER" = chapter08 || "$WHICH_CHAPTER" = update ]]; then
      if [[ "$SYSTEMD" = yes ]]; then # don't need sysklogd and sysvinit
        if [[ "$isSystemdBook" = false ]]; then # need to change the order
          if [[ "$eachFunc" = sysklogd_ || "$eachFunc" = sysvinit_ ]]; then
            : # don't write it
          elif [[ "$eachFunc" = procpsng_ || "$eachFunc" = e2fsprogs_ || "$eachFunc" = coreutils_ || "$eachFunc" = gperf_ || "$eachFunc" = intltool_ || "$eachFunc" = diffutils_ || "$eachFunc" = gawk_ || "$eachFunc" = findutils_ || "$eachFunc" = xz_ || "$eachFunc" = kmod_ || "$eachFunc" = utillinux_ || "$eachFunc" = mandb_ || "$eachFunc" = eudev_ ]]; then # will be moved
            :
          elif [[ "$eachFunc" = gdbm_ ]]; then # add gperf
            echo "$eachFunc
gperf_" >> $Output
          elif [[ "$eachFunc" = xmlparser_ ]]; then # add intltool
            echo "$eachFunc
intltool_" >> $Output
          elif [[ "$eachFunc" = automake_ ]]; then # ad xz
            echo "$eachFunc
xz_
kmod_" >> $Output
          elif [[ "$eachFunc" = systemd_ ]]; then # add procps-ng, etc
            echo "$eachFunc
procpsng_
e2fsprogs_
coreutils_
diffutils_
gawk_
findutils_" >> $Output
          elif [[ "$eachFunc" = dbus_ ]]; then # add util-linux and man-db
            echo "$eachFunc
utillinux_
mandb_" >> $Output
          else
            echo $eachFunc >> $Output
          fi
        else # SYSTEMD=yes and book is systemd, so keep the order unchanged
          if [[ "$eachFunc" = sysklogd_ || "$eachFunc" = sysvinit_ ]]; then
            : # don't write it
          else
            echo $eachFunc >> $Output
          fi
        fi
      else # chapter08 and SYSTEMD=no
        if [[ "$eachFunc" = dbus_ || "$eachFunc" = systemd_ ]]; then
          : # don't write it
        else 
          echo $eachFunc >> $Output
        fi
      fi
    else # chapter07 - need to move creatingdirs first
      if [[ "$eachFunc" = resetBashProfile_ ]]; then # has to come after pkguser
	    :
      elif [[ "$eachFunc" = pkguser_ ]]; then
         echo "$eachFunc
resetBashProfile_" >> $Output
      else # write them
        echo $eachFunc >> $Output
      fi
    fi
  done < $tmpfile
  rm $tmpfile
  chmod 700 $Output
done
} # end arrangeOrder
#
removeTests () {
# removes all the test commands from a script
# $1 is the script file, e.g. LFS/chapter07.sh
local scriptFile=$1
echo "Removing test commands for script $scriptFile"
sed -e '/make -k check 2>&1 | tee glibc-check-log/d' \
    -e '/grep Error glibc-check-log/d' \
    -e '/make check/d' \
    -e '/make -j1 check/d' \
    -e '/make -j4 check/d' \
    -e '/make -k check/d' \
    -e '/make -kj1 check/d' \
    -e '/make -k -j1 check/d' \
    -e '/make RUN_EXPENSIVE_TESTS=yes check/d' \
    -e '/TZ=UTC make test/d' \
    -e '/make check 2>&1 | tee gmp-check-log/d' \
    -e "/awk '\/# PASS:\/{total+=\$3} ; END{print total}' gmp-check-log/d" \
    -e '/ulimit -s 32768/,/contrib\/test_summary/d' \
    -e '/make NON_ROOT_USERNAME=nobody check-root/d' \
    -e '/echo "dummy:x:1000:nobody" >> \/etc\/group/d' \
    -e '/bash tests\/run.sh --srcdir=\$PWD --builddir=\$PWD/d' \
    -e '/chown -Rv nobody ./d' \
    -e '/su nobody -s \/bin\/bash -c "PATH=\$PATH make check"/d' \
    -e '/su nobody -s \/bin\/bash -c \"make RUN_EXPENSIVE_TESTS=yes check\"/d' \
    -e '/su nobody -s \/bin\/bash -c "make tests"/d' \
    -e "/sed -i '\/dummy\/d' \/etc\/group/d" \
    -e '/tester/d' \
    -e '/make test/d' \
    -e '/make -k test/d' \
    -e '/make -j1 test/d' \
    -e '/ninja_test/d' \
    -e '/make PERL5LIB=\$PWD\/tests/d' \
    -e '/make localedata\/install-locales/d' \
    -e '/ln -sfv \/tools\/lib\/lib{blk,uu}id.so.1 lib/,/make LD_LIBRARY_PATH=\/tools\/lib check/d' \
    -i $scriptFile
} # end removeTests
#
Start () {
cleanstart $WHICH_CHAPTER
local bookdir=$1
local book_version=$2
# if a single package used, then $3 is the package name
local singlePackage=$3
local listPackages
#
REPODIR=${bookdir}/$book_version
# build the requested chapters
reqChaps=$WHICH_CHAPTER
Chapter=$WHICH_CHAPTER # don't change Chapter, change reqChaps
if [ "$reqChaps" = all ]; then
  reqChaps=$allChaps
elif [ "$reqChaps" = update ]; then # want the packages from chapter08
  reqChaps=chapter08
fi
# set the output script name
for currentChapter in $reqChaps; do
  case $currentChapter in
     chapter05)
        Output=${LFS}/${ch5script}
     ;;
     chapter06)
        Output=${LFS}/${ch6script}
     ;;
     chapter07)
        Output=${LFS}/${ch7script}
     ;;
     chapter08)
        if [ "$Chapter" = update ]; then
          Output=${LFS}/${updateScript}
        else
          Output=${LFS}/${ch8script}
        fi
     ;;
     chapter10)
        Output=${LFS}/${ch10script}
     ;;
  esac
# TODO single package is a mess here, clean it up - cleanPkgDir is called if root and if a single_package
  if $single_package; then Output=${LFS}/${SINGLE_PACKAGE}.sh; fi # hope noone creates a package no
  Header # set the header values
  if $single_package; then
    listPackages=$singlePackage
    cleanPkgDir
    update_pkguser
    SetPkgVers
    createPkgfile
  else
    listPackages=$( awk -F\" '/href/ && !/<!--/ {gsub(/\.xml/,"");print $(NF -1)}' ${REPODIR}/${currentChapter}/${currentChapter}.xml )
  fi
# if chapter07 remove tcl, expect and dejagnu. They are in the chapter07.xml file
  if [ "$Chapter" = chapter07 ]; then
    for Name in $listPackages; do
      if [[ "$Name" = tcl || "$Name" = expect || "$Name" = dejagnu ]]; then
	listPackages=${listPackages/$Name/}
      fi
    done
  fi
# if chapter06 and installing as pkguser, add openssl and wget so can download sources in chapter07 and 08
  if [[ "$Chapter" = chapter06 && "$as_root" = false ]]; then
    nl='
'
    listPackages=$listPackages"${nl}"openssl"${nl}"wget""
  fi
  if [ "$Chapter" = update ]; then # add linux-headers
    nl='
'
    listPackages="linux-headers""${nl}"$listPackages
  fi
  for Name in $listPackages; do
# ignore systemd and dbus if using sysv
    if [[ "$isSystemdBook" = false && ("$Name" == systemd || "$Name" == dbus) ]]; then # not installed in this book version
      :
    else
      if [[ "$SYSTEMD" = yes && "$Name" = eudev ]]; then # ignore this - replaced by systemd
        :
      else
        FuncName=$( echo $Name | sed -e s/-//g ) # no - allowed in bash names
        PkgName=$( echo $Name | sed -e s/pass.$// -e s/-$// )
        SrcName=$PkgName-
        CmdName=$Name
        if [ "$CmdName" = python ]; then CmdName="Python"; fi
        case $currentChapter in  # deal with the 3 files in chapter07
           chapter07) # creates 3 files
             case $FuncName in
	         changingowner)
                   Output=${LFS}/${ch7asroot}
		 ;;
	         chroot)
                   Output=${LFS}/${ch7chroot}
# if you log out or reboot you need to mount the kernelfs again
# so include some conditionals to look after this
                   cat ${LFS}/${ch7asroot} \
                    | awk '/mount -v/ { printf "if [ \"$(grep -q \""$NF"\" /proc/mounts;echo $?)\" != \"0\" ]; then\n  "$0"\nfi\n"}' \
                    >> $Output
		 ;;
	         *)
                   Output=${LFS}/${ch7script}
		 ;;
             esac
          ;;
        esac
        case $PkgName in # call Function
           createfiles)
              if [ "$Chapter" != update ]; then
                Function
# Now have a base file structure so add pkguser
                if ! $as_root; then
                  pkguser
                else
                  copypkguserbin # add listpkg and necessary files
                fi
              fi
           ;;
           creatingdirs)
              if [ "$Chapter" != update ]; then
                Function
              else
                cleanPkgDir
                update_pkguser # add some files to the tools dir
                if $useDESTDIR; then
                  SetPkgVers
                  createPkgfile
                fi
              fi
           ;;
           expect)
              SrcName=expect5
              Function
           ;;
           fstab) # cannot deal with this here - created in chapter10
              :
           ;;
           gettext) 
              Function
              if [[ "$SYSTEMD" = yes && "$isSystemdBook" = false && "$currentChapter" = chapter06 ]]; then # add systemd
                for sysFile in systemd; do
                  FuncName=$sysFile
                  PkgName=$sysFile
                  SrcName=$sysFile-
                  Function
                done
              fi
           ;;
           introduction|toolchaintechnotes|generalinstructions|pkgmgt|aboutdebug)
              : # do not need any of these
           ;;
           kernfs)
              if [ "$Chapter" != update ]; then
                Output=${LFS}/${ch7asroot}
                Function
              fi
           ;;
           libelf)
              SrcName=elfutils-
              Function
           ;;
           libstdc++)
              PkgName=gcc
              SrcName=gcc-
	      if [ "$FuncName" = "libstdc++pass2" ]; then
		CmdName="gcc-libstdc++-pass2"
	      else
	        CmdName="gcc-libstdc++-pass1"
	      fi
              Function
 	   ;;    
           linux-headers|kernel)
              SrcName=linux-
              Function
           ;;
           patch) 
              Function
              if [[ "$SYSTEMD" = yes && "$isSystemdBook" = false && "$currentChapter" = chapter06 ]]; then
# add dbus after patch
                for sysFile in dbus; do
                  FuncName=$sysFile
                  PkgName=$sysFile
                  SrcName=$sysFile-
                  Function
                done
              fi
           ;;
           pkgconfig)
              PkgName=pkg-config
              CmdName=pkg-config
              SrcName=pkg-config-
              Function
           ;;
           procps)
              FuncName=procpsng
              PkgName=procps-ng
              CmdName=procps-ng
              SrcName=procps-ng-
              Function
           ;;
#          revisedchroot)
#              if [ "$Chapter" != update ]; then
#                Output=~/LFS-chroot.sh
# use this once LFS chapter08 is done, again conditionals added
#                cat ${LFS}/${ch7asroot} \
#                | awk '/mount -v/ {printf "if [ \"$(grep -q \""$NF"\" /proc/mounts;echo $?)\" != \"0\" ]; then\n  "$0"\nfi\n"}' \
#                >> $Output
#                WriteScript
#                Function
#              fi
#          ;;
           revisedchroot|strippingagain)
               if [ "$Chapter" != update ]; then
                Function
              fi
           ;;
           tcl)
                SrcName=tcl8.
                Function
           ;;
           vim) # if updating and MAKE_KERNEL=yes, add the kernel after vim
                Function
                if [[ "$currentChapter" == update && "$MAKE_KERNEL" == yes ]]; then
                  FuncName=kernel
                  PkgName=kernel
                  SrcName=linux-
                  CmdName=kernel
                  Chapter=chapter10
                  Function
                fi
           ;;
           xml-parser)
                SrcName=XML-Parser-
                Function
           ;;
           *)
              if [[ "$Chapter" == chapter10 && "$PkgName" == grub ]]; then # want the grub in chapter08 but not the one in chapter10
                :
              else
                Function
              fi
           ;;
        esac
      fi
    fi
  done
done
# use the latest src file version
#latestVers=$linuxvers
# get the latest kernel from the website
URLtoUse="https://www.kernel.org"
declare -a klines=($(python3 BShref.py $URLtoUse))
kernelURL=${klines[0]}
kernSrcFile=${kernelURL##*/}
echo "the latest kernel src file from kernel.org is $kernSrcFile"
rtrvers=""
latestVers=""
GetPkgVersion "" $kernSrcFile ".tar"
if [ "$?" = 0 ]; then
  if [ ! -z "$rtrvers" ]; then
    latestVers=$rtrvers
  else
    echo "rtrvers is NULL. Can't get the kernel version"
    echo "Investigate why this failed"
  fi
else
   echo "return value for kernel vers from GetPkgVersion is $? It should be zero"
   echo "Investigate why this didn't work"
fi
if [ -z "$linuxcomvers" ]; then
	linuxcomfnd=$(GetLinuxCommandVersion "${LFS}/${lfscommands}/chapter10" "kernel" "vmlinuz") # may have downloaded a later version than that in the book
  retval=$?
  if [ $retval -eq $RETURN_PARAM ]; then
    echo "vmlinuz command not found in ${LFS}/${lfscommands}/chapter10"
    echo "Cannot get the Linux version in the book."
    echo "Will not be able to compare the source version and the book version"
  else
    linuxcomExt="${linuxcomfnd#*-}"
    linuxcomvers="${linuxcomExt%-lfs*}"
    echo "Linux version from the commands is $linuxcomvers"
    echo "Will use latest kernel version which is $latestVers"
    sed -e "s/$linuxcomvers/$latestVers/g" -i $Output
  fi
else
  echo "Linux version from the commands is $linuxcomvers"
  echo "Will use latest kernel version which is $latestVers"
  sed -e "s/$linuxcomvers/$latestVers/g" -i $Output
fi
#
if [[ "$Chapter" != chapter07 && "$Chapter" != chapter08 && "$Chapter" != update ]]; then # 5, 6 and 10
# create the function name to run - use this if do not use arrangeOrder, e.g. chapter10
  awk '/_[[:space:]]\(\)[[:space:]]\{/ {print $1}' $Output >> $Output
else # 7, 8 and update
  arrangeOrder $WHICH_CHAPTER
fi
chmod 700 $Output # make it executable and if chapter07, asroot and chroot as well
if [ "$Chapter" = chapter07 ]; then
  chmod 700 ${LFS}/${Chapter}{-asroot.sh,-chroot.sh}
fi
#
# remove tests if not requested
if [ "$TESTS" = no ]; then
  echo "TESTS is set to no"
  IFSOLD=$IFS
  IFS=" "
  chapnum=""
  case $WHICH_CHAPTER in
     chapter05)
       chapnum="5"
     ;;
     chapter06)
       chapnum="6"
     ;;
     chapter07)
       chapnum="7"
     ;;
     chapter08)
       chapnum="8"
     ;;
     chapter10)
       chapnum="10"
     ;;
     all)
       chapnum="5 6 7 8 10"
     ;;
     update)
       chapnum="update"
     ;;
  esac
# deal with all first
  if [ "$chapnum" = "5 6 7 8 10" ]; then # no tests done in 10
    for chap in $chapnum; do
      tmp=ch${chap}script
      cur_script=${!tmp} # indirect expansion
      if [ ! -z "$cur_script" ]; then
        if [ "$TESTS" = no -a "$chapnum" != 10 ]; then removeTests ${LFS}/${cur_script}; fi
      fi
    done
  elif [ "$chapnum" = update ]; then # remove tests
    if $single_package; then
      if [ "$TESTS" = no ]; then removeTests "${LFS}/${SINGLE_PACKAGE}.sh"; fi
    else
      if [ "$TESTS" = no ]; then removeTests ${LFS}/${updateScript}; fi
    fi
  elif [ "$chapnum" != 10 ]; then # single chapter, not 10
    for chap in $chapnum; do
      tmp=ch${chap}script
      cur_script=${!tmp} # indirect expansion
      if [ ! -z "$cur_script" ]; then
        if [ "$TESTS" = no ]; then removeTests ${LFS}/${cur_script}; fi
      fi
    done
  fi
fi # tests are no
#
if [[ "$WHICH_CHAPTER" = chapter05 || "$WHICH_CHAPTER" = chapter06 || "$WHICH_CHAPTER" = all ]]; then
# make sure the build dir exists for chapter05/06.sh and set owner to lfs if installing as root
  if [ ! -d $buildDir ]; then
    mkdir -pv $buildDir
    if $as_root; then chown lfs $buildDir; fi
  else
    if $as_root; then chown lfs $buildDir; fi
  fi
fi
if [ "$WHICH_CHAPTER" = update ]; then
  if $useDESTDIR; then # change install commands to install to a specified DIR
    sed -i 's/make install/make DESTDIR="$CUR_DIR" install/' ${LFS}/${updateScript}
  fi
fi
IFS=$IFSOLD # put it back the way it was
} # end Start
#**********************************************************************************
#
# main program
#
#**********************************************************************************
# check if the user lfs exists on the target machine
if [ -e ${LFS}/etc/passwd ]; then
  chklfs=$(grep -c '^lfs:' ${LFS}/etc/passwd)
  if [ $chklfs -eq 1 ]; then
# get the uid
    useThisUID=$(grep '^lfs:' ${LFS}/etc/passwd | awk -F\: '{print $3}')
  else
    useThisUID="lfs" 
  fi
fi
#if $display_menu; then # allow editing of the config file
  configEdit # option to change the config file
  source $cfg # maybe config edited - update the values
#fi
#
# *** NOTE ***
# Since Sept 2016 there is one amalgamated development book for sysv and systemd
# This book has the address http://svn.linuxfromscratch.org/lfs/trunk/BOOK/ and the
# books are retrieved using REV='sysv' or REV='systemd' in the Makefile.
#
# For released versions of LFS, the first amalgamated book release is 7.10
# This is the only released book that will work here. Previous releases will probably break.
# The address of this book is http://svn.linuxfromscratch.org/lfs/tags/7.10/
#
# check WHICH_CHAPTER and DESTDIR
if [[ "$DESTDIR" = yes && "$WHICH_CHAPTER" != update ]]; then
  echo "****** NOTE ******"
  echo "DESTDIR is set to yes but WHICH_CHAPTER is set to $WHICH_CHAPTER"
  echo "WHICH_Chapter will be set to 'update' in order to continue."
  WHICH_CHAPTER="update"
fi
# useproxy
useProxy=false
if [ "$USEPROXY" = yes ]; then useProxy=true; fi
#
single_package=false
if [ "$SINGLE_PACKAGE" != no ]; then single_package=true; fi
#
# check DESTDIR and MAKE_KERNEL
if $single_package; then
  if [[ "$SINGLE_PACKAGE" = kernel && "$MAKE_KERNEL" == no ]]; then
    echo "SINGLE_PACKAGE is set to kernel and MAKE_KERNEL is no"
    echo "This will do nothing"
    echo "Set MAKE_KERNEL=yes and make sure the .config file has been"
    echo "copied to $SOURCEDIR"
    exit 1
  fi
fi
if [ "$MAKE_KERNEL" = yes ]; then # check the .config file is in place
  if [ ! -e ${SOURCEDIR}/.config ]; then
    echo "The Kernel .config file is not in $SOURCEDIR"
    echo "Place it there to continue."
    exit 1
  fi
fi
if $single_package; then
  if [ "$DESTDIR" = no ]; then
    echo "The SINGLE_PACKAGE option is meant to be used with DESTDIR"
    echo "Will set DESTDIR=yes and continue"
    DESTDIR="yes"
  fi
fi
useDESTDIR=false
if [ "$DESTDIR" = yes ]; then useDESTDIR=true; fi
#
as_root=false
if [ "$AS_ROOT" = yes ]; then # make sure lfs can write to BuildLog if not updating
  as_root=true
  if [ "$WHICH_CHAPTER" != update ]; then chown lfs ${LFS}/${BuildLog}; fi
else # root is owner of BuildLog when installing as a pkguser
  chown root ${LFS}/${BuildLog}
fi
wgetlist=$WGETLISTNAME # the name of the wget-list file
#
# set up the script filenames
# first initialize them to null
ch5script=""
ch6script=""
ch7asroot=""
ch7chroot=""
ch7script=""
ch8script=""
ch10script=""
updateScript=""
# set the scipt names
ch5script="chapter05.sh"
ch6script="chapter06.sh"
ch7asroot="chapter07-asroot.sh"
ch7chroot="chapter07-chroot.sh"
ch7script="chapter07.sh"
ch8script="chapter08.sh"
ch10script="chapter10.sh"
updateScript="update.sh"
WHICH_CHAPTER=$(echo ${WHICH_CHAPTER,,*}) # make sure it's lower case
# check the chapter name
case $WHICH_CHAPTER in
   chapter05|chapter06|chapter07|chapter08|chapter10|all|update)
     : # continue
   ;;
   *)
     echo "Invalid value for WHICH_CHAPTER. $WHICH_CHAPTER not allowed"
     echo "Should be one of chapter05, chapter06, chapter07, chapter08, chapter10, all or update"
     echo "Exiting now"
     exit 1
   ;;
esac
# check untested combinations
if [[ "$AS_ROOT" = yes && "$SOURCES" = atinstall ]]; then
  echo "*** WARNING ***"
  echo "You've chosen to install as root and to download the sources at install time"
  echo "This combination is untested and is likely not to work"
  echo "Do you wish to continue [y/N]?"
    read REPLY
    case $REPLY in
       [yY]|[yY][Ee][Ss])
          echo "Okay, continuing"
       ;;
       [nN]|[nN][Oo])
          echo "Okay, aborting"
          exit 1
       ;;
       *)
          echo "Okay, aborting"
          exit 1
       ;;
    esac
fi
#
# get the book
#
bookDir=$LFS_BOOK_LOC_DIR
# echo "book dir is $bookDir"
version=$BOOK_VERSION
# echo "book version is $version"
# set version properly
case $version in
   */)
     version=${version%?} # remove trailing /
   ;;
   SYSTEMD|Systemd|systemd) # not okay - abort
     echo "The book version should not be systemd."
     echo "To use systemd, set BOOK_VERSION=BOOK and SYSTEMD=yes in the menu."
     exit 1
   ;;
   Current_Development)
     version="BOOK"
   ;;
esac
# echo "book version is $version"
if [ ! -d $bookDir ]; then mkdir -pv $bookDir; fi
#
isSystemdBook=false # use sysv
if [ "$BOOK" = svn ]; then
  echo "Request to svn the book"
  if [ -z "$SVN_URL" -o "$SVN_URL" = "blank" ]; then
    SetSvnUrl "svn://svn.linuxfromscratch.org/lfs/"
  fi
  if [ "$BOOK_VERSION" != blank ]; then #check if the requested book is present locally
    ChkLocalBook $bookDir $version
    SetLFSBook $version
  else #version set to blank so ask for which book
# note - only books 7.10 and later are guaranteed to work. Previous ones haven't been tested.
    WhichLFSBook # choose which LFS version to download the xml files
# version ends with a / so remove it
    case $version in
       */)
         version=${version%?}
       ;;
    esac
    # check if the requested book is already present locally
    ChkLocalBook $bookDir $version
  fi
  CleanLocalREPO $bookDir $version
  CheckoutSVN $bookDir $version # svn the requested book xml files
else  # local book
  if [ "$BOOK_VERSION" != blank ]; then
    ChkLocalBookExists $bookDir $version
    return_val=$?
    if [ "$return_val" -eq $RETURN_PARAM ]; then # no local book found
      echo "The requested book was not found at $bookDir"
      echo "Change the location or svn it. Exiting now."
      exit 1
    else
      echo "Local book found at $bookDir with requested version $version"
      LocalBookFound $version # set type for locally stored book xml
    fi
  else # BOOK=local and version set to blank
    WhichLFSBook
# version ends with a / so remove it
    case $version in
       */)
         version=${version%?}
       ;;
    esac
    # check if the requested book is already present locally
    ChkLocalBook $bookDir $version
    if [ "$?" -eq $RETURN_PARAM ]; then # local book not found
      echo "The requested book was not found at $bookDir"
      echo "Change the location or svn it. Exiting now"
      exit 1
    fi
  fi
fi
VersToCompare=7.10 # first amalgamated book version
if [ "$SYSTEMD" = yes ]; then
  case $version in
     BOOK)
       isSystemdBook=true
     ;;
     7.10*)
       isSystemdBook=true
     ;;
     *systemd*) # old systemd book
       isSystemdBook=true
     ;;
     [0-9]*) # test if the version is > VersToCompare
       compare_versions $VersToCompare $version "."
       ret_val=$?
       if [ $ret_val -eq 0 ]; then isSystemdBook=true; fi
     ;;
  esac
fi
DumpCommands $REPO $bookDir $version #parse the LFS xml
#
# if chapter06 and installing as pkguser, add additional commands for openssl and wget
retVal=1
if [[ "$WHICH_CHAPTER" = chapter06 && "$as_root" = false ]]; then
  addCommands "chapter06"
  retVal=$?
elif [[ "$WHICH_CHAPTER" = update ]]; then
  addCommands "update"
  retVal=$?
fi
if [[ $retVal -eq $RETURN_PARAM ]]; then
  if [ "$WHICH_CHAPTER" = chapter06 ]; then
    echo "didn't find $LFS/lfs-commands/chapter06"
    echo "did you download the book?"
    echo "*** failed to add the commands for openssl and wget ***"
  elif [ "$WHICH_CHAPTER" = update ]; then
    echo "didn't find $LFS/lfs-commands/chapter08"
    echo "did you download the book?"
    echo "*** failed to add the commands for linux-headers ***"
  fi
elif [[ $retVal -eq 0 ]]; then
  if [ "$WHICH_CHAPTER" = chapter06 ]; then
    echo "Commands for openssl and wget are in ${LFS}/lfs-commands/chapter06"
  elif [ "$WHICH_CHAPTER" = update ]; then
    echo "Commands for linux-headers are in ${LFS}/lfs-commands/chapter08"
  fi
fi
# unpack the pkguser tarfile
pkgFileName="${PKGUSERFILE%.tar*}" # the name unpacked package file dir
# is there a tar package file present?
if [ -e ${LFS}${sourcedir}/${PKGUSERFILE} ]; then # unpack it
  if [ -d ${LFS}/tools/${pkgFileName} ]; then rm -rf ${LFS}/tools/${pkgFileName}; fi
  unpackPkguser $PKGUSERFILE
  if [ $? -eq $RETURN_PARAM ]; then # pkguser file failed to unpack
    echo "Package user file $PKGUSERFILE in ${LFS}${sourcedir}"
    echo "failed to unpack. Is it a tarfile?"
    echo "Exiting now"
    exit 1
  fi  
elif [ "$(grep -q ^pkguser ${LFS}/${BuildLog};echo $?)" == 0 ]; then
    echo "The pkguser is present in ${LFS}/$BuildLog"
    echo "continuing"
else
  if [ -d ${LFS}/tools/${pkgFileName} ]; then # already present
    if $as_root; then
      echo "Installing as root so ${LFS}/tools/${pkgFileName} won't be needed for installation"
    else
      echo "file ${LFS}/tools/${pkgFileName} is present"
    fi
  else
    echo "File $PKGUSERFILE not found in ${LFS}${sourcedir}"
    echo "Place it there to continue"
    exit 1
  fi
fi
#
# get the sources
#
wgetopts=""
ncc="--no-check-certificate"
# is a proxy server being used?
if $useProxy; then
# test if squid is present
  if [ -e /usr/bin/squid ]; then
# first set the proxy values - assumes port 3128
#
    ipaddr=$( /sbin/ip addr | grep "192.168" | awk '{print $2}' | awk -F\/ '{print $1}' )
    proxyset=http://${ipaddr}:3128/
    http_proxy=$proxyset
    ftp_proxy=$proxyset
    https_proxy=$proxyset
    wgetopts="-e http_proxy=$http_proxy -e ftp_proxy=$ftp_proxy -e https_proxy=$https_proxy"
  else # squid not installed
    useProxy=false
  fi
fi # end test useProxy
# declare a global array to hold any missing src file names
declare -a filesNotPresent
#
version=${version%/} # remove any trailing /
SourceDir=${SOURCEDIR}/${version}
sourceloc=${sourcedir}/${version} # location wrt lfs system
WgetList=${SourceDir}/${wgetlist}
if [ ! -e $WgetList ]; then
  echo "wget-list file $WgetList doesn't exist"
  echo "will get it from the book" 
fi
#
# if SINGLE_PACKAGE requested, check if the package src file is in the wget-list file
# if it isn't, try and download it
#
if $single_package; then
  case $SINGLE_PACKAGE in
     linux-headers)
       filesNotPresent[0]=linux
     ;;
     kernel)
       filesNotPresent[0]=linux
     ;;
     xml-parser)
       filesNotPresent[0]=XML-Parser
     ;;
     *)
       filesNotPresent[0]=$SINGLE_PACKAGE
     ;;
  esac 
  rtrnName=""
  if [ ! -e $WgetList ]; then
    echo "$WgetList file doesn't exist"
    echo "You need to download the source for $SINGLE_PACKAGE and place in $SourceDir"
  else # wget-list in place so check single package exists
#    echo "filesNotPresent is ${filesNotPresent[@]}"
    ChkPkgExists $WgetList filesNotPresent[@]
    retval=$?
    if [ $retval -eq $RETURN_PARAM ]; then # wget-list file doesn't exist
      echo "No $WgetList file present"
      echo "Will download the source for ${filesNotPresent[0]}"
    elif [ $retval -eq $RETURN_FNF ]; then
      echo "${filesNotPresent[0]} not found in $WgetList"
      echo "Check the package name"
      exit 1
    else
      filesNotPresent[0]=$rtrnName
    fi
  fi
# check if source(s) already downloaded
  if [ "$SOURCES" = download ]; then
#    echo "single package is ${filesNotPresent[0]}"
    if [ ! -d $SourceDir ]; then install -v -m0755 -d $SourceDir; fi
    if [ "$CLEAN_SRC_DIR" = yes ]; then CleanSourceDir $SourceDir $WgetList; fi
    if [ -e $WgetList ]; then
      ChkSrcPresent $SourceDir $WgetList filesNotPresent[@]
      ret_val=$?
      if [ $ret_val -eq 0 ]; then
        echo "Package ${filesNotPresent[0]} present in $SourceDir"
        echo "Continuing without downloading ${filesNotPresent[0]}"
      else
        echo "Package file ${filesNotPresent[0]} not present in $SourceDir"
        echo "Will download it using $WgetList file"
        if hash wget 2>/dev/null; then
           GetSource $version $SourceDir $WgetList $bookDir filesNotPresent[@] # download LFS sources
        else
           echo "The host does not have wget installed."
           echo "Please install it in order to download the source(s)."
           echo "Exiting now."
           exit 1
        fi
      fi
    else # no wget-list present so need to get it
      if hash wget 2>/dev/null; then
        GetSource $version $SourceDir $WgetList $bookDir filesNotPresent[@] # download LFS sources
      else
         echo "The host does not have wget installed."
         echo "Please install it in order to download the source(s)."
         echo "Exiting now."
         exit 1
      fi
    fi
  else # source is local - check it's there
    echo "Checking if source file is in $SourceDir"
    if [ ! -d $SourceDir ]; then
      echo "You have said that the source is local but"
      echo "directory $SourceDir does not exist"
      echo "Change the config file to make SOURCES = 'download'"
      echo "or download it yourself and place in $SourceDir"
      echo "Will continue to write the requested script."
    fi
    if [ ! -e $WgetList ]; then
      echo "No $WgetList file present in $SourceDir"
      echo "Won't be able to check if the source file exists"
    else
      ChkSrcPresent $SourceDir $WgetList filesNotPresent[@] # check for src file present
      ret_val=$?
      if [ $ret_val -eq $RETURN_PARAM ]; then
        echo "Requested file ${filesNotPresent[0]} has not been downloaded"
        echo "Can download it and place in $SourceDir"
        echo "Do you wish to continue? (Y/n)"
        read reply
        case $reply in
          [yY]|[yY][Ee][Ss])
            echo "okay continuing"
# TODO download the single_package file here
          ;;
          [nN]|[nN][Oo])
            echo "Exiting now"
            exit 1
          ;;
          *)
            echo "okay continuing"
# TODO download the single_package file here
          ;;
        esac
      else
        echo "Source file ${filesNotPresent[0]} present in $SourceDir"
      fi
    fi
  fi
  # check if the file is empty
  ChkEmptySrcFiles $SourceDir ${filesNotPresent[0]} #check for failed downloads
  return_val=$?
  if [ "$return_val" -eq $RETURN_FNF ]; then
    echo "Source file ${filesNotPresent[0]} not found in $SourceDir"
    echo "Check why it's not there"
    exit 1
  elif [ "$return_val" -eq $RETURN_PARAM ]; then
    echo "Source file ${filesNotPresent[0]} is empty."
    echo "You need to download this file and place it in $SourceDir"
    echo "before running the script"
  fi
else # all sources requested
  downloadSrc=false
  if [ ! -d $SourceDir ]; then install -v -m0755 -d $SourceDir; fi
  if [ "$SOURCES" = atinstall ]; then # need the wget-list file and the md5sums
    if [ ! -e $WgetList ]; then # wget-list doesn't exist, get it from the book
      REPODIR=${bookDir}/${version}
      make -j1 -f ${REPODIR}/Makefile -C $REPODIR BASEDIR=$SourceDir REV="systemd" $WgetList ${SourceDir}/md5sums
      md5sums=${SourceDir}/md5sums
    else
      echo "$WgetList file exists"
# make sure the md5sums file is present too
      if [ ! -e  ${SourceDir}/md5sums ]; then # get it from $LFS/lfs-html
	echo "the md5sums file isn't present in $SourceDir"
	echo "will copy it from $LFS/lfs-html"
	cp -v $LFS/lfs-html/md5sums ${SourceDir}/md5sums
	md5sums=${SourceDir}/md5sums
      else
        echo "md5sums file found in $SourceDir"
	md5sums=${SourceDir}/md5sums
      fi
    fi
  elif [ "$SOURCES" = download ]; then
    downloadSrc=true 
    if [ "$CLEAN_SRC_DIR" = yes ]; then CleanSourceDir $SourceDir $WgetList; fi
# check if src dir is not empty and the wgetlist file is already in place
#    if [[ "$(ls -A $SourceDir)" && -e $WgetList ]]; then
    if [ -e $WgetList ]; then
      ChkSrcPresent $SourceDir $WgetList filesNotPresent[@] # check for src files present
      ret_val=$?
      if [ $ret_val -eq 0 ]; then # all files are present
        echo "You requested 'download' for the sources"
        echo "but they are already present in $SourceDir"
        if [ "$UPDATESRCFILES" = yes ]; then
          echo "Will download any more-recent source files and update $WgetList."
        else
          echo "Continuing without updating any source files."
        fi
        downloadSrc=false
      else
        echo "Will download the following files:"
        for (( i=0; i<${#filesNotPresent[@]}; i++ )); do
          echo ${filesNotPresent[i]}
        done
      fi
    fi
    if [ "$UPDATESRCFILES" = yes ]; then
      if [ -e ${WgetList} ]; then
        GetLatestVers $WgetList "lfs-systemd" true false # download latest source files and update wget-list
      else
        echo "You've requested an update of the source files but there is no existing file $WgetList"
        echo "Cannot update source versions without this file"
      fi
    fi
    if $downloadSrc; then
      echo "Will use wget to download the sources"
      if hash wget 2>/dev/null; then
         GetSource $version $SourceDir $WgetList $bookDir filesNotPresent[@] # download LFS sources
# now search for any older versions of the downloaded files and offer to delete them
         for chkFiles in ${filesNotPresent[@]}; do
#echo "downloaded file is $chkFiles"
           pkgnmOnly=$(GetPkgName $chkFiles) 
           GetPkgVersion $SourceDir $pkgnmOnly- .tar
           generalfname=${pkgnmOnly}*.tar.*z* # NOTE amend for fname without tar
           olderVers=( $(ls -l ${SourceDir}/${generalfname} | awk -F\/ '{print $NF}') )
           numoldvers=${#olderVers[@]}
           if [ $numoldvers -eq 1 ]; then # only one version present - good, do nothing
             :
           elif [ $numoldvers -gt 1 ]; then
             echo "There is more than one version of package $pkgnmOnly in $SourceDir"
             for (( ik=0; ik < $numoldvers; ik++ )); do
               if [ "${olderVers[ik]}" != "$chkFiles" ]; then # delete it?
                 echo "Do you want to delete ${olderVers[ik]} (Default is Y)"
                 read reply
                 case $reply in
                    [yY]|[yY][Ee][Ss])
                        rm -v ${SourceDir}/${olderVers[ik]}
                    ;;
                    [nN]|[nN][Oo])
                        echo "okay, ${SourceDir}/${olderVers[ik]} left in place"
                    ;;
                    *)
                        rm -v ${SourceDir}/${olderVers[ik]}
                    ;;
                 esac
               fi
             done
           elif [ $numoldvers -eq 0 ]; then # HELP something's gone wrong
             echo "ERROR - numoldvers=0 . This should never happen. ABORT"
             exit 1
           fi
         done
      else
         echo "The host does not have wget installed."
         echo "Please install it in order to download the sources."
         echo "Exiting now."
         exit 1
      fi
    fi
    ChkEmptySrcFiles $SourceDir # check for failed downloads
    return_val=$?
    if [ "$return_val" -eq $RETURN_FNF ]; then
      echo "Source file ${filesNotPresent[0]} not found in $SourceDir"
      echo "Check why it's not there"
      exit 1
    elif [ "$return_val" -eq $RETURN_PARAM ]; then
      echo "Empty source files found in $SourceDir"
      echo "You need to download these and place them in $SourceDir"
      echo "before running the scripts"
    fi
  else # sources are local - check if update of source files is requested
    echo "Checking if sources are in $SourceDir"
    if [ ! -d $SourceDir ]; then
      echo "You have said that the sources are local but"
      echo "directory $SourceDir does not exist"
      echo "Change the config file to make SOURCES=download"
      echo "or download them yourself and place in $SourceDir"
      echo "Will continue to write the requested script(s)."
    fi 
    if [ ! -e $WgetList ]; then
      echo "No $WgetList file present in $SourceDir"
      echo "Won't be able to check if LFS sources exist"
      if [ "$UPDATESRCFILES" = yes ]; then
        echo "Won't be able to update the sources files"
      fi
    else # wget-list file exists
      if [ "$UPDATESRCFILES" = yes ]; then
        GetLatestVers $WgetList "lfs-systemd" true false # download latest source files and update wget-list
      fi
      ChkSrcPresent $SourceDir $WgetList filesNotPresent[@] # check for src files present
      ret_val=$?
      if [ $ret_val -eq $RETURN_PARAM ]; then 
        echo "Not all requested files in $WgetList have been downloaded"
        echo "You will have to download those that are missing and place them in $SourceDir"
        echo "Do you wish to continue? (Y/n)"
        read reply
        case $reply in
          [yY]|[yY][Ee][Ss])
            echo "okay continue"
          ;;        
          [nN]|[nN][Oo])
            echo "Exiting now"
            exit 1
          ;;        
          *)   
            echo "okay continue"
          ;;        
        esac
      fi
    fi
# check if $SourceDir exists and has files in it
    if [ -d $SourceDir ]; then
      if [ "$(ls -A $SourceDir)" ]; then # has files
        ChkEmptySrcFiles $SourceDir # check for failed downloads
        return_val=$?
        if [ "$return_val" -eq $RETURN_FNF ]; then
          echo "Source file ${filesNotPresent[0]} not found in $SourceDir"
          echo "Check why it's not there"
          exit 1
        elif [ "$return_val" -eq $RETURN_PARAM ]; then
          echo "Empty source files found in $SourceDir"
          echo "You need to download these and place them in $SourceDir"
          echo "before running the scripts"
        fi
      fi
    else
      echo "Source Dir $SourceDir doesn't exist. Will create it"
      mkdir -pv $SourceDir
    fi
  fi
fi
if [ -d $SourceDir -a "$(ls -A $SourceDir)" ]; then # source dir exists and has files in it
  if $single_package; then
    listPkgs=($SINGLE_PACKAGE)
  else # get src versions for all the following
    listPkgs=(bzip2 coreutils dbus gcc glibc gmp kernel mpc mpfr perl python3 systemd util-linux)
  fi
# read the contents of the wget-list file into a variable for the src downloads
  sourceURL="$(<"$WgetList")"
#  echo "sourceURL is ${sourceURL[@]}"
  if [[ "$SOURCES" = atinstall ]]; then
# read the contents of the md5sums file into a variable to get pkg versions
#echo "md5sums is $md5sums"
    srcFileName="$(<"$md5sums")"
#  echo "srcFileName is ${srcFileName[@]}"
    echo "Requested source files downloaded at install time."
    echo "The src package versions will come from the md5sums file,"
    echo "not from the actual src tarfiles."
  fi
# get the required package versions and patch filenames
  for (( i=0; i<${#listPkgs[@]}; i++ )); do
    case ${listPkgs[i]} in
       bzip2)
         if [ "$SOURCES" = atinstall ]; then # use md5sums
           for srcFile in ${srcFileName[@]}; do # need the name of the patch
             case $srcFile in
                *bzip2*.patch*)
                  bzip2Patch=$srcFile
		  echo "bzip2 patch is $bzip2Patch"
                  break
                ;;
             esac
           done
         else # get the patch name from the sources directory
           rtrvers=""
           GetPkgVersion $SourceDir bzip2- "" patch returnName
           bzip2Patch=$rtrvers
           echo "bzip2 patch is $bzip2Patch"
         fi
       ;;
       coreutils)
         if [ "$SOURCES" = atinstall ]; then # use md5sums
           for srcFile in ${srcFileName[@]}; do # need the name of the patch
             case $srcFile in
                *coreutils*.patch*)
                  coreutilsPatch=$srcFile
                  echo "coreutils patch is $coreutilsPatch"
                  break
                ;;
             esac
           done
         else # get the patch name from the sources directory
           rtrvers=""
           GetPkgVersion $SourceDir coreutils- "" patch returnName
           coreutilsPatch=$rtrvers
           echo "coreutils patch is $coreutilsPatch"
         fi
       ;;
       dbus)
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           for srcFile in ${srcFileName[@]}; do
             case $srcFile in
                *dbus-*)
                  rtrvers=""
                  dbusvers=""
                  GetPkgVersion "" $srcFile ".tar"
		  if [ "$?" = 0 ]; then
                    dbusvers=$rtrvers
		    if [ ! -z "$dbusvers" ]; then echo "dbus version is $dbusvers"; fi
		  else
                    echo "return value for dbus is $?"
		    echo "Investigate why this didn't work"
                  fi
                  break
                 ;;
             esac
	   done
         elif [ "$SYSTEMD" = yes ]; then # use the src files in $SourceDir
           rtrvers=""
           dbusvers=""
           GetPkgVersion $SourceDir dbus- .tar
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "*** Directory $SourceDir doesn't exist ***"
           elif [ $retval -eq $RETURN_FNF ]; then
             echo "*** No file found containing the name dbus- and tar found ***"
           elif [ $retval -eq $RETURN_MTOV ]; then
             echo "*** More than one version of dbus- found in $SourceDir ***"
           elif [ $retval -eq 0 ]; then
             dbusvers=$rtrvers
             if [ ! -z "$dbusvers" ]; then echo "dbus version is $dbusvers"; fi
           fi
         fi
       ;;
       gcc)
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           for srcFile in ${srcFileName[@]}; do
             case $srcFile in
                *gcc-*)
                  rtrvers=""
                  gccvers=""
                  GetPkgVersion "" $srcFile ".tar"
                  if [ "$?" = 0 ]; then
                    gccvers=$rtrvers
                    if [ ! -z "$gccvers" ]; then echo "gcc version is $gccvers"; fi
                  else
                    echo "return value for gcc is $?"
		    echo "Investigate why this didn't work"
                  fi
                  break
                 ;;
             esac
           done
         else
           rtrvers=""
           GetPkgVersion $SourceDir gcc- .tar
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "*** Directory $SourceDir doesn't exist ***"
           elif [ $retval -eq $RETURN_FNF ]; then
             echo "*** No file found containing the name gcc- and tar found ***"
           elif [ $retval -eq $RETURN_MTOV ]; then
             echo "*** More than one version of gcc- found in $SourceDir ***"
           elif [ $retval -eq 0 ]; then
             gccvers=$rtrvers
             if [ ! -z "$gccvers" ]; then echo "gcc version is $gccvers"; fi
           fi
         fi
       ;;
       glibc)
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           for srcFile in ${srcFileName[@]}; do
             case $srcFile in
                *glibc-*)
                  rtrvers=""
                  glibcvers=""
                  GetPkgVersion "" $srcFile ".tar"
                  if [ "$?" = 0 ]; then
                    glibcvers=$rtrvers
                    if [ ! -z "$glibcvers" ]; then echo "glibc version is $glibcvers"; fi
                  else
                    echo "return value from GetPkgVersion for glibc is $?"
		    echo "Investigate why this didn't work"
                  fi
                  break
                 ;;
             esac
           done
         else
           rtrvers=""
           glibcvers=""
           GetPkgVersion $SourceDir glibc- .tar
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "*** Directory $SourceDir doesn't exist ***"
           elif [ $retval -eq $RETURN_FNF ]; then
             echo "*** No file found containing the name glibc- and tar found ***"
           elif [ $retval -eq $RETURN_MTOV ]; then
             echo "*** More than one version of glibc- found in $SourceDir ***"
           elif [ $retval -eq 0 ]; then
             glibcvers=$rtrvers
             if [ ! -z "$glibcvers" ]; then
               echo "glibc version is $glibcvers"
             else
               echo "Failed to get glibc version"
               echo "You'll need to rectify this or manually edit the script."
             fi
           fi
	 fi
# need to know the name of the tzdata file from the commands
         tzdataFile=$(GetLinuxCommandVersion "${LFS}/${lfscommands}/chapter08" "glibc" "tzdata")
	 echo "tzdata file is $tzdataFile"
       ;;
       gmp) # need the version if downloading at install time
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           for srcFile in ${srcFileName[@]}; do
             case $srcFile in
                *gmp-*)
                  rtrvers=""
                  gmpvers=""
                  GetPkgVersion "" $srcFile ".tar"
                  if [ "$?" = 0 ]; then
                    gmpvers=$rtrvers
                    if [ ! -z "$gmpvers" ]; then echo "gmp version is $gmpvers"; fi
                  else
                    echo "return value from GetPkgVersion for gmp is $?"
                    echo "Investigate why this didn't work"
                  fi
                  break
                 ;;
             esac
           done
         fi
       ;;
       kernel)
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           for srcFile in ${srcFileName[@]}; do
             case $srcFile in
                *linux-*)
                  rtrvers=""
                  linuxvers=""
                  GetPkgVersion "" $srcFile ".tar"
                  if [ "$?" = 0 ]; then
                    linuxvers=$rtrvers
                    if [ ! -z "$linuxvers" ]; then echo "kernel version is $linuxvers"; fi
                  else
                    echo "return value from GetPkgVersion for kernel is $?"
                    echo "Investigate why this didn't work"
                  fi
                  break
                 ;;
             esac
           done
         else
           GetLinuxVersion $SourceDir
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "Unable to get Linux source version."
             echo "No source file found in $SourceDir"
             echo "**Warning** - value of kernel Src version is not set"
           else
             echo "kernel version from the src file is $linuxvers"
           fi
	 fi
       ;;
       mpc) # need the version if downloading at install time
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           for srcFile in ${srcFileName[@]}; do
             case $srcFile in
                *mpc-*)
                  rtrvers=""
                  mpcvers=""
                  GetPkgVersion "" $srcFile ".tar"
                  if [ "$?" = 0 ]; then
                    mpcvers=$rtrvers
                    if [ ! -z "$gmpvers" ]; then echo "mpc version is $mpcvers"; fi
                  else
                    echo "return value from GetPkgVersion for mpc is $?"
                    echo "Investigate why this didn't work"
                  fi
                  break
                 ;;
             esac
           done
         fi
       ;;
       mpfr) # need the version if downloading at install time
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           for srcFile in ${srcFileName[@]}; do
             case $srcFile in
                *mpfr-*)
                  rtrvers=""
                  mpfrvers=""
                  GetPkgVersion "" $srcFile ".tar"
                  if [ "$?" = 0 ]; then
                    mpfrvers=$rtrvers
                    if [ ! -z "$mpfrvers" ]; then echo "mpfr version is $mpfrvers"; fi
                  else
                    echo "return value from GetPkgVersion for mpfr is $?"
                    echo "Investigate why this didn't work"
                  fi
                  break
                 ;;
             esac
           done
         fi
       ;;
       perl)
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           for srcFile in ${srcFileName[@]}; do
             case $srcFile in
                *perl-*)
                  rtrvers=""
                  perlvers=""
                  GetPkgVersion "" $srcFile ".tar"
                  if [ "$?" = 0 ]; then
                    perlvers=$rtrvers
                    if [ ! -z "$perlvers" ]; then echo "perl version is $perlvers"; fi
                    GetSeriesNum $perlvers
                    perlseries=$rtrseries
                    echo "perl series is $perlseries"
                  else
                    echo "return value from GetPkgVersion for perl is $?"
                    echo "Investigate why this didn't work"
                  fi
                  break
                 ;;
             esac
           done
         else
           rtrvers=""
           GetPkgVersion $SourceDir perl- .tar
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "*** Directory $SourceDir doesn't exist ***"
           elif [ $retval -eq $RETURN_FNF ]; then
             echo "*** No file found containing the name perl- and tar found ***"
           elif [ $retval -eq $RETURN_MTOV ]; then
             echo "*** More than one version of perl- found in $SourceDir ***"
           elif [ $retval -eq 0 ]; then
             perlvers=$rtrvers
             if [ ! -z "$perlvers" ]; then
               echo "perl version is $perlvers"
               GetSeriesNum $perlvers
               perlseries=$rtrseries
               echo "perl series is $perlseries"
             else # try a different source loc
               if [ -d $LFS/sources/BOOK ]; then
                 GetPkgVersion $LFS/sources/BOOK perl- tar
                 perlvers=$rtrvers
                 if [ ! -z "$perlvers" ]; then
                   echo "perl version is $perlvers"
		   GetSeriesNum $perlvers
                   perlseries=$rtrseries
                   echo "perl series is $perlseries"
                 fi
               fi
             fi
           fi
	 fi
       ;;
       python3)
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           for srcFile in ${srcFileName[@]}; do
             case $srcFile in
                *Python-*)
                  rtrvers=""
                  pythonvers=""
                  GetPkgVersion "" $srcFile ".tar"
                  if [ "$?" = 0 ]; then
                    pythonvers=$rtrvers
                    if [ ! -z "$pythonvers" ]; then echo "python3 version is $pythonvers"; fi
		    GetSeriesNum $pythonvers
                    pythonseries=$rtrseries
                    echo "python3 series is $pythonseries"
                  else
                    echo "return value from GetPkgVersion for python3 is $?"
                    echo "Investigate why this didn't work"
                  fi
                  break
                 ;;
             esac
           done
         else
           rtrvers=""
           GetPkgVersion $SourceDir Python- .tar
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "*** Directory $SourceDir doesn't exist ***"
           elif [ $retval -eq $RETURN_FNF ]; then
             echo "*** No file found containing the name python- and tar found ***"
           elif [ $retval -eq $RETURN_MTOV ]; then
             echo "*** More than one version of python- found in $SourceDir ***"
           elif [ $retval -eq 0 ]; then
             pythonvers=$rtrvers
             if [ ! -z "$pythonvers" ]; then
               echo "python3 version is $pythonvers"
               GetSeriesNum $pythonvers
               pythonseries=$rtrseries
               echo "python3 series is $pythonseries"
             else # try a different source loc
               if [ -d $LFS/sources/BOOK ]; then
                 GetPkgVersion $LFS/sources/BOOK Python- tar
                 pythonvers=$rtrvers
                 if [ ! -z "$pythonvers" ]; then echo "python version is $pythonvers"; fi
                 GetSeriesNum $pythonvers
                 pythonseries=$rtrseries
                 echo "python3 series is $pythonseries"
               else
                 echo "*** Warning - unable to get python version. No source found."
               fi
             fi
           fi
	 fi
       ;;
       systemd)
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           for srcFile in ${srcFileName[@]}; do
             case $srcFile in
                *systemd-[0-9]*z*)
                  rtrvers=""
                  systemdvers=""
                  GetPkgVersion "" $srcFile ".tar"
                  if [ "$?" = 0 ]; then
                    systemdvers=$rtrvers
                    if [ ! -z "$systemdvers" ]; then echo "systemd version is $systemdvers"; fi
                  else
                    echo "return value from GetPkgVersion for systemd is $?"
                    echo "Investigate why this didn't work"
                  fi
                ;;
                *systemd-*.patch) # need to know the name of the patch
                  systemdPatch=$srcFile
                  echo "systemd patch is $systemdPatch"
                ;;
                *systemd-man-pages-*) # need the name of the man-pages file
                  systemdManPages=$srcFile
                  echo "systemd man-pages file is $systemdManPages"
                ;;
             esac
           done
         else
           rtrvers=""
           GetPkgVersion $SourceDir systemd- .tar
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "*** Directory $SourceDir doesn't exist ***"
           elif [ $retval -eq $RETURN_FNF ]; then
             echo "*** No file found containing the name systemd- and tar found ***"
           elif [ $retval -eq $RETURN_MTOV ]; then
             echo "*** More than one version of systemd- found in $SourceDir ***"
           elif [ $retval -eq 0 ]; then
             systemdvers=$rtrvers
             if [ ! -z "$systemdvers" ]; then echo "systemd version is $systemdvers"; fi
           fi
           rtrvers="" # get the patch name from the source directory
           GetPkgVersion $SourceDir systemd- "" patch returnName
           systemdPatch=$rtrvers
           echo "systemd patch is $systemdPatch"
	 fi
       ;;
       util-linux)
         if [ "$SOURCES" = atinstall ]; then # use the md5sums file
           for srcFile in ${srcFileName[@]}; do
             case $srcFile in
                *util-linux-*)
                  rtrvers=""
                  utillinuxvers=""
                  GetPkgVersion "" $srcFile ".tar"
                  if [ "$?" = 0 ]; then
                    utillinuxvers=$rtrvers
                    if [ ! -z "$utillinuxvers" ]; then echo "util-linux version is $utillinuxvers"; fi
                  else
                    echo "return value from GetPkgVersion for util-linux is $?"
                    echo "Investigate why this didn't work"
                  fi
                  break
                 ;;
             esac
           done
         else
           rtrvers=""
           GetPkgVersion $SourceDir util-linux- .tar
           retval=$?
           if [ $retval -eq $RETURN_PARAM ]; then
             echo "*** Directory $SourceDir doesn't exist ***"
           elif [ $retval -eq $RETURN_FNF ]; then
             echo "*** No file found containing the name util-linux- and tar found ***"
           elif [ $retval -eq $RETURN_MTOV ]; then
             echo "*** More than one version of $util-linux found in $SourceDir ***"
           elif [ $retval -eq 0 ]; then
             utillinuxvers=$rtrvers
             if [ ! -z "$utillinuxvers" ]; then echo "util-linux version is $utillinuxvers"; fi
           fi
	 fi
       ;;
    esac
  done
#GetPkgVersion $SourceDir gettext- tar
#gettextvers=$rtrvers
#if [ ! -z "$gettextvers" ]; then
#  echo "gettext version is $gettextvers"
#else
#  echo "*** Warning *** the /usr/share/doc/gettext dir in the configure script won't be set correctly because could not get the gettext version. Edit it yourself in chapter06.sh."
#fi
#
elif [ ! -d $SourceDir ]; then
  echo "The source dir $SourceDir doesn't exist. Can't get package versions"
else
  echo "The source dir $SourceDir exists but is empty. Can't get package versions"
fi
if [[ "$single_package" = false || "$SINGLE_PACKAGE" = kernel ]]; then
  if [[ "$WHICH_CHAPTER" = chapter10 || "$WHICH_CHAPTER" = all || "$WHICH_CHAPTER" = update ]]; then
    if [[ -d ${LFS}/${lfscommands}/chapter10 && -d $SourceDir ]]; then
      if [ ! -z "$linuxvers" ]; then
        echo "kernel version from the source file is $linuxvers"
      else
        echo "unable to get the kernel version from the source"
	echo "investigate what went wrong"
	echo "Aborting"
	exit 1
      fi
      linuxcomfnd=$(GetLinuxCommandVersion ${LFS}/${lfscommands}/chapter10 "kernel" "vmlinuz") # may have downloaded a later version than that in the book
      retval=$?
      if [ $retval -eq $RETURN_PARAM ]; then
        echo "vmlinuz command not found in ${LFS}/${lfscommands}/chapter08"
        echo "Cannot get the kernel version in the book."
        echo "Will not be able to compare the source version and the book version"
      else
        linuxcomExt="${linuxcomfnd#*-}"
        linuxcomvers="${linuxcomExt%-lfs*}"
        echo "kernel version from the commands is $linuxcomvers"
      fi
    else
      echo "Won't be able to compare the kernel src version with the kernel version from the $lfscommands file"
    fi
  fi
fi
Start $bookDir $version $SINGLE_PACKAGE # build the scripts
# if installing as root and chapter 5 and 6, set script owner to lfs
if $as_root; then
  case $Chapter in
     chapter05)
       chown lfs ${LFS}/${ch5script}
       chown lfs ${LFS}/${BuildLog}
     ;;
     chapter06)
       chown lfs ${LFS}/${ch6script}
       chown lfs ${LFS}/${BuildLog}
     ;;
  esac
fi
